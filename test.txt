
> @unlockddao/unlockd-protocol@1.0.2 test
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/*.spec.ts


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/home/fvenancio/Projects/unlockd/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  main
  - Provider URL: eth-mainnet.g.alchemy.com
  - Network : hardhat
Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 1000000.0 ETH
LendPool Liquidator: 0xA2874be6Acdc314dd055f6869a2dBdF62c983436 Balance: 1000000.0 ETH


Migration started


Deploy Punks Market and Wrapped Punk
*** CryptoPunksMarket ***

Network: hardhat
tx: 0x7e2b217c1470cc33d07800e41e372cd77257cbc90b9fbbcc29ffd96c0ba31134
contract address: 0xB4B4ead1A260F1572b88b9D8ABa5A152D166c104
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 36913595807
gas used: 2378109

******

contracts-helpers:registerContractInJsonDb, contractId: CryptoPunksMarket address: 0xB4B4ead1A260F1572b88b9D8ABa5A152D166c104 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WrappedPunk ***

Network: hardhat
tx: 0x210a2f28e6d5d33859e30796b5b3fc41e14f7d66c2a9b3f939340667a687636b
contract address: 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 34139385195
gas used: 1992593

******

contracts-helpers:registerContractInJsonDb, contractId: WrappedPunk address: 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy proxy admin
*** UnlockdProxyAdminPool ***

Network: hardhat
tx: 0xba201ca13d7e343fef6299c18ee3d48f027a23a40f439018e33b5af5e421ecff
contract address: 0xb2f97A3c2E48cd368901657e31Faaa93035CE390
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 27560281204
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminPool address: 0xb2f97A3c2E48cd368901657e31Faaa93035CE390 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
ProxyAdminPool Address: 0xb2f97A3c2E48cd368901657e31Faaa93035CE390 Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** UnlockdProxyAdminFund ***

Network: hardhat
tx: 0x66711f9b4d0b86478b76fa9d9592743fa2a3c69b1227ae12229bb375bbb79887
contract address: 0x5a60c5d89A0A0e08ae0CAe73453e3AcC9C335847
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 24491290845
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminFund address: 0x5a60c5d89A0A0e08ae0CAe73453e3AcC9C335847 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProxyAdminFund Address: 0x5a60c5d89A0A0e08ae0CAe73453e3AcC9C335847 Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy address provider
- Deploying new Address Provider:
*** LendPoolAddressesProvider ***

Network: hardhat
tx: 0x62e7ee6f2d30f5ade70eb9839783567b3de06e7470828b8436909873886009d8
contract address: 0x4e07D87De1CF586D51C3665e6a4d36eB9d99a457
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 21776916529
gas used: 2978496

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProvider address: 0x4e07D87De1CF586D51C3665e6a4d36eB9d99a457 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
- Deploying a new Address Provider Registry:
*** LendPoolAddressesProviderRegistry ***

Network: hardhat
tx: 0x84e65fc8eb4251d4af7cdc39234641c121155ddfec372717e1e01644053b9960
contract address: 0x2F7f69a3cd22FcfFB5E0C0fB7Ae5Eb278b3919Ff
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 20422451818
gas used: 502283

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProviderRegistry address: 0x2F7f69a3cd22FcfFB5E0C0fB7Ae5Eb278b3919Ff deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deployed Registry Address: 0x2F7f69a3cd22FcfFB5E0C0fB7Ae5Eb278b3919Ff Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Added LendPoolAddressesProvider with address "0x4e07D87De1CF586D51C3665e6a4d36eB9d99a457" to registry located at 0x2F7f69a3cd22FcfFB5E0C0fB7Ae5Eb278b3919Ff
LSSVM ROUTER ADDRESS: 0x2b2e8cda09bba9660dca5cb6233787738ad68329
LIQUIDATOR addrs 0xA2874be6Acdc314dd055f6869a2dBdF62c983436
Pool Admin 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Emergency Admin 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3
LendPool Liquidator 0xA2874be6Acdc314dd055f6869a2dBdF62c983436
SushiSwap Router 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F
NFTXVault Factory 0xBE86f647b167567525cCAAfcd6f881F1Ee558216


Deploy Incentives Controller
Deploying new Incentives Controller Implementation...
*** MockIncentivesController ***

Network: hardhat
tx: 0x7d9cc75623a59181008837a268c37fd628644aece89cbb3a87f66da2ef83a78b
contract address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 6960912075
gas used: 142669

******

contracts-helpers:registerContractInJsonDb, contractId: MockIncentivesController address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy UNFT Registry
Deploying new UnftRegistry implementation...
*** UNFT ***

Network: hardhat
tx: 0xeec0de9df580a439b181000e4626067a0e29e220341ab280196aa0bbb80b7629
contract address: 0xd240323E990c480f993E74634c08f3D6EAD0a31F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 5583743794
gas used: 1503057

******

contracts-helpers:registerContractInJsonDb, contractId: UNFT address: 0xd240323E990c480f993E74634c08f3D6EAD0a31F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:insertContractAddressInDb, id: UNFTRegistryImpl address 0x1eaA4a267eDcde0eB5e08D08810Aa1696b123a2D
*** UNFTRegistry ***

Network: hardhat
tx: 0x4589434f7b967731de5b3474f0e32e98cdd3bfc14228121fcf3ccee0be04f2ee
contract address: 0x1eaA4a267eDcde0eB5e08D08810Aa1696b123a2D
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 5149121768
gas used: 2441516

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0x1eaA4a267eDcde0eB5e08D08810Aa1696b123a2D deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Invalid Proxy Admin address in pool config. Trying to fetch from deployed contracts...
*** UNFTRegistry ***

Network: hardhat
tx: 0x5ab15c35b4e3dcba1e13aed389635c1fef476b97a0294a811c35b58a184d926e
contract address: 0xb38Ce645F2890a7820d322c1cE0774849489bB9d
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 4833898158
gas used: 740488

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0xb38Ce645F2890a7820d322c1cE0774849489bB9d deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UNFT created successfully for token WPUNKS with address 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb
UNFT Token: 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb 0x0891a54D56e574348f876B66e82Ea67dDD7f16E4
UNFT created successfully for token BAYC with address 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
UNFT Token: 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D 0xE48051B8ad05d1c67571a1cCafb67A9d93222711
UNFT created successfully for token AZUKI with address 0xED5AF388653567Af2F388E6224dC7C4b3241C544
UNFT Token: 0xED5AF388653567Af2F388E6224dC7C4b3241C544 0xd0188E9d8fdAd0c44C0b4D62C5D49ce9e5DF130e


Deploy Lockey Holders
Deploying new Lockey Holders implementation...
contracts-helpers:insertContractAddressInDb, id: LockeyHolderImpl address 0x4C8871d8f224eE3Cd12a14fF3B691a1A0dB392ec
*** LockeyHolder ***

Network: hardhat
tx: 0x07a4df21cc8535aeeabafa287775b7dc02971f2c15b8c568764106629fdd9ed5
contract address: 0x4C8871d8f224eE3Cd12a14fF3B691a1A0dB392ec
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 3104501504
gas used: 293631

******

contracts-helpers:registerContractInJsonDb, contractId: LockeyHolder address: 0x4C8871d8f224eE3Cd12a14fF3B691a1A0dB392ec deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lockey holders implementation with address: 0x4C8871d8f224eE3Cd12a14fF3B691a1A0dB392ec
contracts-helpers:insertContractAddressInDb, id: LockeyHolder address 0xc831fAe49f2c324704F7133CB8bE08BC768904cf


Deploy Debt Market
Deploying new Debt Market implementation...
contracts-helpers:insertContractAddressInDb, id: DebtMarketImpl address 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
*** DebtMarket ***

Network: hardhat
tx: 0x782181f297aebb4dd25191a3b711f3d533929f8c7545aa56d6b93be1732c4f2f
contract address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 2441620406
gas used: 3289330

******

contracts-helpers:registerContractInJsonDb, contractId: DebtMarket address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting Debt Market implementation with address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
contracts-helpers:insertContractAddressInDb, id: DebtMarket address 0x80Fa1fA8B0CaF15CFC3961C934cFA860945d9139


Deploy lend pool
Setting UNFTRegistry to address provider...
Setting IncentivesController to address provider...
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x8165d37f701aa9249bd4aee5a199524f3e5564bce7f61b0a1142a0f1fc68c593
contract address: 0x7ECdCa35F3B55acE694A7DA48a759444Fe81b943
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1808764447
gas used: 84290

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0x7ECdCa35F3B55acE694A7DA48a759444Fe81b943 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ReserveLogic ***

Network: hardhat
tx: 0x7e5494c929541764ca92602f2d2d59f48be10c1022f53f1c1fece11365ede8b3
contract address: 0xa25a322c846E3be3207365390A02864fdEDfA0CD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1709037782
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0xa25a322c846E3be3207365390A02864fdEDfA0CD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** NftLogic ***

Network: hardhat
tx: 0xa571af75482e46e03b9dc48c812ac4a7816caf5806fc4f1b3acb87e814eb09c7
contract address: 0x7dDc7b2963AC96336Ec238e816FCbc30aDB113AD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1622845669
gas used: 141022

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0x7dDc7b2963AC96336Ec238e816FCbc30aDB113AD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ValidationLogic ***

Network: hardhat
tx: 0x59425d0f1de8e65419594603b6f2e844c87af6fcf7aaed0322361d5cd4df552f
contract address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1546753715
gas used: 1573518

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** SupplyLogic ***

Network: hardhat
tx: 0x66a54dde89b3b162ceece2ce734d52f28d15409d41aeb86899f964a62daadd26
contract address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1495685140
gas used: 1235281

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** BorrowLogic ***

Network: hardhat
tx: 0x092b12b3e650b9eb89a2bfb30173d514c242e0b761de47db24ed1f7515fda957
contract address: 0x5c769753F192449c3c6AeC7BF2145928eb261699
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1446019888
gas used: 2060203

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0x5c769753F192449c3c6AeC7BF2145928eb261699 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateLogic ***

Network: hardhat
tx: 0x59ef1433b95c02a39288368ed7b1f81788d78819d71319ad4be771464df77ae3
contract address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1408719039
gas used: 5017191

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0xbbbc0c66af78210db0fcebd80bb520fa29ad275ae9608429b78e413b9a640116
contract address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1398806298
gas used: 3025524

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LendingLogic ***

Network: hardhat
tx: 0x67c78447d65b811b64655d620fc9ba3d08210ab58b73cbf507fa934d022def02
contract address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1373184387
gas used: 72217

******

contracts-helpers:registerContractInJsonDb, contractId: LendingLogic address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ConfiguratorLogic ***

Network: hardhat
tx: 0xa08cec61d65920b60f3898e04bd8ddfd8f10f88ed75a523350baca6d7b3c7cca
contract address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1327077509
gas used: 1970106

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
*** LendPool ***

Network: hardhat
tx: 0x861025184ba68ecca235a7bae21b2746bb33a3fc591954997a50eaae3cdddc8e
contract address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1299132125
gas used: 5328527

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool implementation with address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
contracts-helpers:insertContractAddressInDb, id: LendPool address 0x7D2386aA0b699eD5C9a8D9caa2efDA648C2418e7
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
*** LendPoolLoan ***

Network: hardhat
tx: 0x253737c8c7c025dbf0f14efdd05e649c4c16140bdee1d69bf21f820b946f06fe
contract address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1261150572
gas used: 3737747

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool loan implementation with address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x8E170f8919F9f6e58EEbd6E7bF0f1E2CFfaBe5E4
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
*** LendPoolConfigurator ***

Network: hardhat
tx: 0x75e7509a59197759ca222191b693e72d8eeb00295c495c3470d3dc46d980a1df
contract address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1220379489
gas used: 5230541

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool configurator implementation with address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0xAAd52A86F916f46c2Dc87f2BfCEA0B03aEAa8AE1
Deploying UToken implementation UToken
*** UToken ***

Network: hardhat
tx: 0xfb56ff6c7b71c80416be320422a51eb9a822041b3cc35528c1202c99cbcf6c3a
contract address: 0xa85e569EF873Cec2a82012C08057397F93aed686
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1168064558
gas used: 2710730

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0xa85e569EF873Cec2a82012C08057397F93aed686 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** DebtToken ***

Network: hardhat
tx: 0x1d4f9fd03f896cb0d23d539024401910c3e315b922aec5add3d7ebc51e3ddb13
contract address: 0x8e090D5B023252bE8d05d4c33b959A6F4A8BdD9e
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1156204634
gas used: 1455765

******

contracts-helpers:registerContractInJsonDb, contractId: DebtToken address: 0x8e090D5B023252bE8d05d4c33b959A6F4A8BdD9e deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy reserve oracle
PROXY admin: 0xb2f97A3c2E48cd368901657e31Faaa93035CE390
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
*** ReserveOracle ***

Network: hardhat
tx: 0x52741b40a216239f4f9cf4c65acde8b001e4a7009ee49ea07ef68aa25bb1f3b0
contract address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1108537068
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x6fd588b6439ca4553c8efb8739f96c509d3d46771f00a476519e79cd020c2f32
contract address: 0x941C6c63Def537699014d15605828339475ed33c
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1097610607
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x941C6c63Def537699014d15605828339475ed33c deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Reserve Oracle: proxy 0x941C6c63Def537699014d15605828339475ed33c, implementation 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0x7f386c2b9ac6e5cb77bc7df742069b889d6ea459508797584a61a530aa4734fe
contract address: 0x06A6737A0713e3DAe8DEfA7565f89D835C1594B7
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1066652435
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0x06A6737A0713e3DAe8DEfA7565f89D835C1594B7 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xf5e1700fbfebcb37ed464740401fbf3152b04c68480b084497e3c4f747fe950b
contract address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1052640167
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy nft oracle
contracts-helpers:insertContractAddressInDb, id: NFTOracleImpl address 0x0c6ee9D95dD6e39C1808d3fF219a6cE9b70E8dA7
*** NFTOracle ***

Network: hardhat
tx: 0x15b5c622c81755379286cc1e12c408624dd66566ddd737e1ccd6a1666df2ea7a
contract address: 0x0c6ee9D95dD6e39C1808d3fF219a6cE9b70E8dA7
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1046715635
gas used: 1047527

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x0c6ee9D95dD6e39C1808d3fF219a6cE9b70E8dA7 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new nft oracle proxy & implementation...
*** NFTOracle ***

Network: hardhat
tx: 0x3aa3a9c0910d5ba9fbaaadb12792d93e651dd908f832eab2cfbd75ad27416adf
contract address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1041858829
gas used: 712030

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
NFT Oracle: proxy 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b, implementation 0x0c6ee9D95dD6e39C1808d3fF219a6cE9b70E8dA7
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0xb02765a2037f5643a87f82eba6a8dc1320295082ab3898d107543f03a3992aed
contract address: 0x2bDc03E97c90C269099931986078fb9e353a65C6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1019200980
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x2bDc03E97c90C269099931986078fb9e353a65C6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize lend pool
Init & Config Reserve assets
RESERVES: WETH,[object Object]
*** InterestRate ***

Network: hardhat
tx: 0xab2c12e3581f0fe3f019b17f75293dc6828cd4ba4c75114473fe6dedb0518b33
contract address: 0x495DeE8247914e3176a4F9767596d15a09230aC7
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1015117117
gas used: 613836

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x495DeE8247914e3176a4F9767596d15a09230aC7 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address 0x495DeE8247914e3176a4F9767596d15a09230aC7
- Reserves initialization in 1 txs
  - Reserve ready for: WETH 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
    * gasUsed 1631429
addressesProvider: 0x4e07D87De1CF586D51C3665e6a4d36eB9d99a457
configuator: 0xAAd52A86F916f46c2Dc87f2BfCEA0B03aEAa8AE1
- Configure Reserves
  - Params for WETH: 3000 true
- Configure reserves in 1 txs
  - batchConfigReserve for: WETH
Setting YVaultWETH with address:  0xa258C4606Ca8206D8aA700cE2143D7db854D168c  in addressesProvider...
Init & Config NFT assets
- Skipping init of DOODLE due nft address is not set at markets config
- NFTs initialization in 3 txs
  - NFT ready for: WPUNKS 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb
    * gasUsed 257048
  - NFT ready for: BAYC 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
    * gasUsed 241868
  - NFT ready for: AZUKI 0xED5AF388653567Af2F388E6224dC7C4b3241C544
    * gasUsed 241686
addressesProvider: 0x4e07D87De1CF586D51C3665e6a4d36eB9d99a457
configuator: 0xAAd52A86F916f46c2Dc87f2BfCEA0B03aEAa8AE1
- Configure NFTs
  - Params for WPUNKS: 4000 9000 500 24 24 500 5000 2000 10000 9999
  - Params for BAYC: 4000 9000 500 24 24 500 5000 2000 10000 9999
- Skipping init of DOODLE due nft address is not set at markets config
  - Params for AZUKI: 4000 9000 500 24 24 500 5000 2000 10000 9999
- Configure NFTs in 6 txs
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC
  - batchConfigNft for: AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI
  - batchConfigNft for: AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI, AZUKI


Deploy WETH Gateway
contracts-helpers:insertContractAddressInDb, id: WETHGatewayImpl address 0x6e41fB61F92789d78ed6b7B70B5452c13706c2fE
*** WETHGateway ***

Network: hardhat
tx: 0x85af916df752312cadd6ad818da61c81eddf6a23ad5a32946ddd89b893ce09f5
contract address: 0x6e41fB61F92789d78ed6b7B70B5452c13706c2fE
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1002903502
gas used: 2997021

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x6e41fB61F92789d78ed6b7B70B5452c13706c2fE deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WETHGateway ***

Network: hardhat
tx: 0xc46de321f927bbb152cf047e256e934922cb2a0b93bae091a7057db665a9100d
contract address: 0xD0330Ac56A182aC22864D67D6f6E76aD628c9b2e
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1002715301
gas used: 745653

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0xD0330Ac56A182aC22864D67D6f6E76aD628c9b2e deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy PUNK Gateway
wethGateWay.address 0xD0330Ac56A182aC22864D67D6f6E76aD628c9b2e
CryptoPunksMarket.address 0xB4B4ead1A260F1572b88b9D8ABa5A152D166c104
WPUNKS.address 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb
contracts-helpers:insertContractAddressInDb, id: PunkGatewayImpl address 0x51bda59320165617F7209a38D08b11ccefF58F1a
*** PunkGateway ***

Network: hardhat
tx: 0xed34d8ad27bd00c58bc63852caf89785a5244c385ae625e48cc43df981bec0b3
contract address: 0x51bda59320165617F7209a38D08b11ccefF58F1a
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1001854364
gas used: 3587787

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0x51bda59320165617F7209a38D08b11ccefF58F1a deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new PunkGateway proxy & implementation...
*** PunkGateway ***

Network: hardhat
tx: 0x585afd17015c7a3867cdf7fceea35dea0ca19c22ba995c00b83d6b3f7511ad44
contract address: 0x816b2d94590fbcE4C06a70FBb770323166867549
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1001756165
gas used: 998847

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0x816b2d94590fbcE4C06a70FBb770323166867549 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize gateway
WETHGateway: authorizeLendPoolNFT: [
  '0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb',
  '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',
  '0xED5AF388653567Af2F388E6224dC7C4b3241C544'
]
PunkGateway: authorizeLendPoolERC20: [ '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' ]


Deploy data provider
*** WalletBalanceProvider ***

Network: hardhat
tx: 0xd4c8b0c4cf12f95ba18f17a205c707893936ab08e53852a24b7f3deae3b44ff8
contract address: 0x35793856D2b49B365748b532149E1C52Cfa1744F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1001059169
gas used: 1251354

******

contracts-helpers:registerContractInJsonDb, contractId: WalletBalanceProvider address: 0x35793856D2b49B365748b532149E1C52Cfa1744F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
WalletBalancerProvider deployed at: 0x35793856D2b49B365748b532149E1C52Cfa1744F
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0x02e1ccab9b515cef756367f2f5641fff57f2c1ffa6abe38e64aee6ae8edb2853
contract address: 0x8Fe994bA879dF436bDA80d1fc559d192608939f6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000835124
gas used: 3157791

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0x8Fe994bA879dF436bDA80d1fc559d192608939f6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProtocolDataProvider deployed at: 0x8Fe994bA879dF436bDA80d1fc559d192608939f6
*** UIPoolDataProvider ***

Network: hardhat
tx: 0x6799baf3d8741447dd161552904fe91be5a8fc00138651125dd48b26a66773d7
contract address: 0xF79a1ab14b401d7032bdDD20D8Eb061557fa8D87
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000686475
gas used: 3056749

******

contracts-helpers:registerContractInJsonDb, contractId: UIPoolDataProvider address: 0xF79a1ab14b401d7032bdDD20D8Eb061557fa8D87 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UiPoolDataProvider deployed at: 0xF79a1ab14b401d7032bdDD20D8Eb061557fa8D87


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 60
UnlockdProxyAdminPool: 0xb2f97A3c2E48cd368901657e31Faaa93035CE390
NFTOracleImpl: 0x0c6ee9D95dD6e39C1808d3fF219a6cE9b70E8dA7
NFTOracle: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
CryptoPunksMarket: 0xB4B4ead1A260F1572b88b9D8ABa5A152D166c104
WrappedPunk: 0xa05ffF82bcC0C599984b0839218DC6ee9328d1Fb
UnlockdProxyAdminFund: 0x5a60c5d89A0A0e08ae0CAe73453e3AcC9C335847
LendPoolAddressesProvider: 0x4e07D87De1CF586D51C3665e6a4d36eB9d99a457
LendPoolAddressesProviderRegistry: 0x2F7f69a3cd22FcfFB5E0C0fB7Ae5Eb278b3919Ff
ReserveLogic: 0xa25a322c846E3be3207365390A02864fdEDfA0CD
NftLogic: 0x7dDc7b2963AC96336Ec238e816FCbc30aDB113AD
GenericLogic: 0x7ECdCa35F3B55acE694A7DA48a759444Fe81b943
ValidationLogic: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
SupplyLogic: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
BorrowLogic: 0x5c769753F192449c3c6AeC7BF2145928eb261699
LiquidateLogic: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
ConfiguratorLogic: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
LendPoolImpl: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
LendPool: 0x7D2386aA0b699eD5C9a8D9caa2efDA648C2418e7
LendPoolLoanImpl: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
LendPoolLoan: 0x8E170f8919F9f6e58EEbd6E7bF0f1E2CFfaBe5E4
LendPoolConfiguratorImpl: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
LendPoolConfigurator: 0xAAd52A86F916f46c2Dc87f2BfCEA0B03aEAa8AE1
UToken: 0xa85e569EF873Cec2a82012C08057397F93aed686
DebtToken: 0x8e090D5B023252bE8d05d4c33b959A6F4A8BdD9e
ReserveOracleImpl: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
ReserveOracle: 0x941C6c63Def537699014d15605828339475ed33c
InterestRate: 0x495DeE8247914e3176a4F9767596d15a09230aC7
rateStrategyWETH: 0x495DeE8247914e3176a4F9767596d15a09230aC7
WETHGatewayImpl: 0x6e41fB61F92789d78ed6b7B70B5452c13706c2fE
WETHGateway: 0xD0330Ac56A182aC22864D67D6f6E76aD628c9b2e
PunkGatewayImpl: 0x51bda59320165617F7209a38D08b11ccefF58F1a
PunkGateway: 0x816b2d94590fbcE4C06a70FBb770323166867549
WalletBalanceProvider: 0x35793856D2b49B365748b532149E1C52Cfa1744F
UnlockdProtocolDataProvider: 0x8Fe994bA879dF436bDA80d1fc559d192608939f6
UIPoolDataProvider: 0xF79a1ab14b401d7032bdDD20D8Eb061557fa8D87
WPUNKS: 0xE1D3E11961552eC49F6AfD0D703bDd931129DCF0
BAYC: 0xC20ED1B44C638B602Cdf16F6D8Da4d292ED31f93
DOODLE: 0x88543b8Bcf9a2B4b6A483b1C1A245B6008bceB7E
AZUKI: 0xa8e7507b022b54B8686bC2Bd8a6a49b3bE70cE76
MockIncentivesController: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
UNFT: 0xd240323E990c480f993E74634c08f3D6EAD0a31F
UNFTRegistryImpl: 0x1eaA4a267eDcde0eB5e08D08810Aa1696b123a2D
UNFTRegistry: 0xb38Ce645F2890a7820d322c1cE0774849489bB9d
LiquidateMarketsLogic: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
LockeyHolderImpl: 0x4C8871d8f224eE3Cd12a14fF3B691a1A0dB392ec
LockeyHolder: 0xc831fAe49f2c324704F7133CB8bE08BC768904cf
WETHMocked: 0xDa59E3467845ae1772Dc6Ce15d4E9635F89EE025
WETH: 0xDa59E3467845ae1772Dc6Ce15d4E9635F89EE025
MintableERC721: 0xa8e7507b022b54B8686bC2Bd8a6a49b3bE70cE76
UnlockdProxyAdminTest: 0xc0025E8b72EE8e2792be48F0a39f3F6b4d5D73B0
LendingLogic: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
MockChainlinkOracle: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
MockReserveOracle: 0x06A6737A0713e3DAe8DEfA7565f89D835C1594B7
NFTXVaultFactory: 0xBe91E12034Ab247E49f9CAd2f61fBC722523662e
UniswapV2Factory: 0xC824A255d9D40Ef122e40Fa22255B9b36c0e1783
SushiSwapRouter: 0x18103A894DDA262BA3604994946fa4052D8F9abe
MockNFTOracle: 0x2bDc03E97c90C269099931986078fb9e353a65C6
DebtMarketImpl: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
DebtMarket: 0x80Fa1fA8B0CaF15CFC3961C934cFA860945d9139
SelfdestructTransferMock: 0x3C2AeD703EF55ABE3C9D1080418406Fae704bae0 

Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.610375020896012532
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.610375020896012532
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 999999.999786505399657059
LendPoolLiquidator: 0xA2874be6Acdc314dd055f6869a2dBdF62c983436 Balance: 1000000.0
-> Initialize make suite...
uDai undefined
uUSDC undefined
uWETH 0x09107Cb921F161b37B295eF1068942653a8B586D
daiAdd undefined
usdcAdd undefined
wethAdd 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

***************
Setup and snapshot finished
***************

  LendPoolAddressesProvider
    ✓ Test the accessibility of the LendPoolAddressesProvider
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0xD4aE8cED94f843e559f125e6CE0c65E8A7dAa035
*** LendPool ***

Network: hardhat
tx: 0x5df0a42aa6e57f08935d5f058543df63b7ede2efef96c25e9442c20284e354f8
contract address: 0xD4aE8cED94f843e559f125e6CE0c65E8A7dAa035
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000431671
gas used: 5328527

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0xD4aE8cED94f843e559f125e6CE0c65E8A7dAa035 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    ✓ Tests adding a proxied address with `setAddressAsProxy()`
    ✓ Tests adding a non proxied address with `setAddress()`
    ✓ Tests specific non-proxied addresses set via `setAddress()`

  LendPool: Borrow/repay test cases
    ✓ Delegatee try to Borrow WETH to different onBehalf

  LendPool: Borrow negative test cases
    ✓ Users 0 Deposits 100 WETH and user 1 tries to borrow 0 WETH (revert expected)
    ✓ User 1 tries to use underpriced NFT as collateral to borrow 100 WETH (revert expected)
    ✓ User 2 tries to uses user 1 owned NFT as collateral to borrow 10 WETH (revert expected)
    ✓ Users 0 Deposits 100 WETH and user 1 tries to borrow but the timestamp exceeds

  LendPool: Borrow/repay test cases
    ✓ User 2 deposits 1 WETH and 1000 DAI to account for rounding errors
    ✓ User 0 deposits 100 WETH, user 1 uses NFT as collateral and borrows 1 WETH
    ✓ User 1 uses existed collateral and borrows more 100 DAI (revert expected)
    ✓ User 1 uses existed collateral and borrows more 2 WETH
    ✓ User 1 tries to borrow more than the rest of the WETH liquidity (revert expected)
    ✓ User 1 tries to repay 0 WETH (revert expected)
    ✓ User 1 repays 0.5 WETH, enough to cover a small part of the interest
    ✓ User 1 repays all WETH borrow after one year
    ✓ User 0 withdraws the deposited WETH plus interest
    ✓ User 1 deposits 1 USDC to account for rounding errors
    ✓ User 1 deposits 1000 USDC, user 3 uses not owned NFT as collateral and borrows 10 USDC
    ✓ user 2 uses owned NFT as collateral on behalf of user 3 and borrows 10 USDC
    ✓ user 2 uses existed collateral on behalf of user 3 and borrows more 20 USDC
    ✓ user 3 repay 10 USDC, a fraction of borrow amount
    ✓ user 3 repay all USDC, full of borrow amount

  LendPool: buyout test cases
    ✓ Borrower - Borrows WETH
    ✓ Buyer tries to buy with HF above 1
    ✓ Health Factor goes below 1
    ✓ Buyer - tries to buy the NFT with a wrong tokenId
    ✓ Buyer - tries to buy the NFT with a smaller amount than debt
    ✓ Buyer - tries to buy the NFT with an amount higher than debt lower then valuation

  LendPool: buyout test cases
    ✓ Borrower - Borrows WETH
    ✓ Health Factor goes below 1
    ✓ Buyer - buys out the NFT in auction
    ✓ Lockey Holder: Borrower - Borrows WETH
    ✓ Lockey Holder: Health Factor goes below 1
Balance before:  1771428571428571428570
Balance after:  1721428571428571428570
    ✓ Lockey Holder: Buyer - buys out the NFT in auction and deducts because his a lockey holder.

  Configurator-NFT
    ✓ Deactivates the BAYC NFT
    ✓ Deactivates the BAYC NFT Token
    ✓ Rectivates the BAYC NFT
    ✓ Rectivates the BAYC NFT Token
    ✓ Check the onlyAdmin on deactivateRNft 
    ✓ Check the onlyAdmin on activateNft 
    ✓ Freezes the BAYC NFT
    ✓ Freezes the BAYC NFT Token
    ✓ Unfreezes the BAYC NFT
    ✓ Unfreezes the BAYC NFT Token
    ✓ Check the onlyAdmin on freezeNft 
    ✓ Check the onlyAdmin on unfreezeNft 
    ✓ Deactivates the BAYC NFT as collateral
    ✓ Activates the BAYC NFT as collateral
    ✓ Check the onlyLtvManager on configureNftAsCollateral 
    ✓ Deactivates the BAYC NFT as auction
    ✓ Activates the BAYC NFT as auction
    ✓ Check the onlyLtvManager on configureNftAsAuction 
    ✓ Batch Deactivates the BAYC NFT as collateral
    ✓ Batch Activates the BAYC NFT as collateral
    ✓ Check the onlyAdmin on batchConfigNft 
    ✓ Batch Deactivates the BAYC NFT as auction
    ✓ Batch Activates the BAYC NFT as auction
    ✓ Reverts when trying to disable the BAYC nft with liquidity on it
    ✓ Config setMaxNumberOfNfts invalid value
    ✓ Config setMaxNumberOfNfts invalid value overflowing
    ✓ Check the onlyAdmin on setMaxNumberOfNfts 
    ✓ Config the timeFrame for an X amount of time
    ✓ Check if the config timestamp is correct
    ✓ Check if general configurations are correct
    ✓ Check the zero check on set rescuer
    ✓ (LendPool): Check the only pool admin in safe health factor 
    ✓ (LendPool): Check invalid 0 value in safe health factor 
    ✓ (LendPool): Check correct value in safe health factor 

  Configurator-Reserve
    ✓ Reverts trying to set an invalid reserve factor
    ✓ Rectivates the ETH reserve
    ✓ Check the onlyAdmin on deactivateReserve 
    ✓ Check the onlyAdmin on activateReserve 
    ✓ Freezes the ETH reserve
    ✓ Unfreezes the ETH reserve
    ✓ Check the onlyAdmin on freezeReserve 
    ✓ Check the onlyAdmin on unfreezeReserve 
    ✓ Deactivates the ETH reserve for borrowing
    ✓ Activates the ETH reserve for borrowing
    ✓ Check the onlyAdmin on disableBorrowingOnReserve 
    ✓ Check the onlyAdmin on enableBorrowingOnReserve 
    ✓ Changes the reserve factor of WETH
    ✓ Check the onlyLendPoolManager on setReserveFactor
    ✓ Batch Changes the reserve factor of WETH & DAI
    ✓ Check the onlyPoolAdmin on batchConfigReserve
    ✓ Reverts when trying to disable the DAI reserve with liquidity on it
    ✓ Config setMaxNumberOfReserves valid value
    ✓ Config setMaxNumberOfReserves invalid value
    ✓ Config setMaxNumberOfReserves invalid value overflow
    ✓ Check the onlyAdmin on setMaxNumberOfReserves 

  DataProvider
    ✓ Borrows WETH using 1 BAYC
    ✓ Query UI Reserve Data
    ✓ Query UI NFT Data
    ✓ Query UI Loan Data
    ✓ Query Wallet Reserve Data
    ✓ Query Wallet NFT Data

  Buy and sell the debts
    Positive
      ✓ Create a debt listing
      ✓ Cancel a debt listing
      ✓ Buy a debt with ETH
      ✓ Create a bid
      ✓ Update a debt listing delta bids
      ✓ Cancel a debt listing with bids
      ✓ Create a second bid 

      1) Claim an auction
      ✓ Buy a debt with a LOCKEY HOLDER discount
      ✓ Buy a PUNK debt with WETH
      ✓ Buy a PUNK debt with ETH
    Negative
      Revert on try to buy a debt listing
        ✓ When it is a the price is lowest than the offer
        ✓ When it is a the price is highest than the offer
      Revert on try to create listing
        ✓ When it is a debt listing without the ownership of the nft
        ✓ When it is a debt listing with wrong on behalf of
        ✓ When it is a debt listing with 0 sell price
        ✓ When it is a debt listing that alerady exist
        ✓ When it is a debt listing on non existing loan
      Revert on try to create listing with Auction
        ✓ When it is a debt listing with the auctionEndTimestamp past
      Revert on try to cancel listing
        ✓ When debt no exist
        ✓ When it has SOLD state 
      Revert on try to bid a auction debt
        ✓ When debt no exist
        ✓ When the new bid price is lower than sellPrice
        ✓ When the new bid price is lower than the last bid price plus delta
        ✓ When the bid type is PRICE FIXED

        2) When auction already ended
      Revert on try to claim a auction debt
        ✓ When debt no exist
        ✓ When onBehalfOf is not the last bidder
        ✓ When bid type is not AUCTION
        ✓ When auction is not already ended

  LendPool: Deposit
    ✓ User 0 Deposits 1000 DAI in an empty reserve
    ✓ User 1 deposits 1000 DAI after user 0
    ✓ User 0 deposits 1000 USDC in an empty reserve
    ✓ User 1 deposits 1000 USDC after user 0
    ✓ User 0 deposits 1 WETH in an empty reserve
    ✓ User 1 deposits 1 WETH after user 0
    ✓ User 1 deposits 0 WETH (revert expected)
    ✓ User 1 deposits 0 DAI (revert expected)
    ✓ User 1 deposits 100 DAI on behalf of user 2, user 2 tries to borrow 0.01 WETH

  Interest rate tests
*** InterestRate ***

Network: hardhat
tx: 0x22c8d853838f82d41751bd8b4a41c92e2bc990bf88d23e4af207647f5586a350
contract address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000493014
gas used: 613848

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    ✓ Checks rates at 0% utilization rate, empty reserve
    ✓ Checks rates at 80% utilization rate
    ✓ Checks rates at 100% utilization rate

  LendPool: Malicious Hacker Rentrant
hacker do reentrant action: ACTION_DEPOSIT
hacker do reentrant action: ACTION_WITHDRAW
hacker do reentrant action: ACTION_BORROW
hacker do reentrant action: ACTION_REPAY
hacker do reentrant action: ACTION_AUCTION
hacker do reentrant action: ACTION_REDEEM
hacker do reentrant action: ACTION_LIQUIDATE_NFTX
    ✓ Malicious hacker try to reentrant (should revert)

  LendPool: Liquidation negative test cases
    ✓ User 0 deposit 100 WETH, user 1 mint NFT and borrow 10 WETH
    ✓ User 1 liquidate on a non-existent NFT

    3) User 2 auction on a loan health factor above 1
    ✓ Drop loan health factor below 1

    4) User 2 auction price is unable to cover borrow

    5) User 2 auction price is less than liquidate price

    6) User 2 auction price is enough to cover borrow and liqudiate price

    7) User 3 auction price is lesser than user 2

    8) User 2 liquidate before auction duration is end

    9) User 1 redeem but bidFine is not fullfil to borrow amount of user 2 auction

    10) User 1 redeem but amount is not fullfil to mininum repay amount

    11) User 1 redeem but amount is not fullfil to maximum repay amount
    ✓ Ends redeem duration

    12) User 1 redeem after duration is end
    ✓ Ends auction duration

    13) User 3 auction after duration is end

    14) User 2 auction consecutively

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1

    15) WETH - Auctions the borrow

    16) WETH - Can't liquidate on NFTX due to invalid loan state
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1
    ✓ USDC - Auctions the borrow at first time
    ✓ USDC - Auctions the borrow at second time with higher price
    ✓ USDC - Can't liquidate on NFTX

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1

  LendPool: Redeem
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1

    17) WETH - Auctions the borrow

    18) WETH - Redeems the borrow
    ✓ WETH - Repays the borrow
    ✓ DAI - Borrows DAI
    ✓ DAI - Drop the health factor below 1
    ✓ DAI - Auctions the borrow
    ✓ DAI - Redeems the borrow
    ✓ DAI - Repays the borrow

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1

    19) WETH - Auctions the borrow

    20) WETH - Liquidates the borrow
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1
    ✓ USDC - Auctions the borrow at first time
    ✓ USDC - Auctions the borrow at second time with higher price
    ✓ USDC - Liquidates the borrow

  LendPool: Liquidation on SudoSwap
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Liquidates the borrow on SudoSwap
    ✓ DAI - Borrows DAI
    ✓ DAI - Drop the health factor below 1
    ✓ DAI - Liquidates the borrow on SudoSwap

  LendPoolLoan: Modifiers
    ✓ Tries to invoke initNft not being the Pool
    ✓ Tries to invoke createLoan not being the Pool
    ✓ Tries to invoke updateLoan not being the Pool
    ✓ Tries to invoke repayLoan not being the Pool
    ✓ Tries to invoke auctionLoan not being the Pool
    ✓ Tries to invoke redeemLoan not being the Pool
    ✓ Tries to invoke liquidateLoan not being the Pool
    ✓ Tries to invoke liquidateLoanNFTX not being the Pool

  NFTOracle: General functioning
    ✓ Set Admin correctly
    ✓ Set and get Mocknft price at 1000
    ✓ Add 2 Multi Assets
    ✓ Add 3 Multi Assets
    ✓ Add 3 Multi Assets - BigNumbers
    ✓ Single asset price updates
    ✓ Multiple asset price updates

  NFTOracle: Reverting Errors
    ✓ Should be reverted as NFTOracle is already initialized
    ✓ Should be reverted as it is a non-existing collection
    ✓ Should be reverted as price is 0
    ✓ Should be reverted as the collection has been deleted
    ✓ Should be reverted as contract is paused
    ✓ Should be reverted as array lengths aren't matching (2 vs 3)
    ✓ Testing overflows

  NFTOracle: Test Pause
    ✓ Should revert as collection is paused
    ✓ Should revert on multi-paused collections

  LendPool: Pause
    ✓ Transfer
    ✓ Deposit
    ✓ Withdraw
    ✓ Borrow
    ✓ Repay
    ✓ Liquidate
    ✓ LiquidateNFTX

  PunkGateway: Delegate
    ✓ Hacker try to borrow and delegate different onBehalf (should revert)
    ✓ Hacker try to auction and delegate different onBehalf (should revert)

  PunkGateway
USER: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3
    ✓ Owner can do emergency CryptoPunks recovery
    ✓ Should fail: not supported collection
    ✓ Should fail: not holder
    ✓ Check approve valuation on cryptopunks
    ✓ Borrow some USDC and repay it
AVAILABLE LIQUIDITY AFTER FIRST BORROW: 48999999999999999965
AVAILABLE LIQUIDITY AFTER SECOND BORROW: 46999999999999999965
    ✓ Borrow some ETH and repay it
    ✓ Borrow all ETH and repay it

  PunkGateway-Liquidate
    ✓ Borrow USDC and liquidate it

    21) Borrow ETH and liquidate it

    22) Borrow ETH and redeem it

  Repay and transfer helper tests
    ✓ borrow-repay-transfer

  LendPool: Rescue locked funds
BigNumber { value: "1000000000000000000000" }
    ✓ User 1 transfers 100 WETH directly to pool, and rescuer returns funds
BigNumber { value: "1000000000000000000000" }
    ✓ Prevents a random user from rescuing tokens 

  ReserveOracle
    ✓ ReserveOracle: Add Aggregator
    ✓ ReserveOracle: Remove Aggregator
    ✓ ReserveOracle: get latest price
    ✓ ReserveOracle: get eth price
    ✓ ReserveOracle: get latest timestamp
    ReserveOracle-TWAP
      ✓ twap price
      ✓ asking interval more than asset has
      ✓ asking interval less than asset has
      ✓ given variant price period
      ✓ latest price update time is earlier than the request, return the latest price
      ✓ get 0 while interval is zero

  Upgradeability
    ✓ Tries to update the WETH UToken implementation with a different address than the configuator
    ✓ Upgrades the WETH UToken implementation 
    ✓ Tries to update the weth DebtToken implementation with a different address than the configuator
    ✓ Upgrades the weth DebtToken implementation 
    ✓ Tries to update the LendPoolLoan implementation with a different address than the address provider
    ✓ Upgrades the LendPoolLoan implementation 

  UToken: Modifiers
    ✓ Tries to invoke mint not being the Pool
    ✓ Tries to invoke burn not being the Pool
    ✓ Tries to invoke mintToTreasury not being the Pool
    ✓ Tries to invoke transferUnderlyingTo not being the Pool
    ✓ Tries to invoke depositReserves not being the Pool
    ✓ Tries to invoke withdrawReserves not being the Pool
    ✓ Tries to invoke sweepUToken not being the PoolAdmin

  UToken
    ✓ Check WETH basic parameters
    ✓ Check the onlyAdmin on set treasury to new utoken
    ✓ Check the zero check on set treasury to new utoken
    ✓ Check the address is properly updated in WETH uToken
    ✓ 10 WETH are sent to UToken, sweep deposits them into Yearn Vault
    ✓ User 8 deposits 1000 WETH, transfers uweth to user 6

  WETHGateway - Delegate
    ✓ Hacker try to delegate different onBehalf (should revert)
    ✓ Borrower try to Borrow more ETH to different onBehalf (should revert)
Hacker try Borrow more ETH with others NFT
    ✓ Hacker try to Borrow more ETH (should revert)

  WETHGateway
    ✓ Deposit WETH via WethGateway 
    ✓ Withdraw WETH - Partial
    ✓ Withdraw WETH - Full
    ✓ Borrow WETH and Full Repay with ETH
Partial Repay ETH loan with native ETH
Full Repay ETH loan with native ETH
    ✓ Borrow ETH and Full Repay with ETH
    ✓ Should revert if receiver function receives Ether if not WETH
    ✓ Should revert if fallback functions is called with Ether
    ✓ Should revert if fallback functions is called
    ✓ Owner can do emergency ERC20 recovery
    ✓ Owner can do emergency ERC721 recovery
*** SelfdestructTransferMock ***

Network: hardhat
tx: 0xf3baedb8a9acec63cacdd4e094eb35a95edb46a79f90bea759aff7a623154af2
contract address: 0x3C2AeD703EF55ABE3C9D1080418406Fae704bae0
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000059
gas used: 88001

******

contracts-helpers:registerContractInJsonDb, contractId: SelfdestructTransferMock address: 0x3C2AeD703EF55ABE3C9D1080418406Fae704bae0 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    ✓ Owner can do emergency native ETH recovery

  WETHGateway - Liquidate

    23) Borrow ETH and Liquidate it

    24) Borrow ETH and Redeem it

  LendPool: Withdraw negative test cases
    ✓ Users 0 Deposits 1000 DAI and tries to withdraw 0 DAI (revert expected)
    ✓ Users 0 tries to withdraw 1100 DAI from the 1000 DAI deposited (revert expected)
    ✓ Users 1 borrows 100 DAI, users 0 tries to withdraw the 1000 DAI deposited (revert expected)
    ✓ Users 1 deposits 1 WETH, users 0 borrows 0.01 WETH, users 1 tries to withdraw the 1 WETH deposited (revert expected)

  LendPool: Withdraw
    ✓ User 0 Deposits 1000 DAI in an empty reserve
    ✓ User 0 withdraws half of the deposited DAI
    ✓ User 0 withdraws remaining half of the deposited DAI
    ✓ User 0 Deposits 1 WETH in an empty reserve
    ✓ User 0 withdraws half of the deposited WETH
    ✓ User 0 tries to withdraw remaining half of the deposited WETH (expect revert due to not enough liquidity)
    ✓ User 0 tries to withdraw remaining half of the deposited WETH 
    ✓ Users 0 and 1 Deposit 1000 DAI, both withdraw
    ✓ Users 0 deposits 1000 DAI, user 1 Deposit 1000 USDC and 1 WETH, borrows 100 DAI. User 1 tries to withdraw all the USDC

  UToken: Yearn integration
    ✓ User 0 deposits 10 WETH in an empty reserve, WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    ✓ User 1 deposits 10 WETH in the reserve, WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    ✓ User 0 withdraws 10 WETH, WETH is withdrawn from the Yearn Vault and WETH is given back to user
    ✓ User 2 deposits 1000 WETH in the reserve. WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    ✓ User 2 withdraws 500 WETH from the reserve, then 500 more. WETH is withdrawn from Yearn Vault and WETH is given back to user

·---------------------------------------------------------------------------------|---------------------------|-------------|-----------------------------·
|                               [90mSolc version: 0.8.4[39m                               ·  [90mOptimizer enabled: true[39m  ·  [90mRuns: 200[39m  ·  [90mBlock limit: 12450000 gas[39m  │
··················································································|···························|·············|······························
|  [32m[1mMethods[22m[39m                                                                                                                                                │
······································|···········································|·············|·············|·············|···············|··············
|  [1mContract[22m                           ·  [1mMethod[22m                                   ·  [32mMin[39m        ·  [32mMax[39m        ·  [32mAvg[39m        ·  [1m# calls[22m      ·  [1meur (avg)[22m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  allInitialOwnersAssigned                 ·      [36m25618[39m  ·      [31m45518[39m  ·      30593  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  offerPunkForSaleToAddress                ·          -  ·          -  ·     119299  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  setInitialOwner                          ·      [36m60589[39m  ·      [31m77689[39m  ·      70849  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  transferPunk                             ·          -  ·          -  ·      66575  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mDebtMarket[39m                         ·  cancelDebtListing                        ·      [36m96604[39m  ·      [31m96746[39m  ·      96675  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mDebtMarket[39m                         ·  createDebtListing                        ·     [36m294116[39m  ·     [31m345416[39m  ·     303326  ·           [90m13[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mDebtMarket[39m                         ·  createDebtListingWithAuction             ·     [36m329771[39m  ·     [31m329783[39m  ·     329774  ·           [90m13[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mDebtMarket[39m                         ·  setDeltaBidPercent                       ·      [36m51164[39m  ·      [31m51174[39m  ·      51169  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  approve                                  ·      [36m26200[39m  ·      [31m53948[39m  ·      38453  ·          [90m159[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  transfer                                 ·      [36m29706[39m  ·     [31m155210[39m  ·      50636  ·          [90m163[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  transferFrom                             ·      [36m62447[39m  ·     [31m124787[39m  ·     107226  ·          [90m111[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mERC721Upgradeable[39m                  ·  safeTransferFrom                         ·          -  ·          -  ·     123319  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mERC721Upgradeable[39m                  ·  setApprovalForAll                        ·      [36m26380[39m  ·      [31m46280[39m  ·      35456  ·          [90m114[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setAddress                               ·      [36m29481[39m  ·      [31m49381[39m  ·      40353  ·           [90m35[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setAddressAsProxy                        ·     [36m633558[39m  ·     [31m699898[39m  ·     662991  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setEmergencyAdmin                        ·          -  ·          -  ·      47355  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setIncentivesController                  ·      [36m27475[39m  ·      [31m47375[39m  ·      37425  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolConfiguratorImpl              ·          -  ·          -  ·     610449  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolImpl                          ·          -  ·          -  ·     698762  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolLiquidator                    ·      [36m27543[39m  ·      [31m47443[39m  ·      37493  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolLoanImpl                      ·      [36m43396[39m  ·     [31m659458[39m  ·     454104  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLSSVMRouter                           ·          -  ·          -  ·      47442  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setNFTOracle                             ·          -  ·          -  ·      47421  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setNFTXVaultFactory                      ·          -  ·          -  ·      47377  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setPoolAdmin                             ·          -  ·          -  ·      47444  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setReserveOracle                         ·          -  ·          -  ·      47354  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setSushiSwapRouter                       ·          -  ·          -  ·      47399  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUIDataProvider                        ·          -  ·          -  ·      47295  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUNFTRegistry                          ·      [36m27476[39m  ·      [31m47376[39m  ·      37426  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUnlockdDataProvider                   ·          -  ·          -  ·      47421  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setWalletBalanceProvider                 ·          -  ·          -  ·      47463  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  transferOwnership                        ·          -  ·          -  ·      28645  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProviderRegistry[39m  ·  registerAddressesProvider                ·          -  ·          -  ·      92000  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchConfigNft                           ·      [36m88027[39m  ·    [31m1105232[39m  ·     836531  ·           [90m16[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchConfigReserve                       ·          -  ·          -  ·      68171  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchInitNft                             ·     [36m241686[39m  ·     [31m257048[39m  ·     246867  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchInitReserve                         ·          -  ·          -  ·    1631429  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  configureNftAsAuction                    ·      [36m68252[39m  ·      [31m68288[39m  ·      68270  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  configureNftsAsCollateral                ·      [36m96973[39m  ·     [31m133973[39m  ·     113958  ·           [90m72[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnNft                       ·      [36m78212[39m  ·      [31m83817[39m  ·      81015  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnNftByTokenId              ·      [36m69707[39m  ·      [31m69719[39m  ·      69713  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnReserve                   ·          -  ·          -  ·      63878  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setBorrowingFlagOnReserve                ·      [36m66624[39m  ·      [31m66648[39m  ·      66642  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnNft                       ·      [36m66687[39m  ·      [31m66700[39m  ·      66694  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnNftByTokenId              ·      [36m69637[39m  ·      [31m69649[39m  ·      69643  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnReserve                   ·      [36m66627[39m  ·      [31m66639[39m  ·      66633  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setLtvManagerStatus                      ·      [36m39630[39m  ·      [31m59530[39m  ·      46540  ·           [90m72[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setNftMinBidFine                         ·      [36m68059[39m  ·      [31m68083[39m  ·      68071  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setNftRedeemThreshold                    ·      [36m68102[39m  ·      [31m68126[39m  ·      68114  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setPoolPause                             ·      [36m64331[39m  ·     [31m101174[39m  ·      82753  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setPoolRescuer                           ·      [36m63903[39m  ·      [31m81003[39m  ·      72453  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setReserveFactor                         ·          -  ·          -  ·      66921  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  updateDebtToken                          ·          -  ·          -  ·      89474  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  updateUToken                             ·          -  ·          -  ·      89364  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLockeyHolder[39m                       ·  setLockeyDiscountPercentage              ·          -  ·          -  ·      58785  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mLockeyHolder[39m                       ·  setLockeyDiscountPercentageOnDebtMarket  ·      [36m41597[39m  ·      [31m58697[39m  ·      50147  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMaliciousHackerERC721[39m              ·  approveDelegate                          ·          -  ·          -  ·      87479  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMaliciousHackerERC721[39m              ·  simulateAction                           ·      [36m26483[39m  ·      [31m43583[39m  ·      28926  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockChainlinkOracle[39m                ·  mockAddAnswer                            ·     [36m125897[39m  ·     [31m245509[39m  ·     149398  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockDebtTokenVersionN[39m              ·  approveDelegation                        ·      [36m36248[39m  ·      [31m56148[39m  ·      50111  ·           [90m24[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockIncentivesController[39m           ·  resetHandleActionIsCalled                ·      [36m25882[39m  ·      [31m29026[39m  ·      27711  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  approveValuation                         ·      [36m64013[39m  ·      [31m71393[39m  ·      65858  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  borrow                                   ·     [36m461336[39m  ·     [31m906226[39m  ·     856862  ·           [90m54[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  buyOut                                   ·     [36m779133[39m  ·     [31m782193[39m  ·     780663  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  deposit                                  ·     [36m257359[39m  ·     [31m329154[39m  ·     303576  ·           [90m76[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  liquidateSudoSwap                        ·          -  ·          -  ·     693713  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  repay                                    ·     [36m359988[39m  ·     [31m666076[39m  ·     534895  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  rescue                                   ·          -  ·          -  ·      57119  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setIsMarketSupported                     ·      [36m58528[39m  ·      [31m78452[39m  ·      73468  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setMaxNumberOfReserves                   ·          -  ·          -  ·      62675  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setTimeframe                             ·      [36m58143[39m  ·      [31m78055[39m  ·      61975  ·           [90m17[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  updateSafeHealthFactor                   ·      [36m40218[39m  ·      [31m60118[39m  ·      56793  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  withdraw                                 ·     [36m241640[39m  ·     [31m280640[39m  ·     270618  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  addCollection                            ·      [36m47505[39m  ·      [31m54843[39m  ·      49822  ·           [90m19[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  initialize                               ·          -  ·          -  ·     113794  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  removeCollection                         ·          -  ·          -  ·      25685  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setMultipleNFTPrices                     ·      [36m62686[39m  ·      [31m84325[39m  ·      73684  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setNFTPrice                              ·      [36m33049[39m  ·      [31m60368[39m  ·      43650  ·           [90m75[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setPause                                 ·      [36m27850[39m  ·      [31m49762[39m  ·      38806  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setPriceManagerStatus                    ·      [36m33894[39m  ·      [31m53794[39m  ·      37701  ·           [90m85[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  addAggregator                            ·      [36m75602[39m  ·      [31m92702[39m  ·      89282  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  initialize                               ·          -  ·          -  ·      90917  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  mock_setBlockTimestamp                   ·          -  ·          -  ·      26541  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  removeAggregator                         ·      [36m33119[39m  ·      [31m37640[39m  ·      34023  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  setAggregators                           ·          -  ·          -  ·     101406  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockUTokenVersionN[39m                 ·  setTreasuryAddress                       ·          -  ·          -  ·      43299  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mMockUTokenVersionN[39m                 ·  sweepUToken                              ·          -  ·          -  ·     134846  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  authorizeCallerWhitelist                 ·      [36m62136[39m  ·     [31m103554[39m  ·      81753  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  authorizeLendPoolERC20                   ·          -  ·          -  ·      75304  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  borrow                                   ·    [36m1032675[39m  ·    [31m1066995[39m  ·    1049835  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  borrowETH                                ·     [36m553003[39m  ·    [31m1137931[39m  ·    1010650  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  buyDebtPunk                              ·          -  ·          -  ·     542926  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  buyDebtPunkETH                           ·          -  ·          -  ·     557700  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  emergencyERC20Transfer                   ·          -  ·          -  ·      65139  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  emergencyERC721Transfer                  ·          -  ·          -  ·     125982  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  emergencyPunksTransfer                   ·          -  ·          -  ·      79849  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  repayETH                                 ·     [36m457376[39m  ·     [31m829215[39m  ·     696298  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mRepayAndTransferHelper[39m             ·  emergencyEtherTransfer                   ·          -  ·          -  ·      42657  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mRepayAndTransferHelper[39m             ·  repayETHAndTransferERC721                ·          -  ·          -  ·     838830  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mSelfdestructTransfer[39m               ·  destroyAndTransfer                       ·      [36m29253[39m  ·      [31m54253[39m  ·      29446  ·          [90m276[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mUNFTRegistry[39m                       ·  createUNFT                               ·     [36m725318[39m  ·     [31m742551[39m  ·     731099  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  authorizeLendPoolNFT                     ·          -  ·          -  ·     128840  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  bidDebtETH                               ·     [36m192663[39m  ·     [31m227676[39m  ·     212721  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  borrowETH                                ·     [36m506187[39m  ·     [31m996336[39m  ·     887509  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  buyDebtETH                               ·     [36m532178[39m  ·     [31m591712[39m  ·     569257  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  depositETH                               ·     [36m292269[39m  ·     [31m377744[39m  ·     348026  ·           [90m17[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  repayETH                                 ·     [36m404818[39m  ·     [31m684838[39m  ·     550813  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  withdrawETH                              ·     [36m341734[39m  ·     [31m384760[39m  ·     363247  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [90mWrappedPunk[39m                        ·  setApprovalForAll                        ·      [36m26420[39m  ·      [31m46320[39m  ·      41345  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|···········································|·············|·············|·············|···············|··············
|  [32m[1mDeployments[22m[39m                                                                    ·                                         ·  [1m% of limit[22m   ·             │
··················································································|·············|·············|·············|···············|··············
|  BorrowLogic                                                                    ·          -  ·          -  ·    2060203  ·       [90m16.5 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  ConfiguratorLogic                                                              ·          -  ·          -  ·    1970106  ·       [90m15.8 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  CryptoPunksMarket                                                              ·          -  ·          -  ·    2378109  ·       [90m19.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  DebtMarket                                                                     ·          -  ·          -  ·    3289330  ·       [90m26.4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  DebtToken                                                                      ·          -  ·          -  ·    1455765  ·       [90m11.7 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  GenericLogic                                                                   ·          -  ·          -  ·      84290  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  InterestRate                                                                   ·     [36m613836[39m  ·     [31m613848[39m  ·     613843  ·        [90m4.9 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LendingLogic                                                                   ·          -  ·          -  ·      72217  ·        [90m0.6 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LendPool                                                                       ·          -  ·          -  ·    5328527  ·       [90m42.8 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LendPoolAddressesProvider                                                      ·          -  ·          -  ·    2978496  ·       [90m23.9 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LendPoolAddressesProviderRegistry                                              ·          -  ·          -  ·     502283  ·          [90m4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LendPoolConfigurator                                                           ·          -  ·          -  ·    5230541  ·         [90m42 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LendPoolLoan                                                                   ·          -  ·          -  ·    3737747  ·         [90m30 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LiquidateLogic                                                                 ·          -  ·          -  ·    5017191  ·       [90m40.3 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LiquidateMarketsLogic                                                          ·          -  ·          -  ·    3025524  ·       [90m24.3 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  LockeyHolder                                                                   ·          -  ·          -  ·     293631  ·        [90m2.4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  MaliciousHackerERC721                                                          ·          -  ·          -  ·     801955  ·        [90m6.4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  MockChainlinkOracle                                                            ·          -  ·          -  ·     620122  ·          [90m5 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  MockIncentivesController                                                       ·          -  ·          -  ·     142669  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  MockNFTOracle                                                                  ·          -  ·          -  ·    1117453  ·          [90m9 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  MockReserveOracle                                                              ·          -  ·          -  ·    1280668  ·       [90m10.3 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  NftLogic                                                                       ·          -  ·          -  ·     141022  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  NFTOracle                                                                      ·          -  ·          -  ·    1047527  ·        [90m8.4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  PunkGateway                                                                    ·          -  ·          -  ·    3587787  ·       [90m28.8 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  RepayAndTransferHelper                                                         ·          -  ·          -  ·     883669  ·        [90m7.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  ReserveLogic                                                                   ·          -  ·          -  ·     171208  ·        [90m1.4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  ReserveOracle                                                                  ·          -  ·          -  ·    1211618  ·        [90m9.7 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  SelfdestructTransfer                                                           ·          -  ·          -  ·      88001  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  SupplyLogic                                                                    ·          -  ·          -  ·    1235281  ·        [90m9.9 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UiPoolDataProvider                                                             ·          -  ·          -  ·    3056749  ·       [90m24.6 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UNFT                                                                           ·          -  ·          -  ·    1503057  ·       [90m12.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UNFTRegistry                                                                   ·          -  ·          -  ·    2441516  ·       [90m19.6 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UnlockdProtocolDataProvider                                                    ·          -  ·          -  ·    3157791  ·       [90m25.4 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UnlockdProxyAdmin                                                              ·          -  ·          -  ·     470704  ·        [90m3.8 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UnlockdUpgradeableProxy                                                        ·     [36m689038[39m  ·     [31m998847[39m  ·     777211  ·        [90m6.2 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  UToken                                                                         ·          -  ·          -  ·    2710730  ·       [90m21.8 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  ValidationLogic                                                                ·          -  ·          -  ·    1573518  ·       [90m12.6 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  WalletBalanceProvider                                                          ·          -  ·          -  ·    1251354  ·       [90m10.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  WETHGateway                                                                    ·          -  ·          -  ·    2997021  ·       [90m24.1 %[39m  ·          [32m[90m-[32m[39m  │
··················································································|·············|·············|·············|···············|··············
|  WrappedPunk                                                                    ·          -  ·          -  ·    1992593  ·         [90m16 %[39m  ·          [32m[90m-[32m[39m  │
·---------------------------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------·

  281 passing (5m)
  24 failing

  1) Buy and sell the debts
       Positive
         Claim an auction:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '1011'", method="estimateGas", transaction={"from":"0x5657118C630e2dd8878072DC6274be1F0AAE9a43","to":"0x80Fa1fA8B0CaF15CFC3961C934cFA860945d9139","data":"0x9e96a260000000000000000000000000bc4ca0eda7647a8ab7c2061c2e118a18a936f13d00000000000000000000000000000000000000000000000000000000000000700000000000000000000000005657118c630e2dd8878072dc6274be1f0aae9a43","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"claim","contract":"DebtMarket","sourceName":"contracts/protocol/DebtMarket.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IDebtMarket} from \"../interfaces/IDebtMarket.sol\";\nimport {IUNFT} from \"../interfaces/IUNFT.sol\";\nimport {IDebtToken} from \"../interfaces/IDebtToken.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILockeyHolder} from \"../interfaces/ILockeyHolder.sol\";\n\ncontract DebtMarket is Initializable, ContextUpgradeable, IDebtMarket {\n  using CountersUpgradeable for CountersUpgradeable.Counter;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using PercentageMath for uint256;\n\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  CountersUpgradeable.Counter private _debtIdTracker;\n  mapping(uint256 => DataTypes.DebtMarketListing) private _marketListings;\n  mapping(address => mapping(uint256 => uint256)) private _nftToDebtIds;\n  mapping(address => mapping(address => uint256)) private _userTotalDebtByCollection;\n  mapping(address => uint256) private _totalDebtsByCollection;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n  uint256 private _deltaBidPercent;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n  modifier nonDuplicatedDebt(address nftAsset, uint256 tokenId) {\n    require(_nftToDebtIds[nftAsset][tokenId] == 0, Errors.DM_DEBT_ALREADY_EXIST);\n    _;\n  }\n  modifier onlyOwnerOfBorrowedNft(address nftAsset, uint256 tokenId) {\n    address lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    uint256 loanId = ILendPoolLoan(lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n    require(loanId != 0, Errors.DM_LOAN_SHOULD_EXIST);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(lendPoolLoanAddress).getLoan(loanId);\n    require(loanData.borrower == msg.sender, Errors.DM_CALLER_NOT_THE_OWNER);\n    _;\n  }\n\n  modifier debtShouldExistGuard(address nftAsset, uint256 tokenId) {\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n    require(debtId != 0, Errors.DM_DEBT_SHOULD_EXIST);\n    DataTypes.DebtMarketListing memory selldebt = _marketListings[debtId];\n    require(_userTotalDebtByCollection[selldebt.debtor][nftAsset] >= 1, Errors.DM_DEBT_SHOULD_EXIST);\n    require(_totalDebtsByCollection[nftAsset] >= 1, Errors.DM_DEBT_SHOULD_EXIST);\n    _;\n  }\n\n  struct TransferLocalVars {\n    address lendPoolLoanAddress;\n    address lendPoolAddress;\n    uint256 loanId;\n    address buyer;\n    uint256 debtId;\n    uint256 borrowAmount;\n  }\n  struct BuyLocalVars {\n    uint256 debtId;\n    address lendPoolLoanAddress;\n    address lockeysCollection;\n    address lockeyHolderAddress;\n    uint256 loanId;\n    uint256 price;\n  }\n\n  function initialize(ILendPoolAddressesProvider addressesProvider) external initializer {\n    _addressesProvider = addressesProvider;\n    _deltaBidPercent = PercentageMath.ONE_PERCENT;\n  }\n\n  function createDebtListing(\n    address nftAsset,\n    uint256 tokenId,\n    uint256 sellPrice,\n    address onBehalfOf\n  ) external nonReentrant nonDuplicatedDebt(nftAsset, tokenId) onlyOwnerOfBorrowedNft(nftAsset, tokenId) {\n    _createDebt(nftAsset, tokenId, sellPrice, onBehalfOf);\n\n    uint256 debtId = _debtIdTracker.current();\n    DataTypes.DebtMarketListing memory marketListing = _marketListings[debtId];\n\n    emit DebtListingCreated(\n      marketListing.debtId,\n      marketListing.debtor,\n      marketListing.nftAsset,\n      marketListing.tokenId,\n      marketListing.sellType,\n      marketListing.state,\n      marketListing.sellPrice,\n      marketListing.reserveAsset,\n      marketListing.scaledAmount\n    );\n  }\n\n  function createDebtListingWithAuction(\n    address nftAsset,\n    uint256 tokenId,\n    uint256 sellPrice,\n    address onBehalfOf,\n    uint256 auctionEndTimestamp\n  ) external nonReentrant nonDuplicatedDebt(nftAsset, tokenId) onlyOwnerOfBorrowedNft(nftAsset, tokenId) {\n    // solhint-disable-next-line\n    require(auctionEndTimestamp >= block.timestamp, Errors.DM_AUCTION_ALREADY_ENDED);\n\n    _createDebt(nftAsset, tokenId, sellPrice, onBehalfOf);\n\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[debtId];\n    marketListing.sellType = DataTypes.DebtMarketType.Auction;\n    marketListing.auctionEndTimestamp = auctionEndTimestamp;\n\n    emit DebtAuctionCreated(\n      marketListing.debtId,\n      marketListing.debtor,\n      marketListing.nftAsset,\n      marketListing.tokenId,\n      marketListing.sellType, // Auction\n      marketListing.state,\n      marketListing.sellPrice,\n      marketListing.reserveAsset,\n      marketListing.scaledAmount\n    );\n  }\n\n  function cancelDebtListing(\n    address nftAsset,\n    uint256 tokenId\n  ) external nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n\n    DataTypes.DebtMarketListing storage selldebt = _marketListings[debtId];\n    require(selldebt.state != DataTypes.DebtMarketState.Sold, Errors.DM_DEBT_SHOULD_NOT_BE_SOLD);\n    selldebt.state = DataTypes.DebtMarketState.Canceled;\n    _deleteDebtOfferListing(nftAsset, tokenId);\n\n    _nftToDebtIds[nftAsset][tokenId] = 0;\n\n    if (selldebt.bidderAddress != address(0)) {\n      IERC20Upgradeable(selldebt.reserveAsset).safeTransferFrom(\n        address(this),\n        selldebt.bidderAddress,\n        selldebt.bidPrice\n      );\n    }\n\n    emit DebtListingCanceled(\n      selldebt.debtor,\n      selldebt.debtId,\n      selldebt,\n      _totalDebtsByCollection[nftAsset],\n      _userTotalDebtByCollection[selldebt.debtor][nftAsset]\n    );\n  }\n\n  function buy(\n    address nftAsset,\n    uint256 tokenId,\n    address onBehalfOf,\n    uint256 amount\n  ) external override nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    BuyLocalVars memory vars;\n\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n    vars.lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    vars.lockeysCollection = _addressesProvider.getAddress(keccak256(\"LOCKEY_COLLECTION\"));\n    vars.lockeyHolderAddress = _addressesProvider.getAddress(keccak256(\"LOCKEY_HOLDER\"));\n    vars.loanId = ILendPoolLoan(vars.lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n    require(vars.loanId != 0, Errors.DM_LOAN_SHOULD_EXIST);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.lendPoolLoanAddress).getLoan(vars.loanId);\n    DataTypes.DebtMarketListing memory marketOrder = _marketListings[vars.debtId];\n\n    _transferDebt(nftAsset, tokenId, onBehalfOf);\n    vars.price = marketOrder.sellPrice;\n\n    if (IERC721Upgradeable(vars.lockeysCollection).balanceOf(onBehalfOf) > 0) {\n      vars.price = marketOrder.sellPrice.percentMul(\n        ILockeyHolder(vars.lockeyHolderAddress).getLockeyDiscountPercentageOnDebtMarket()\n      );\n    }\n\n    require(vars.price == amount, Errors.DM_AMOUNT_DIFFERENT_FROM_SELL_PRICE);\n\n    // Pay to the seller with ERC20\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(_msgSender(), loanData.borrower, vars.price);\n\n    // Create a event\n    emit DebtSold(loanData.borrower, onBehalfOf, vars.debtId);\n  }\n\n  struct BidLocalVars {\n    uint256 loanId;\n    address previousBidder;\n    uint256 previousBidPrice;\n    uint256 borrowAmount;\n    uint256 debtId;\n  }\n\n  function bid(\n    address nftAsset,\n    uint256 tokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    BidLocalVars memory vars;\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[vars.debtId];\n    vars.previousBidder = marketListing.bidderAddress;\n    vars.previousBidPrice = marketListing.bidPrice;\n\n    require(bidPrice >= marketListing.sellPrice, Errors.DM_BID_PRICE_LESS_THAN_SELL_PRICE);\n    require(\n      bidPrice > (marketListing.bidPrice + marketListing.bidPrice.percentMul(_deltaBidPercent)),\n      Errors.DM_BID_PRICE_LESS_THAN_PREVIOUS_BID\n    );\n    require(marketListing.sellType == DataTypes.DebtMarketType.Auction, Errors.DM_INVALID_SELL_TYPE);\n    require(block.timestamp <= marketListing.auctionEndTimestamp, Errors.DM_AUCTION_ALREADY_ENDED);\n\n    marketListing.state = DataTypes.DebtMarketState.Active;\n    marketListing.bidderAddress = onBehalfOf;\n    marketListing.bidPrice = bidPrice;\n\n    IERC20Upgradeable(marketListing.reserveAsset).safeTransferFrom(_msgSender(), address(this), bidPrice);\n\n    if (vars.previousBidder != address(0)) {\n      IERC20Upgradeable(marketListing.reserveAsset).safeTransferFrom(\n        address(this),\n        vars.previousBidder,\n        vars.previousBidPrice\n      );\n    }\n\n    emit BidPlaced(\n      marketListing.bidderAddress,\n      marketListing.reserveAsset,\n      nftAsset,\n      tokenId,\n      vars.debtId,\n      marketListing.bidPrice\n    );\n  }\n\n  function claim(\n    address nftAsset,\n    uint256 tokenId,\n    address onBehalfOf\n  ) external override nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    BidLocalVars memory vars;\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[vars.debtId];\n\n    require(marketListing.sellType == DataTypes.DebtMarketType.Auction, Errors.DM_INVALID_SELL_TYPE);\n    require(onBehalfOf == marketListing.bidderAddress, Errors.DM_INVALID_CLAIM_RECEIVER);\n    require(block.timestamp > marketListing.auctionEndTimestamp, Errors.DM_AUCTION_NOT_ALREADY_ENDED);\n\n    marketListing.state = DataTypes.DebtMarketState.Sold;\n\n    _transferDebt(nftAsset, tokenId, onBehalfOf);\n\n    IERC20Upgradeable(marketListing.reserveAsset).safeTransfer(marketListing.debtor, marketListing.bidPrice);\n\n    // Create a event\n    emit DebtClaimed(marketListing.debtor, onBehalfOf, vars.debtId);\n  }\n\n  function _deleteDebtOfferListing(address nftAsset, uint256 tokenId) internal {\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n    DataTypes.DebtMarketListing storage selldebt = _marketListings[debtId];\n\n    _userTotalDebtByCollection[selldebt.debtor][nftAsset] -= 1;\n    _totalDebtsByCollection[nftAsset] -= 1;\n  }\n\n  function _createDebt(address nftAsset, uint256 tokenId, uint256 sellPrice, address onBehalfOf) internal {\n    require(onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n    require(sellPrice > 0, Errors.DM_INVALID_AMOUNT);\n\n    address lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    uint256 loanId = ILendPoolLoan(lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n    require(loanId != 0, Errors.DM_LOAN_SHOULD_EXIST);\n\n    _debtIdTracker.increment();\n\n    uint256 debtId = _debtIdTracker.current();\n    _nftToDebtIds[nftAsset][tokenId] = debtId;\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[debtId];\n\n    marketListing.debtId = debtId;\n    marketListing.nftAsset = nftAsset;\n    marketListing.tokenId = tokenId;\n    marketListing.sellPrice = sellPrice;\n    marketListing.debtor = onBehalfOf;\n\n    (, , address reserveAsset, uint256 scaledAmount) = ILendPoolLoan(lendPoolLoanAddress).getLoanCollateralAndReserve(\n      loanId\n    );\n    marketListing.reserveAsset = reserveAsset;\n    marketListing.scaledAmount = scaledAmount;\n    marketListing.state = DataTypes.DebtMarketState.New;\n\n    _userTotalDebtByCollection[onBehalfOf][nftAsset] += 1;\n    _totalDebtsByCollection[nftAsset] += 1;\n  }\n\n  function _transferDebt(address nftAsset, uint256 tokenId, address onBehalfOf) internal {\n    TransferLocalVars memory vars;\n\n    vars.lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    vars.lendPoolAddress = _addressesProvider.getLendPool();\n    vars.loanId = ILendPoolLoan(vars.lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.lendPoolLoanAddress).getLoan(vars.loanId);\n    DataTypes.ReserveData memory reserveData = ILendPool(vars.lendPoolAddress).getReserveData(loanData.reserveAsset);\n    // reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.lendPoolLoanAddress).getLoanReserveBorrowAmount(vars.loanId);\n\n    vars.buyer = onBehalfOf;\n\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n    // Burn debt from seller\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n    // Mint debt from buyer\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.buyer,\n      vars.buyer,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // Burn unft from seller\n    // Mint unft from buyer\n    ILendPoolLoan(vars.lendPoolLoanAddress).reMintUNFT(\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.buyer\n    );\n    // Remove the offer listing\n    DataTypes.DebtMarketListing storage marketOrder = _marketListings[vars.debtId];\n    marketOrder.state = DataTypes.DebtMarketState.Sold;\n    _deleteDebtOfferListing(nftAsset, tokenId);\n  }\n\n  function setDeltaBidPercent(uint256 value) external override nonReentrant onlyPoolAdmin {\n    _deltaBidPercent = value;\n  }\n\n  function getDebtId(address nftAsset, uint256 tokenId) external view returns (uint256) {\n    return _nftToDebtIds[nftAsset][tokenId];\n  }\n\n  function getDebt(uint256 debtId) external view returns (DataTypes.DebtMarketListing memory sellDebt) {\n    return _marketListings[debtId];\n  }\n\n  function getDebtIdTracker() external view returns (CountersUpgradeable.Counter memory) {\n    return _debtIdTracker;\n  }\n}\n","line":288,"range":[10814,11753]},"functionType":1},{"type":4,"sourceReference":{"function":"nonReentrant","contract":"DebtMarket","sourceName":"contracts/protocol/DebtMarket.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IDebtMarket} from \"../interfaces/IDebtMarket.sol\";\nimport {IUNFT} from \"../interfaces/IUNFT.sol\";\nimport {IDebtToken} from \"../interfaces/IDebtToken.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILockeyHolder} from \"../interfaces/ILockeyHolder.sol\";\n\ncontract DebtMarket is Initializable, ContextUpgradeable, IDebtMarket {\n  using CountersUpgradeable for CountersUpgradeable.Counter;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using PercentageMath for uint256;\n\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  CountersUpgradeable.Counter private _debtIdTracker;\n  mapping(uint256 => DataTypes.DebtMarketListing) private _marketListings;\n  mapping(address => mapping(uint256 => uint256)) private _nftToDebtIds;\n  mapping(address => mapping(address => uint256)) private _userTotalDebtByCollection;\n  mapping(address => uint256) private _totalDebtsByCollection;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n  uint256 private _deltaBidPercent;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n  modifier nonDuplicatedDebt(address nftAsset, uint256 tokenId) {\n    require(_nftToDebtIds[nftAsset][tokenId] == 0, Errors.DM_DEBT_ALREADY_EXIST);\n    _;\n  }\n  modifier onlyOwnerOfBorrowedNft(address nftAsset, uint256 tokenId) {\n    address lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    uint256 loanId = ILendPoolLoan(lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n    require(loanId != 0, Errors.DM_LOAN_SHOULD_EXIST);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(lendPoolLoanAddress).getLoan(loanId);\n    require(loanData.borrower == msg.sender, Errors.DM_CALLER_NOT_THE_OWNER);\n    _;\n  }\n\n  modifier debtShouldExistGuard(address nftAsset, uint256 tokenId) {\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n    require(debtId != 0, Errors.DM_DEBT_SHOULD_EXIST);\n    DataTypes.DebtMarketListing memory selldebt = _marketListings[debtId];\n    require(_userTotalDebtByCollection[selldebt.debtor][nftAsset] >= 1, Errors.DM_DEBT_SHOULD_EXIST);\n    require(_totalDebtsByCollection[nftAsset] >= 1, Errors.DM_DEBT_SHOULD_EXIST);\n    _;\n  }\n\n  struct TransferLocalVars {\n    address lendPoolLoanAddress;\n    address lendPoolAddress;\n    uint256 loanId;\n    address buyer;\n    uint256 debtId;\n    uint256 borrowAmount;\n  }\n  struct BuyLocalVars {\n    uint256 debtId;\n    address lendPoolLoanAddress;\n    address lockeysCollection;\n    address lockeyHolderAddress;\n    uint256 loanId;\n    uint256 price;\n  }\n\n  function initialize(ILendPoolAddressesProvider addressesProvider) external initializer {\n    _addressesProvider = addressesProvider;\n    _deltaBidPercent = PercentageMath.ONE_PERCENT;\n  }\n\n  function createDebtListing(\n    address nftAsset,\n    uint256 tokenId,\n    uint256 sellPrice,\n    address onBehalfOf\n  ) external nonReentrant nonDuplicatedDebt(nftAsset, tokenId) onlyOwnerOfBorrowedNft(nftAsset, tokenId) {\n    _createDebt(nftAsset, tokenId, sellPrice, onBehalfOf);\n\n    uint256 debtId = _debtIdTracker.current();\n    DataTypes.DebtMarketListing memory marketListing = _marketListings[debtId];\n\n    emit DebtListingCreated(\n      marketListing.debtId,\n      marketListing.debtor,\n      marketListing.nftAsset,\n      marketListing.tokenId,\n      marketListing.sellType,\n      marketListing.state,\n      marketListing.sellPrice,\n      marketListing.reserveAsset,\n      marketListing.scaledAmount\n    );\n  }\n\n  function createDebtListingWithAuction(\n    address nftAsset,\n    uint256 tokenId,\n    uint256 sellPrice,\n    address onBehalfOf,\n    uint256 auctionEndTimestamp\n  ) external nonReentrant nonDuplicatedDebt(nftAsset, tokenId) onlyOwnerOfBorrowedNft(nftAsset, tokenId) {\n    // solhint-disable-next-line\n    require(auctionEndTimestamp >= block.timestamp, Errors.DM_AUCTION_ALREADY_ENDED);\n\n    _createDebt(nftAsset, tokenId, sellPrice, onBehalfOf);\n\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[debtId];\n    marketListing.sellType = DataTypes.DebtMarketType.Auction;\n    marketListing.auctionEndTimestamp = auctionEndTimestamp;\n\n    emit DebtAuctionCreated(\n      marketListing.debtId,\n      marketListing.debtor,\n      marketListing.nftAsset,\n      marketListing.tokenId,\n      marketListing.sellType, // Auction\n      marketListing.state,\n      marketListing.sellPrice,\n      marketListing.reserveAsset,\n      marketListing.scaledAmount\n    );\n  }\n\n  function cancelDebtListing(\n    address nftAsset,\n    uint256 tokenId\n  ) external nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n\n    DataTypes.DebtMarketListing storage selldebt = _marketListings[debtId];\n    require(selldebt.state != DataTypes.DebtMarketState.Sold, Errors.DM_DEBT_SHOULD_NOT_BE_SOLD);\n    selldebt.state = DataTypes.DebtMarketState.Canceled;\n    _deleteDebtOfferListing(nftAsset, tokenId);\n\n    _nftToDebtIds[nftAsset][tokenId] = 0;\n\n    if (selldebt.bidderAddress != address(0)) {\n      IERC20Upgradeable(selldebt.reserveAsset).safeTransferFrom(\n        address(this),\n        selldebt.bidderAddress,\n        selldebt.bidPrice\n      );\n    }\n\n    emit DebtListingCanceled(\n      selldebt.debtor,\n      selldebt.debtId,\n      selldebt,\n      _totalDebtsByCollection[nftAsset],\n      _userTotalDebtByCollection[selldebt.debtor][nftAsset]\n    );\n  }\n\n  function buy(\n    address nftAsset,\n    uint256 tokenId,\n    address onBehalfOf,\n    uint256 amount\n  ) external override nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    BuyLocalVars memory vars;\n\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n    vars.lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    vars.lockeysCollection = _addressesProvider.getAddress(keccak256(\"LOCKEY_COLLECTION\"));\n    vars.lockeyHolderAddress = _addressesProvider.getAddress(keccak256(\"LOCKEY_HOLDER\"));\n    vars.loanId = ILendPoolLoan(vars.lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n    require(vars.loanId != 0, Errors.DM_LOAN_SHOULD_EXIST);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.lendPoolLoanAddress).getLoan(vars.loanId);\n    DataTypes.DebtMarketListing memory marketOrder = _marketListings[vars.debtId];\n\n    _transferDebt(nftAsset, tokenId, onBehalfOf);\n    vars.price = marketOrder.sellPrice;\n\n    if (IERC721Upgradeable(vars.lockeysCollection).balanceOf(onBehalfOf) > 0) {\n      vars.price = marketOrder.sellPrice.percentMul(\n        ILockeyHolder(vars.lockeyHolderAddress).getLockeyDiscountPercentageOnDebtMarket()\n      );\n    }\n\n    require(vars.price == amount, Errors.DM_AMOUNT_DIFFERENT_FROM_SELL_PRICE);\n\n    // Pay to the seller with ERC20\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(_msgSender(), loanData.borrower, vars.price);\n\n    // Create a event\n    emit DebtSold(loanData.borrower, onBehalfOf, vars.debtId);\n  }\n\n  struct BidLocalVars {\n    uint256 loanId;\n    address previousBidder;\n    uint256 previousBidPrice;\n    uint256 borrowAmount;\n    uint256 debtId;\n  }\n\n  function bid(\n    address nftAsset,\n    uint256 tokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    BidLocalVars memory vars;\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[vars.debtId];\n    vars.previousBidder = marketListing.bidderAddress;\n    vars.previousBidPrice = marketListing.bidPrice;\n\n    require(bidPrice >= marketListing.sellPrice, Errors.DM_BID_PRICE_LESS_THAN_SELL_PRICE);\n    require(\n      bidPrice > (marketListing.bidPrice + marketListing.bidPrice.percentMul(_deltaBidPercent)),\n      Errors.DM_BID_PRICE_LESS_THAN_PREVIOUS_BID\n    );\n    require(marketListing.sellType == DataTypes.DebtMarketType.Auction, Errors.DM_INVALID_SELL_TYPE);\n    require(block.timestamp <= marketListing.auctionEndTimestamp, Errors.DM_AUCTION_ALREADY_ENDED);\n\n    marketListing.state = DataTypes.DebtMarketState.Active;\n    marketListing.bidderAddress = onBehalfOf;\n    marketListing.bidPrice = bidPrice;\n\n    IERC20Upgradeable(marketListing.reserveAsset).safeTransferFrom(_msgSender(), address(this), bidPrice);\n\n    if (vars.previousBidder != address(0)) {\n      IERC20Upgradeable(marketListing.reserveAsset).safeTransferFrom(\n        address(this),\n        vars.previousBidder,\n        vars.previousBidPrice\n      );\n    }\n\n    emit BidPlaced(\n      marketListing.bidderAddress,\n      marketListing.reserveAsset,\n      nftAsset,\n      tokenId,\n      vars.debtId,\n      marketListing.bidPrice\n    );\n  }\n\n  function claim(\n    address nftAsset,\n    uint256 tokenId,\n    address onBehalfOf\n  ) external override nonReentrant debtShouldExistGuard(nftAsset, tokenId) {\n    BidLocalVars memory vars;\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[vars.debtId];\n\n    require(marketListing.sellType == DataTypes.DebtMarketType.Auction, Errors.DM_INVALID_SELL_TYPE);\n    require(onBehalfOf == marketListing.bidderAddress, Errors.DM_INVALID_CLAIM_RECEIVER);\n    require(block.timestamp > marketListing.auctionEndTimestamp, Errors.DM_AUCTION_NOT_ALREADY_ENDED);\n\n    marketListing.state = DataTypes.DebtMarketState.Sold;\n\n    _transferDebt(nftAsset, tokenId, onBehalfOf);\n\n    IERC20Upgradeable(marketListing.reserveAsset).safeTransfer(marketListing.debtor, marketListing.bidPrice);\n\n    // Create a event\n    emit DebtClaimed(marketListing.debtor, onBehalfOf, vars.debtId);\n  }\n\n  function _deleteDebtOfferListing(address nftAsset, uint256 tokenId) internal {\n    uint256 debtId = _nftToDebtIds[nftAsset][tokenId];\n    DataTypes.DebtMarketListing storage selldebt = _marketListings[debtId];\n\n    _userTotalDebtByCollection[selldebt.debtor][nftAsset] -= 1;\n    _totalDebtsByCollection[nftAsset] -= 1;\n  }\n\n  function _createDebt(address nftAsset, uint256 tokenId, uint256 sellPrice, address onBehalfOf) internal {\n    require(onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n    require(sellPrice > 0, Errors.DM_INVALID_AMOUNT);\n\n    address lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    uint256 loanId = ILendPoolLoan(lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n    require(loanId != 0, Errors.DM_LOAN_SHOULD_EXIST);\n\n    _debtIdTracker.increment();\n\n    uint256 debtId = _debtIdTracker.current();\n    _nftToDebtIds[nftAsset][tokenId] = debtId;\n    DataTypes.DebtMarketListing storage marketListing = _marketListings[debtId];\n\n    marketListing.debtId = debtId;\n    marketListing.nftAsset = nftAsset;\n    marketListing.tokenId = tokenId;\n    marketListing.sellPrice = sellPrice;\n    marketListing.debtor = onBehalfOf;\n\n    (, , address reserveAsset, uint256 scaledAmount) = ILendPoolLoan(lendPoolLoanAddress).getLoanCollateralAndReserve(\n      loanId\n    );\n    marketListing.reserveAsset = reserveAsset;\n    marketListing.scaledAmount = scaledAmount;\n    marketListing.state = DataTypes.DebtMarketState.New;\n\n    _userTotalDebtByCollection[onBehalfOf][nftAsset] += 1;\n    _totalDebtsByCollection[nftAsset] += 1;\n  }\n\n  function _transferDebt(address nftAsset, uint256 tokenId, address onBehalfOf) internal {\n    TransferLocalVars memory vars;\n\n    vars.lendPoolLoanAddress = _addressesProvider.getLendPoolLoan();\n    vars.lendPoolAddress = _addressesProvider.getLendPool();\n    vars.loanId = ILendPoolLoan(vars.lendPoolLoanAddress).getCollateralLoanId(nftAsset, tokenId);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.lendPoolLoanAddress).getLoan(vars.loanId);\n    DataTypes.ReserveData memory reserveData = ILendPool(vars.lendPoolAddress).getReserveData(loanData.reserveAsset);\n    // reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.lendPoolLoanAddress).getLoanReserveBorrowAmount(vars.loanId);\n\n    vars.buyer = onBehalfOf;\n\n    vars.debtId = _nftToDebtIds[nftAsset][tokenId];\n    // Burn debt from seller\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n    // Mint debt from buyer\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.buyer,\n      vars.buyer,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // Burn unft from seller\n    // Mint unft from buyer\n    ILendPoolLoan(vars.lendPoolLoanAddress).reMintUNFT(\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.buyer\n    );\n    // Remove the offer listing\n    DataTypes.DebtMarketListing storage marketOrder = _marketListings[vars.debtId];\n    marketOrder.state = DataTypes.DebtMarketState.Sold;\n    _deleteDebtOfferListing(nftAsset, tokenId);\n  }\n\n  function setDeltaBidPercent(uint256 value) external override nonReentrant onlyPoolAdmin {\n    _deltaBidPercent = value;\n  }\n\n  function getDebtId(address nftAsset, uint256 tokenId) external view returns (uint256) {\n    return _nftToDebtIds[nftAsset][tokenId];\n  }\n\n  function getDebt(uint256 debtId) external view returns (DataTypes.DebtMarketListing memory sellDebt) {\n    return _marketListings[debtId];\n  }\n\n  function getDebtIdTracker() external view returns (CountersUpgradeable.Counter memory) {\n    return _debtIdTracker;\n  }\n}\n","line":54,"range":[2806,2869]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,49,48,49,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000043130313100000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)

  2) Buy and sell the debts
       Negative
         Revert on try to bid a auction debt
           When auction already ended:

      AssertionError: Expected transaction to be reverted
      + expected - actual

      -Transaction NOT reverted.
      +Transaction reverted.
      
  

  3) LendPool: Liquidation negative test cases
       User 2 auction on a loan health factor above 1:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:143:43)
      at processImmediate (node:internal/timers:476:21)

  4) LendPool: Liquidation negative test cases
       User 2 auction price is unable to cover borrow:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:172:43)
      at processImmediate (node:internal/timers:476:21)

  5) LendPool: Liquidation negative test cases
       User 2 auction price is less than liquidate price:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:202:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)

  6) LendPool: Liquidation negative test cases
       User 2 auction price is enough to cover borrow and liqudiate price:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:215:43)
      at processImmediate (node:internal/timers:476:21)

  7) LendPool: Liquidation negative test cases
       User 3 auction price is lesser than user 2:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:229:43)
      at processImmediate (node:internal/timers:476:21)

  8) LendPool: Liquidation negative test cases
       User 2 liquidate before auction duration is end:
     AssertionError: Expected transaction to be reverted with 490, but other exception was thrown: Error: VM Exception while processing transaction: reverted with reason string '480'
  

  9) LendPool: Liquidation negative test cases
       User 1 redeem but bidFine is not fullfil to borrow amount of user 2 auction:
     AssertionError: Expected transaction to be reverted with 494, but other exception was thrown: Error: VM Exception while processing transaction: reverted with reason string '480'
  

  10) LendPool: Liquidation negative test cases
       User 1 redeem but amount is not fullfil to mininum repay amount:
     AssertionError: Expected transaction to be reverted with 415, but other exception was thrown: Error: VM Exception while processing transaction: reverted with reason string '480'
  

  11) LendPool: Liquidation negative test cases
       User 1 redeem but amount is not fullfil to maximum repay amount:
     AssertionError: Expected transaction to be reverted with 416, but other exception was thrown: Error: VM Exception while processing transaction: reverted with reason string '480'
  

  12) LendPool: Liquidation negative test cases
       User 1 redeem after duration is end:
     AssertionError: Expected transaction to be reverted with 486, but other exception was thrown: Error: VM Exception while processing transaction: reverted with reason string '480'
  

  13) LendPool: Liquidation negative test cases
       User 3 auction after duration is end:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:332:43)
      at processImmediate (node:internal/timers:476:21)

  14) LendPool: Liquidation negative test cases
       User 2 auction consecutively:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-negatives.spec.ts:348:43)
      at processImmediate (node:internal/timers:476:21)

  15) LendPool: Liquidation
       WETH - Auctions the borrow:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-nftx-fail.spec.ts:117:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)

  16) LendPool: Liquidation
       WETH - Can't liquidate on NFTX due to invalid loan state:
     AssertionError: Expected transaction to be reverted with 480, but other exception was thrown: Error: VM Exception while processing transaction: reverted with reason string '321'
  

  17) LendPool: Redeem
       WETH - Auctions the borrow:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate-redeem.spec.ts:114:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)

  18) LendPool: Redeem
       WETH - Redeems the borrow:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '480'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0x7D2386aA0b699eD5C9a8D9caa2efDA648C2418e7","data":"0xea2092f3000000000000000000000000bc4ca0eda7647a8ab7c2061c2e118a18a936f13d0000000000000000000000000000000000000000000000000000000000000065000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoanReserveBorrowAmount(loanId);\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\n   * @param reserve the reserve object\n   **/\n  function updateReserveState(address reserve) external override {\n    DataTypes.ReserveData storage reserveData = _reserves[reserve];\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    reserveData.updateState();\n  }\n\n  /**\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\n   * @param reserve The address of the reserve to be updated\n   **/\n  function updateReserveInterestRates(address reserve) external override {\n    DataTypes.ReserveData storage reserveData = _reserves[reserve];\n    address uTokenAddress = reserveData.uTokenAddress;\n    require(uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    reserveData.updateInterestRates(reserve, uTokenAddress, 0, 0);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":365,"range":[14015,14414]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\nimport {ILockeyHolder} from \"../../interfaces/ILockeyHolder.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */\n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle\n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n\n    vars.repayAmount = params.amount;\n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset,\n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n\n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n\n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n\n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n\n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount redeemed to lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n    address lockeysCollection;\n    address lockeyHolderAddress;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(uToken, vars.borrowAmount);\n\n    // Deposit amount from debt repaid to lending protocol\n    IUToken(uToken).depositReserves(vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(uToken).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeBuyout(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.lockeysCollection = addressesProvider.getAddress(keccak256(\"LOCKEY_COLLECTION\"));\n    vars.lockeyHolderAddress = addressesProvider.getAddress(keccak256(\"LOCKEY_HOLDER\"));\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    uint256 nftPrice = INFTOracleGetter(vars.nftOracle).getNFTPrice(loanData.nftAsset, loanData.nftTokenId);\n\n    // Check for health factor\n    (, , uint256 healthFactor) = GenericLogic.calculateLoanData(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    //Loan must be unhealthy in order to get liquidated\n    require(\n      healthFactor <= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    ValidationLogic.validateBuyout(reserveData, nftData, nftConfig, loanData);\n    require(params.amount > vars.borrowAmount, Errors.LP_AMOUNT_LESS_THAN_DEBT);\n\n    // IF the user is a lockey holder, gets a discount\n    if (IERC721Upgradeable(vars.lockeysCollection).balanceOf(params.initiator) > 0) {\n      require(\n        params.amount >= nftPrice.percentMul(ILockeyHolder(vars.lockeyHolderAddress).getLockeyDiscountPercentage()),\n        Errors.LP_AMOUNT_LESS_THAN_VALUATION\n      );\n    } else {\n      require(params.amount >= nftPrice, Errors.LP_AMOUNT_LESS_THAN_VALUATION);\n    }\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    //lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.amount);\n\n    vars.remainAmount = params.amount - vars.borrowAmount;\n\n    ILendPoolLoan(vars.poolLoan).buyoutLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex,\n      params.amount\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // Deposit amount from debt repaid to lending protocol\n    IUToken(reserveData.uTokenAddress).depositReserves(vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to buyer.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        vars.initiator,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":318,"range":[12772,12860]},"functionType":1},{"type":0,"sourceReference":{"function":"validateRedeem","contract":"ValidationLogic","sourceName":"contracts/libraries/logic/ValidationLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ValidationLogic library\n * @author Unlockd\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveData The reserve state\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveData storage reserveData,\n    uint256 amount,\n    uint256 userBalance,\n    address uToken\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    // Case where there is not enough liquidity to cover user's withdrawal\n    uint256 availableLiquidity = IUToken(uToken).getAvailableLiquidity();\n    require(amount <= availableLiquidity, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeeded;\n    uint256 userCollateralBalance;\n    uint256 userBorrowBalance;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool nftIsActive;\n    bool nftIsFrozen;\n    address loanReserveAsset;\n    address loanBorrower;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param reserveData The reserve state from which the user is borrowing\n   * @param nftData The state of the user for the specific nft\n   */\n  function validateBorrow(\n    DataTypes.ExecuteBorrowParams memory params,\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(params.amount > 0, Errors.VL_INVALID_AMOUNT);\n\n    if (loanId != 0) {\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\n\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n      require(params.asset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\n      require(params.onBehalfOf == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\n    }\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\n      .configuration\n      .getFlags();\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    (vars.nftIsActive, vars.nftIsFrozen) = nftConfig.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    require(\n      (nftConfig.getConfigTimestamp() + ILendPool(address(this)).getTimeframe()) >= block.timestamp,\n      Errors.VL_TIMEFRAME_EXCEEDED\n    );\n\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\n      params.asset,\n      reserveData,\n      params.nftAsset,\n      params.nftTokenId,\n      nftConfig,\n      loanAddress,\n      loanId,\n      reserveOracle,\n      nftOracle\n    );\n\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    //LTV is calculated in percentage\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + params.amount).percentDiv(vars.currentLtv);\n\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserveData The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param borrowAmount The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amountSent,\n    uint256 borrowAmount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\n\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the auction action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The nft data of the underlying nft\n   * @param bidPrice Total variable debt balance of the user\n   **/\n  function validateAuction(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 bidPrice\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateBuyout(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n  }\n\n  /**\n   * @dev Validates a redeem action\n   * @param reserveData The reserve state\n   * @param nftData The nft state\n   */\n  function validateRedeem(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidate(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the liquidation NFTX action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidateMarkets(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev Loan requires to be in `Active` state. The Markets liquidate process is triggered if there has not been any auction\n     * and the auction time has passed. In that case, loan is not in `Auction` nor `Defaulted`,  and needs to be liquidated in a third-party market.\n     */\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates an uToken transfer\n   * @param from The user from which the uTokens are being transferred\n   * @param reserveData The state of the reserve\n   */\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\n    from;\n    reserveData;\n  }\n}\n","line":265,"range":[9935,10779]},"functionType":1},{"type":4,"sourceReference":{"function":"validateDeposit","contract":"ValidationLogic","sourceName":"contracts/libraries/logic/ValidationLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ValidationLogic library\n * @author Unlockd\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveData The reserve state\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveData storage reserveData,\n    uint256 amount,\n    uint256 userBalance,\n    address uToken\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    // Case where there is not enough liquidity to cover user's withdrawal\n    uint256 availableLiquidity = IUToken(uToken).getAvailableLiquidity();\n    require(amount <= availableLiquidity, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeeded;\n    uint256 userCollateralBalance;\n    uint256 userBorrowBalance;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool nftIsActive;\n    bool nftIsFrozen;\n    address loanReserveAsset;\n    address loanBorrower;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param reserveData The reserve state from which the user is borrowing\n   * @param nftData The state of the user for the specific nft\n   */\n  function validateBorrow(\n    DataTypes.ExecuteBorrowParams memory params,\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(params.amount > 0, Errors.VL_INVALID_AMOUNT);\n\n    if (loanId != 0) {\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\n\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n      require(params.asset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\n      require(params.onBehalfOf == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\n    }\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\n      .configuration\n      .getFlags();\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    (vars.nftIsActive, vars.nftIsFrozen) = nftConfig.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    require(\n      (nftConfig.getConfigTimestamp() + ILendPool(address(this)).getTimeframe()) >= block.timestamp,\n      Errors.VL_TIMEFRAME_EXCEEDED\n    );\n\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\n      params.asset,\n      reserveData,\n      params.nftAsset,\n      params.nftTokenId,\n      nftConfig,\n      loanAddress,\n      loanId,\n      reserveOracle,\n      nftOracle\n    );\n\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    //LTV is calculated in percentage\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + params.amount).percentDiv(vars.currentLtv);\n\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserveData The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param borrowAmount The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amountSent,\n    uint256 borrowAmount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\n\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the auction action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The nft data of the underlying nft\n   * @param bidPrice Total variable debt balance of the user\n   **/\n  function validateAuction(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 bidPrice\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateBuyout(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n  }\n\n  /**\n   * @dev Validates a redeem action\n   * @param reserveData The reserve state\n   * @param nftData The nft state\n   */\n  function validateRedeem(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidate(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the liquidation NFTX action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidateMarkets(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev Loan requires to be in `Active` state. The Markets liquidate process is triggered if there has not been any auction\n     * and the auction time has passed. In that case, loan is not in `Auction` nor `Defaulted`,  and needs to be liquidated in a third-party market.\n     */\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates an uToken transfer\n   * @param from The user from which the uTokens are being transferred\n   * @param reserveData The state of the reserve\n   */\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\n    from;\n    reserveData;\n  }\n}\n","line":41,"range":[1795,1841]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,52,56,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033438300000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)

  19) LendPool: Liquidation
       WETH - Auctions the borrow:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/liquidate.spec.ts:118:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)

  20) LendPool: Liquidation
       WETH - Liquidates the borrow:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '480'", method="estimateGas", transaction={"from":"0xA2874be6Acdc314dd055f6869a2dBdF62c983436","to":"0x7D2386aA0b699eD5C9a8D9caa2efDA648C2418e7","data":"0x0710285c000000000000000000000000bc4ca0eda7647a8ab7c2061c2e118a18a936f13d00000000000000000000000000000000000000000000000000000000000000650000000000000000000000000000000000000000000000000de0b6b3a7640000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"liquidate","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoanReserveBorrowAmount(loanId);\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\n   * @param reserve the reserve object\n   **/\n  function updateReserveState(address reserve) external override {\n    DataTypes.ReserveData storage reserveData = _reserves[reserve];\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    reserveData.updateState();\n  }\n\n  /**\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\n   * @param reserve The address of the reserve to be updated\n   **/\n  function updateReserveInterestRates(address reserve) external override {\n    DataTypes.ReserveData storage reserveData = _reserves[reserve];\n    address uTokenAddress = reserveData.uTokenAddress;\n    require(uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    reserveData.updateInterestRates(reserve, uTokenAddress, 0, 0);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":395,"range":[14954,15284]},"functionType":1},{"type":0,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\nimport {ILockeyHolder} from \"../../interfaces/ILockeyHolder.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */\n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle\n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n\n    vars.repayAmount = params.amount;\n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset,\n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n\n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n\n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n\n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n\n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount redeemed to lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n    address lockeysCollection;\n    address lockeyHolderAddress;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(uToken, vars.borrowAmount);\n\n    // Deposit amount from debt repaid to lending protocol\n    IUToken(uToken).depositReserves(vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(uToken).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeBuyout(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.lockeysCollection = addressesProvider.getAddress(keccak256(\"LOCKEY_COLLECTION\"));\n    vars.lockeyHolderAddress = addressesProvider.getAddress(keccak256(\"LOCKEY_HOLDER\"));\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    uint256 nftPrice = INFTOracleGetter(vars.nftOracle).getNFTPrice(loanData.nftAsset, loanData.nftTokenId);\n\n    // Check for health factor\n    (, , uint256 healthFactor) = GenericLogic.calculateLoanData(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    //Loan must be unhealthy in order to get liquidated\n    require(\n      healthFactor <= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    ValidationLogic.validateBuyout(reserveData, nftData, nftConfig, loanData);\n    require(params.amount > vars.borrowAmount, Errors.LP_AMOUNT_LESS_THAN_DEBT);\n\n    // IF the user is a lockey holder, gets a discount\n    if (IERC721Upgradeable(vars.lockeysCollection).balanceOf(params.initiator) > 0) {\n      require(\n        params.amount >= nftPrice.percentMul(ILockeyHolder(vars.lockeyHolderAddress).getLockeyDiscountPercentage()),\n        Errors.LP_AMOUNT_LESS_THAN_VALUATION\n      );\n    } else {\n      require(params.amount >= nftPrice, Errors.LP_AMOUNT_LESS_THAN_VALUATION);\n    }\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    //lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.amount);\n\n    vars.remainAmount = params.amount - vars.borrowAmount;\n\n    ILendPoolLoan(vars.poolLoan).buyoutLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex,\n      params.amount\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // Deposit amount from debt repaid to lending protocol\n    IUToken(reserveData.uTokenAddress).depositReserves(vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to buyer.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        vars.initiator,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":473,"range":[18374,18450]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\nimport {ILockeyHolder} from \"../../interfaces/ILockeyHolder.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */\n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle\n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n\n    vars.repayAmount = params.amount;\n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset,\n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n\n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n\n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n\n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n\n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount redeemed to lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n    address lockeysCollection;\n    address lockeyHolderAddress;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(uToken, vars.borrowAmount);\n\n    // Deposit amount from debt repaid to lending protocol\n    IUToken(uToken).depositReserves(vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(uToken).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeBuyout(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.lockeysCollection = addressesProvider.getAddress(keccak256(\"LOCKEY_COLLECTION\"));\n    vars.lockeyHolderAddress = addressesProvider.getAddress(keccak256(\"LOCKEY_HOLDER\"));\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    uint256 nftPrice = INFTOracleGetter(vars.nftOracle).getNFTPrice(loanData.nftAsset, loanData.nftTokenId);\n\n    // Check for health factor\n    (, , uint256 healthFactor) = GenericLogic.calculateLoanData(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    //Loan must be unhealthy in order to get liquidated\n    require(\n      healthFactor <= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    ValidationLogic.validateBuyout(reserveData, nftData, nftConfig, loanData);\n    require(params.amount > vars.borrowAmount, Errors.LP_AMOUNT_LESS_THAN_DEBT);\n\n    // IF the user is a lockey holder, gets a discount\n    if (IERC721Upgradeable(vars.lockeysCollection).balanceOf(params.initiator) > 0) {\n      require(\n        params.amount >= nftPrice.percentMul(ILockeyHolder(vars.lockeyHolderAddress).getLockeyDiscountPercentage()),\n        Errors.LP_AMOUNT_LESS_THAN_VALUATION\n      );\n    } else {\n      require(params.amount >= nftPrice, Errors.LP_AMOUNT_LESS_THAN_VALUATION);\n    }\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    //lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.amount);\n\n    vars.remainAmount = params.amount - vars.borrowAmount;\n\n    ILendPoolLoan(vars.poolLoan).buyoutLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex,\n      params.amount\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // Deposit amount from debt repaid to lending protocol\n    IUToken(reserveData.uTokenAddress).depositReserves(vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to buyer.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        vars.initiator,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":465,"range":[17947,18013]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,52,56,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033438300000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)

  21) PunkGateway-Liquidate
       Borrow ETH and liquidate it:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/punk-liquidate.spec.ts:396:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)

  22) PunkGateway-Liquidate
       Borrow ETH and redeem it:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/punk-liquidate.spec.ts:615:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)

  23) WETHGateway - Liquidate
       Borrow ETH and Liquidate it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '301'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0xD0330Ac56A182aC22864D67D6f6E76aD628c9b2e","data":"0x9c748eff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bc4ca0eda7647a8ab7c2061c2e118a18a936f13d000000000000000000000000000000000000000000000000000000000000008d000000000000000000000000bec583e93262ad87b08cffbd4d8d97fc80e191ac0000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrowETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IDebtMarket} from \"../interfaces/IDebtMarket.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n  struct GuardVars {\n    ILendPoolLoan cachedPoolLoan;\n    uint256 loanId;\n    DataTypes.LoanData loan;\n  }\n  modifier loanReserveShouldBeWETH(address nftAsset, uint256 tokenId) {\n    GuardVars memory vars;\n    vars.cachedPoolLoan = _getLendPoolLoan();\n\n    vars.loanId = vars.cachedPoolLoan.getCollateralLoanId(nftAsset, tokenId);\n    require(vars.loanId > 0, \"collateral loan id not exist\");\n\n    vars.loan = vars.cachedPoolLoan.getLoan(vars.loanId);\n    require(vars.loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    _;\n  }\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal loanReserveShouldBeWETH(nftAsset, nftTokenId) returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = _getLendPool().repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf\n  ) external payable override nonReentrant loanReserveShouldBeWETH(nftAsset, nftTokenId) {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant loanReserveShouldBeWETH(nftAsset, nftTokenId) returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override nonReentrant loanReserveShouldBeWETH(nftAsset, nftTokenId) returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  function bidDebtETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf\n  ) external payable override nonReentrant loanReserveShouldBeWETH(nftAsset, nftTokenId) {\n    bytes32 DEBT_MARKET = keccak256(\"DEBT_MARKET\");\n\n    IDebtMarket debtMarketAddress = IDebtMarket(_addressProvider.getAddress(DEBT_MARKET));\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    if (WETH.allowance(address(this), address(debtMarketAddress)) == 0) {\n      WETH.approve(address(debtMarketAddress), type(uint256).max);\n    }\n    debtMarketAddress.bid(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function buyDebtETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf\n  ) external payable override nonReentrant loanReserveShouldBeWETH(nftAsset, nftTokenId) {\n    bytes32 DEBT_MARKET = keccak256(\"DEBT_MARKET\");\n\n    IDebtMarket debtMarketAddress = IDebtMarket(_addressProvider.getAddress(DEBT_MARKET));\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    if (WETH.allowance(address(this), address(debtMarketAddress)) == 0) {\n      WETH.approve(address(debtMarketAddress), type(uint256).max);\n    }\n\n    debtMarketAddress.buy(nftAsset, nftTokenId, onBehalfOf, msg.value);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":200,"range":[6661,6749]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrow","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoanReserveBorrowAmount(loanId);\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\n   * @param reserve the reserve object\n   **/\n  function updateReserveState(address reserve) external override {\n    DataTypes.ReserveData storage reserveData = _reserves[reserve];\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    reserveData.updateState();\n  }\n\n  /**\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\n   * @param reserve The address of the reserve to be updated\n   **/\n  function updateReserveInterestRates(address reserve) external override {\n    DataTypes.ReserveData storage reserveData = _reserves[reserve];\n    address uTokenAddress = reserveData.uTokenAddress;\n    require(uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    reserveData.updateInterestRates(reserve, uTokenAddress, 0, 0);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":244,"range":[10121,10480]},"functionType":1},{"type":0,"sourceReference":{"function":"executeBorrow","contract":"BorrowLogic","sourceName":"contracts/libraries/logic/BorrowLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Unlockd\n * @notice Implements the logic to borrow feature\n */\nlibrary BorrowLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on borrow() when loan needs to be opened\n   * @param user The address of the user initiating the borrow(), receiving the funds\n   * @param reserve The address of the underlying asset being borrowed\n   * @param amount The amount borrowed out\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the loan\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address indexed onBehalfOf,\n    uint256 borrowRate,\n    uint256 loanId,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param user The address of the user initiating the repay(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param amount The amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Repay(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct ExecuteBorrowLocalVars {\n    address initiator;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 loanId;\n    address reserveOracle;\n    address nftOracle;\n    address loanAddress;\n    uint256 totalSupply;\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) external {\n    _borrow(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `_borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function _borrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) internal {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    ExecuteBorrowLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n    // Convert asset amount to ETH\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n\n    ValidationLogic.validateBorrow(\n      params,\n      reserveData,\n      nftData,\n      nftConfig,\n      vars.loanAddress,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    require(IUToken(uToken).getAvailableLiquidity() >= params.amount, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n\n    if (vars.loanId == 0) {\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\n\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\n        vars.initiator,\n        params.onBehalfOf,\n        params.nftAsset,\n        params.nftTokenId,\n        nftData.uNftAddress,\n        params.asset,\n        params.amount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.loanAddress).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        params.amount,\n        0,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.initiator,\n      params.onBehalfOf,\n      params.amount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(params.asset, uToken, 0, params.amount);\n\n    // Withdraw amount from external lending protocol\n    uint256 value = IUToken(uToken).withdrawReserves(params.amount);\n\n    // Transfer underlying to user\n    IUToken(uToken).transferUnderlyingTo(vars.initiator, value);\n\n    emit Borrow(\n      vars.initiator,\n      params.asset,\n      value,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      reserveData.currentVariableBorrowRate,\n      vars.loanId,\n      params.referralCode\n    );\n  }\n\n  struct RepayLocalVars {\n    address initiator;\n    address poolLoan;\n    address onBehalfOf;\n    uint256 loanId;\n    bool isUpdate;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function executeRepay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256, bool) {\n    return _repay(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function _repay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) internal returns (uint256, bool) {\n    RepayLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\n\n    ValidationLogic.validateRepay(reserveData, nftData, nftConfig, loanData, params.amount, vars.borrowAmount);\n\n    vars.repayAmount = vars.borrowAmount;\n    vars.isUpdate = false;\n    if (params.amount < vars.repayAmount) {\n      vars.isUpdate = true;\n      vars.repayAmount = params.amount;\n    }\n\n    if (vars.isUpdate) {\n      ILendPoolLoan(vars.poolLoan).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        0,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.poolLoan).repayLoan(\n        vars.initiator,\n        vars.loanId,\n        nftData.uNftAddress,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount repaid to external lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    // transfer erc721 to borrower\n    if (!vars.isUpdate) {\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\n    }\n\n    emit Repay(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount, !vars.isUpdate);\n  }\n}\n","line":108,"range":[4269,4339]},"functionType":1},{"type":0,"sourceReference":{"function":"_borrow","contract":"BorrowLogic","sourceName":"contracts/libraries/logic/BorrowLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Unlockd\n * @notice Implements the logic to borrow feature\n */\nlibrary BorrowLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on borrow() when loan needs to be opened\n   * @param user The address of the user initiating the borrow(), receiving the funds\n   * @param reserve The address of the underlying asset being borrowed\n   * @param amount The amount borrowed out\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the loan\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address indexed onBehalfOf,\n    uint256 borrowRate,\n    uint256 loanId,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param user The address of the user initiating the repay(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param amount The amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Repay(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct ExecuteBorrowLocalVars {\n    address initiator;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 loanId;\n    address reserveOracle;\n    address nftOracle;\n    address loanAddress;\n    uint256 totalSupply;\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) external {\n    _borrow(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `_borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function _borrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) internal {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    ExecuteBorrowLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n    // Convert asset amount to ETH\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n\n    ValidationLogic.validateBorrow(\n      params,\n      reserveData,\n      nftData,\n      nftConfig,\n      vars.loanAddress,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    require(IUToken(uToken).getAvailableLiquidity() >= params.amount, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n\n    if (vars.loanId == 0) {\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\n\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\n        vars.initiator,\n        params.onBehalfOf,\n        params.nftAsset,\n        params.nftTokenId,\n        nftData.uNftAddress,\n        params.asset,\n        params.amount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.loanAddress).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        params.amount,\n        0,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.initiator,\n      params.onBehalfOf,\n      params.amount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(params.asset, uToken, 0, params.amount);\n\n    // Withdraw amount from external lending protocol\n    uint256 value = IUToken(uToken).withdrawReserves(params.amount);\n\n    // Transfer underlying to user\n    IUToken(uToken).transferUnderlyingTo(vars.initiator, value);\n\n    emit Borrow(\n      vars.initiator,\n      params.asset,\n      value,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      reserveData.currentVariableBorrowRate,\n      vars.loanId,\n      params.referralCode\n    );\n  }\n\n  struct RepayLocalVars {\n    address initiator;\n    address poolLoan;\n    address onBehalfOf;\n    uint256 loanId;\n    bool isUpdate;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function executeRepay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256, bool) {\n    return _repay(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function _repay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) internal returns (uint256, bool) {\n    RepayLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\n\n    ValidationLogic.validateRepay(reserveData, nftData, nftConfig, loanData, params.amount, vars.borrowAmount);\n\n    vars.repayAmount = vars.borrowAmount;\n    vars.isUpdate = false;\n    if (params.amount < vars.repayAmount) {\n      vars.isUpdate = true;\n      vars.repayAmount = params.amount;\n    }\n\n    if (vars.isUpdate) {\n      ILendPoolLoan(vars.poolLoan).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        0,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.poolLoan).repayLoan(\n        vars.initiator,\n        vars.loanId,\n        nftData.uNftAddress,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount repaid to external lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    // transfer erc721 to borrower\n    if (!vars.isUpdate) {\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\n    }\n\n    emit Repay(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount, !vars.isUpdate);\n  }\n}\n","line":144,"range":[5950,6142]},"functionType":1},{"type":0,"sourceReference":{"function":"validateBorrow","contract":"ValidationLogic","sourceName":"contracts/libraries/logic/ValidationLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ValidationLogic library\n * @author Unlockd\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveData The reserve state\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveData storage reserveData,\n    uint256 amount,\n    uint256 userBalance,\n    address uToken\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    // Case where there is not enough liquidity to cover user's withdrawal\n    uint256 availableLiquidity = IUToken(uToken).getAvailableLiquidity();\n    require(amount <= availableLiquidity, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeeded;\n    uint256 userCollateralBalance;\n    uint256 userBorrowBalance;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool nftIsActive;\n    bool nftIsFrozen;\n    address loanReserveAsset;\n    address loanBorrower;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param reserveData The reserve state from which the user is borrowing\n   * @param nftData The state of the user for the specific nft\n   */\n  function validateBorrow(\n    DataTypes.ExecuteBorrowParams memory params,\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(params.amount > 0, Errors.VL_INVALID_AMOUNT);\n\n    if (loanId != 0) {\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\n\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n      require(params.asset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\n      require(params.onBehalfOf == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\n    }\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\n      .configuration\n      .getFlags();\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    (vars.nftIsActive, vars.nftIsFrozen) = nftConfig.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    require(\n      (nftConfig.getConfigTimestamp() + ILendPool(address(this)).getTimeframe()) >= block.timestamp,\n      Errors.VL_TIMEFRAME_EXCEEDED\n    );\n\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\n      params.asset,\n      reserveData,\n      params.nftAsset,\n      params.nftTokenId,\n      nftConfig,\n      loanAddress,\n      loanId,\n      reserveOracle,\n      nftOracle\n    );\n\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    //LTV is calculated in percentage\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + params.amount).percentDiv(vars.currentLtv);\n\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserveData The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param borrowAmount The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amountSent,\n    uint256 borrowAmount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\n\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the auction action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The nft data of the underlying nft\n   * @param bidPrice Total variable debt balance of the user\n   **/\n  function validateAuction(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 bidPrice\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateBuyout(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n  }\n\n  /**\n   * @dev Validates a redeem action\n   * @param reserveData The reserve state\n   * @param nftData The nft state\n   */\n  function validateRedeem(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidate(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the liquidation NFTX action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidateMarkets(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev Loan requires to be in `Active` state. The Markets liquidate process is triggered if there has not been any auction\n     * and the auction time has passed. In that case, loan is not in `Auction` nor `Defaulted`,  and needs to be liquidated in a third-party market.\n     */\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates an uToken transfer\n   * @param from The user from which the uTokens are being transferred\n   * @param reserveData The state of the reserve\n   */\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\n    from;\n    reserveData;\n  }\n}\n","line":92,"range":[3448,6380]},"functionType":1},{"type":4,"sourceReference":{"function":"validateDeposit","contract":"ValidationLogic","sourceName":"contracts/libraries/logic/ValidationLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ValidationLogic library\n * @author Unlockd\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveData The reserve state\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveData storage reserveData,\n    uint256 amount,\n    uint256 userBalance,\n    address uToken\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    // Case where there is not enough liquidity to cover user's withdrawal\n    uint256 availableLiquidity = IUToken(uToken).getAvailableLiquidity();\n    require(amount <= availableLiquidity, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeeded;\n    uint256 userCollateralBalance;\n    uint256 userBorrowBalance;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool nftIsActive;\n    bool nftIsFrozen;\n    address loanReserveAsset;\n    address loanBorrower;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param reserveData The reserve state from which the user is borrowing\n   * @param nftData The state of the user for the specific nft\n   */\n  function validateBorrow(\n    DataTypes.ExecuteBorrowParams memory params,\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(params.amount > 0, Errors.VL_INVALID_AMOUNT);\n\n    if (loanId != 0) {\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\n\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n      require(params.asset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\n      require(params.onBehalfOf == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\n    }\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\n      .configuration\n      .getFlags();\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    (vars.nftIsActive, vars.nftIsFrozen) = nftConfig.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    require(\n      (nftConfig.getConfigTimestamp() + ILendPool(address(this)).getTimeframe()) >= block.timestamp,\n      Errors.VL_TIMEFRAME_EXCEEDED\n    );\n\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\n      params.asset,\n      reserveData,\n      params.nftAsset,\n      params.nftTokenId,\n      nftConfig,\n      loanAddress,\n      loanId,\n      reserveOracle,\n      nftOracle\n    );\n\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    //LTV is calculated in percentage\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + params.amount).percentDiv(vars.currentLtv);\n\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserveData The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param borrowAmount The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amountSent,\n    uint256 borrowAmount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\n\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the auction action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The nft data of the underlying nft\n   * @param bidPrice Total variable debt balance of the user\n   **/\n  function validateAuction(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 bidPrice\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateBuyout(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n  }\n\n  /**\n   * @dev Validates a redeem action\n   * @param reserveData The reserve state\n   * @param nftData The nft state\n   */\n  function validateRedeem(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidate(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the liquidation NFTX action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidateMarkets(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev Loan requires to be in `Active` state. The Markets liquidate process is triggered if there has not been any auction\n     * and the auction time has passed. In that case, loan is not in `Auction` nor `Defaulted`,  and needs to be liquidated in a third-party market.\n     */\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates an uToken transfer\n   * @param from The user from which the uTokens are being transferred\n   * @param reserveData The state of the reserve\n   */\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\n    from;\n    reserveData;\n  }\n}\n","line":41,"range":[1795,1841]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,51,48,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033330310000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  24) WETHGateway - Liquidate
       Borrow ETH and Redeem it:
     TypeError: pool.getNftLiquidatePrice is not a function
      at Context.<anonymous> (test/weth-liquidate.spec.ts:359:43)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:538:9)
      at processTimers (node:internal/timers:512:7)



