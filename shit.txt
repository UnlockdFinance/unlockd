
> @unlockddao/unlockd-protocol@1.0.2 test
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/*.spec.ts


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/Users/adri/work/unlockd-protocol-v1/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  goerli
  - Provider URL: eth-goerli.g.alchemy.com
  - Network : hardhat
Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 1000000.0 ETH
LendPool Liquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH


Migration started


Deploy Punks Market and Wrapped Punk
*** CryptoPunksMarket ***

Network: hardhat
tx: 0x67afc5b971d207e75f3498c82fc72d142659cf9e5d27e7ea60a251cc160db823
contract address: 0x1864c9342339c36588F7f31d1079690a7003c7a2
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000042103
gas used: 2378109

******

contracts-helpers:registerContractInJsonDb, contractId: CryptoPunksMarket address: 0x1864c9342339c36588F7f31d1079690a7003c7a2 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WrappedPunk ***

Network: hardhat
tx: 0xe728bedb02bee455dab430156f43961f57d5a9fe0ff3ae48a1aaf1095051e0c2
contract address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000038851
gas used: 1992593

******

contracts-helpers:registerContractInJsonDb, contractId: WrappedPunk address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy proxy admin
*** UnlockdProxyAdminPool ***

Network: hardhat
tx: 0xd8fe84a47275e5c108cc974c34fe7dc1fced7b74c87287816c1b5f4cc057cacf
contract address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000031139
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminPool address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
ProxyAdminPool Address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** UnlockdProxyAdminFund ***

Network: hardhat
tx: 0xf9687bddd351d5744b1d8accd8f7e7d49ccc45a61e6ff48c5df0902db09aeeeb
contract address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000027541
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminFund address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProxyAdminFund Address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy address provider
- Deploying new Address Provider:
*** LendPoolAddressesProvider ***

Network: hardhat
tx: 0x2d2851ab2b937bf38bd23645e2f23fb9b278acd1041b1ddc3934ee1eef6412aa
contract address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000024359
gas used: 2978496

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProvider address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
- Deploying a new Address Provider Registry:
*** LendPoolAddressesProviderRegistry ***

Network: hardhat
tx: 0xf350605065cb33d0d48da55a91d75c05e9a80658f9b818c9861c89172e257d5f
contract address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000022772
gas used: 502283

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProviderRegistry address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deployed Registry Address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Added LendPoolAddressesProvider with address "0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977" to registry located at 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
LSSVM ROUTER ADDRESS: 0x25b4EfC43c9dCAe134233CD577fFca7CfAd6748F
Pool Admin 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Emergency Admin 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3
LendPool Liquidator 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
SushiSwap Router 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506
NFTXVault Factory 0xe01Cf5099e700c282A56E815ABd0C4948298Afae


Deploy Incentives Controller
Deploying new Incentives Controller Implementation...
*** MockIncentivesController ***

Network: hardhat
tx: 0x13f2a4a181bd6e42bcfbed55b2948c24f6cbe8df18323014b8f9d5ef61219b07
contract address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000006991
gas used: 142669

******

contracts-helpers:registerContractInJsonDb, contractId: MockIncentivesController address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy UNFT Registry
Deploying new UnftRegistry implementation...
*** UNFT ***

Network: hardhat
tx: 0xdb1c1b9d5a05012416ff674516c86b3a9992ab294ea4362b5480c3c091d4c529
contract address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000005377
gas used: 1503057

******

contracts-helpers:registerContractInJsonDb, contractId: UNFT address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:insertContractAddressInDb, id: UNFTRegistryImpl address 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
*** UNFTRegistry ***

Network: hardhat
tx: 0x6538e206c72d4582502561e69be0633c125630beb0c077735834f3dc46f1d292
contract address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004868
gas used: 2441516

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Invalid Proxy Admin address in pool config. Trying to fetch from deployed contracts...
*** UNFTRegistry ***

Network: hardhat
tx: 0x7effe466cacfb2236a2e3e51c11335370dbbfc2af0edbb3b6b9d45568b2b4ed2
contract address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004499
gas used: 740488

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UNFT created successfully for token WPUNKS with address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UNFT Token: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 0xfC856EeEaE446258cc8f17C5421c507115dc912d
UNFT created successfully for token BAYC with address 0x9278420Bf7548970799c56ef9A0B081862515330
UNFT Token: 0x9278420Bf7548970799c56ef9A0B081862515330 0x06cF13D8aD87307d50540223D3A08f63CDF8A211


Deploy lend pool
Setting UNFTRegistry to address provider...
Setting IncentivesController to address provider...
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x50be9fb2adfb68f71fc41542a9b63367140c7fdc4e0700b160196af1c998d844
contract address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000002131
gas used: 84290

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ReserveLogic ***

Network: hardhat
tx: 0xbcd5f851e240b1ad9cd74d6b2a4d270e9fb137d96bbb9dd901777352fe2f8f4d
contract address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001869
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** NftLogic ***

Network: hardhat
tx: 0x22eae7d101e8f18127afd75978147bfd36b35bb70eec9701f4638531ca9a8a3c
contract address: 0x5c769753F192449c3c6AeC7BF2145928eb261699
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001642
gas used: 141010

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0x5c769753F192449c3c6AeC7BF2145928eb261699 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ValidationLogic ***

Network: hardhat
tx: 0xf93491a2191e77cd1119ad51545680cace92888274d5dd88acc80c3a9a2c322b
contract address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001442
gas used: 1530121

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** SupplyLogic ***

Network: hardhat
tx: 0x52ad6561a6644188456903398271de7a8fe8bd15385e5f03e983f19d5762546f
contract address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001307
gas used: 1184796

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** BorrowLogic ***

Network: hardhat
tx: 0xbae4c097cf71fcf952da0b99faaed50b2d49dc0349e64f5fc528cc5b1d560fe3
contract address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001175
gas used: 2066318

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateLogic ***

Network: hardhat
tx: 0x19aa1b5d2c35376888c538cef2430cb61ff40afb6d018b24d72fcdab79855557
contract address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001077
gas used: 3939677

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0x9e958ebcd47d6512f95c1c251dbee57e46d279daa06c9513e16fe3a454ea1da5
contract address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001028
gas used: 2995275

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ConfiguratorLogic ***

Network: hardhat
tx: 0xc36e97dfe58f20df08877fdcb0056b447b821e82de1d6dd94b24d195dffc2f4e
contract address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000962
gas used: 1970094

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
*** LendPool ***

Network: hardhat
tx: 0x4535c1451188553d96b3f7cc8d52165f3871010795b009ddaeda505d8d121512
contract address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000880
gas used: 5095759

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool implementation with address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
contracts-helpers:insertContractAddressInDb, id: LendPool address 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
*** LendPoolLoan ***

Network: hardhat
tx: 0x3c47420198582059161a31da1bd22aba04c83d5a25bd14063abd469a9dbccd6d
contract address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000766
gas used: 3262299

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool loan implementation with address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0xa85e569EF873Cec2a82012C08057397F93aed686
*** LendPoolConfigurator ***

Network: hardhat
tx: 0xf3a5025fe878cf72b1c1d6f5cbd7557dc5cf797dd039fb8aea8a23d3e6adcdbf
contract address: 0xa85e569EF873Cec2a82012C08057397F93aed686
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000641
gas used: 5346518

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0xa85e569EF873Cec2a82012C08057397F93aed686 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool configurator implementation with address: 0xa85e569EF873Cec2a82012C08057397F93aed686
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
Deploying UToken implementation UToken
*** UToken ***

Network: hardhat
tx: 0xec8ad84bf15f5095ffa6a770f5366fd1fadce3749becc457927d23427928a801
contract address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000491
gas used: 1983088

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** DebtToken ***

Network: hardhat
tx: 0x3d437fb6461d97e7afeec5374a3cedbf3ba5dc2daeef669f947fd1ae80660c8c
contract address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000450
gas used: 1366344

******

contracts-helpers:registerContractInJsonDb, contractId: DebtToken address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy reserve oracle
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0xd81cfDb25C4a27795c17A893F7813590614f2A90
*** ReserveOracle ***

Network: hardhat
tx: 0x204cccc22c382758535e6c1abb54ff8547f3d05b9e04d52a7a173d65301c034b
contract address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000313
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x3b00956f251d62ec5ecb8e9bc89e6a7ccf60812ef29dee172f8fd61461ca4889
contract address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000282
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Reserve Oracle: proxy 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD, implementation 0xd81cfDb25C4a27795c17A893F7813590614f2A90
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0x9690b60248da3cd6e53f0c4afa423109a5429c35ba3b3cb34ab1994eca1ec904
contract address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000194
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xab9163c6b945317e85eed4498822eb591a6c4bda662f15bb3e922e95cccd3694
contract address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000154
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy nft oracle
contracts-helpers:insertContractAddressInDb, id: NFTOracleImpl address 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
*** NFTOracle ***

Network: hardhat
tx: 0xb060ae12c18612015c12c110ba4aba551d73c1b821d4e5f13d8c350d41304ce5
contract address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000137
gas used: 1047527

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new nft oracle proxy & implementation...
*** NFTOracle ***

Network: hardhat
tx: 0xd3266ca8a44039d60bb99540199f42180a40e850a307ef3c3effa2eafd8ac0f3
contract address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000123
gas used: 712030

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
NFT Oracle: proxy 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482, implementation 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0x2e8ea41966be8b0994b0a80df72e371148f1b831feacaf460bb584c575f03227
contract address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000066
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize lend pool
Init & Config Reserve assets
RESERVES: WETH,[object Object],DAI,[object Object],USDC,[object Object]
*** InterestRate ***

Network: hardhat
tx: 0xf513aa90999a147e235e0cc4b29e1e86c02f7dce61616e086bb7db31a6f8c9b2
contract address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000053
gas used: 616243

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
*** InterestRate ***

Network: hardhat
tx: 0xbc625206726bbac5dc3ac44b3a05df3176a0722250728f789e2f4533305080da
contract address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000048
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableTwo address 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
*** InterestRate ***

Network: hardhat
tx: 0xb7cd213fb503d54c1764b0f9072cab7e410bbee2bc50fa5ae2f14bd83df974d8
contract address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000043
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableThree address 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
- Reserves initialization in 3 txs
  - Reserve ready for: WETH 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
    * gasUsed 1631536
  - Reserve ready for: DAI 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
    * gasUsed 1616376
  - Reserve ready for: USDC 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
    * gasUsed 1616436
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure Reserves
  - Params for WETH: 3000 true
  - Params for DAI: 3000 true
  - Params for USDC: 3000 true
- Configure reserves in 1 txs
  - batchConfigReserve for: WETH, DAI, USDC
Init & Config NFT assets
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- NFTs initialization in 2 txs
  - NFT ready for: WPUNKS 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
    * gasUsed 256916
  - NFT ready for: BAYC 0x9278420Bf7548970799c56ef9A0B081862515330
    * gasUsed 241624
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure NFTs
  - Params for WPUNKS: 4000 9000 500 24 24 500 5000 2000 10000 9999
  - Params for BAYC: 4000 9000 500 24 24 500 5000 2000 10000 9999
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- Configure NFTs in 4 txs
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC


Deploy WETH Gateway
contracts-helpers:insertContractAddressInDb, id: WETHGatewayImpl address 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
*** WETHGateway ***

Network: hardhat
tx: 0x0e0d66bf5cfc006340d5cd7606fd834b2f71e5f4f9b58581a4e9130af1a70692
contract address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 2420738

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WETHGateway ***

Network: hardhat
tx: 0x6d03cbac55cae78ab06141f97990448af35b27a6542ffa3fb3b14d4858d4bdd2
contract address: 0x51bda59320165617F7209a38D08b11ccefF58F1a
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 745667

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x51bda59320165617F7209a38D08b11ccefF58F1a deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy PUNK Gateway
wethGateWay.address 0x51bda59320165617F7209a38D08b11ccefF58F1a
CryptoPunksMarket.address 0x1864c9342339c36588F7f31d1079690a7003c7a2
WPUNKS.address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
contracts-helpers:insertContractAddressInDb, id: PunkGatewayImpl address 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
*** PunkGateway ***

Network: hardhat
tx: 0xeb14ee86a92c1b32de1bf47652dbe2c7baf42187bae35ff683165b7f1f4c391d
contract address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 3304310

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new PunkGateway proxy & implementation...
*** PunkGateway ***

Network: hardhat
tx: 0xe497468701478e9cb6329a257808193d7df117faab927e83f8c131c646f75b00
contract address: 0xb16101f4b859580B810b683264102c49e12d0732
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 998847

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xb16101f4b859580B810b683264102c49e12d0732 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize gateway
WETHGateway: authorizeLendPoolNFT: [
  '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
  '0x9278420Bf7548970799c56ef9A0B081862515330'
]
PunkGateway: authorizeLendPoolERC20: [
  '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6',
  '0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36',
  '0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557'
]


Deploy data provider
*** WalletBalanceProvider ***

Network: hardhat
tx: 0xf84aea80d4991194695f64a52794c3930c48ad30a7e270d22ec0952d0d430bd4
contract address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 1251342

******

contracts-helpers:registerContractInJsonDb, contractId: WalletBalanceProvider address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
WalletBalancerProvider deployed at: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0xff36285743a6aea6935ac2fe7a7537ad09ea118b87d92e332d65323b00eb4a49
contract address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 2888605

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProtocolDataProvider deployed at: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
*** UIPoolDataProvider ***

Network: hardhat
tx: 0x1f4938a06a35a4840f691ec5197dbcd79272757ead4de68ad62954be068dc89a
contract address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 3116123

******

contracts-helpers:registerContractInJsonDb, contractId: UIPoolDataProvider address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UiPoolDataProvider deployed at: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 47
CryptoPunksMarket: 0x1864c9342339c36588F7f31d1079690a7003c7a2
WrappedPunk: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UnlockdProxyAdminPool: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
UnlockdProxyAdminFund: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
LendPoolAddressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
LendPoolAddressesProviderRegistry: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
MockIncentivesController: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
UnlockdProxyAdminTest: 0x8b89F971cA1A5dE1B7df7f554a3024eE84FeeB05
UNFT: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
UNFTRegistryImpl: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
UNFTRegistry: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
GenericLogic: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
ReserveLogic: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
NftLogic: 0x5c769753F192449c3c6AeC7BF2145928eb261699
ValidationLogic: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
SupplyLogic: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
BorrowLogic: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
LiquidateLogic: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
LiquidateMarketsLogic: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
ConfiguratorLogic: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
LendPoolImpl: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
LendPool: 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
LendPoolLoanImpl: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
LendPoolLoan: 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
LendPoolConfiguratorImpl: 0xa85e569EF873Cec2a82012C08057397F93aed686
LendPoolConfigurator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
UToken: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
DebtToken: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
ReserveOracleImpl: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
ReserveOracle: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
MockReserveOracle: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
MockChainlinkOracle: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
NFTOracleImpl: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
NFTOracle: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
MockNFTOracle: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
InterestRate: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
rateStrategyWETH: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
rateStrategyStableTwo: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
rateStrategyStableThree: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
WETHGatewayImpl: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
WETHGateway: 0x51bda59320165617F7209a38D08b11ccefF58F1a
PunkGatewayImpl: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
PunkGateway: 0xb16101f4b859580B810b683264102c49e12d0732
WalletBalanceProvider: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
UnlockdProtocolDataProvider: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
UIPoolDataProvider: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
SelfdestructTransferMock: 0xC8bcB2Fd3EA4D38BC62663Cf782805724eFa6Bb0 

Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.91669127871942287
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.91669127871942287
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 999999.999817306910258813
LendPoolLiquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.91669127871942287
-> Initialize make suite...
uDai 0xa6388056eCA8e9546E68E58A17EF2D00c30B300E
uUSDC 0x1e217a095DbF898A732d8419aBBedf8b7df3AD8b
uWETH 0xf1b719001AccaC7666C8c987F4e3acBAeF6E1C45
daiAdd 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
usdcAdd 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
wethAdd 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
allUNftTokens [
  [
    'WPUNKS',
    '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    'UBoundWPUNKS',
    '0xfC856EeEaE446258cc8f17C5421c507115dc912d',
    nftSymbol: 'WPUNKS',
    nftAddress: '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    uNftSymbol: 'UBoundWPUNKS',
    uNftAddress: '0xfC856EeEaE446258cc8f17C5421c507115dc912d'
  ],
  [
    'BAYC',
    '0x9278420Bf7548970799c56ef9A0B081862515330',
    'UBoundBAYC',
    '0x06cF13D8aD87307d50540223D3A08f63CDF8A211',
    nftSymbol: 'BAYC',
    nftAddress: '0x9278420Bf7548970799c56ef9A0B081862515330',
    uNftSymbol: 'UBoundBAYC',
    uNftAddress: '0x06cF13D8aD87307d50540223D3A08f63CDF8A211'
  ]
]
0x9278420Bf7548970799c56ef9A0B081862515330

***************
Setup and snapshot finished
***************

  ReserveOracle
    âœ“ ReserveOracle: Add Aggregator
    âœ“ ReserveOracle: Remove Aggregator
    âœ“ ReserveOracle: get latest price
    âœ“ ReserveOracle: get eth price
    âœ“ ReserveOracle: get latest timestamp
    ReserveOracle-TWAP
      âœ“ twap price
      âœ“ asking interval more than asset has
      âœ“ asking interval less than asset has
      âœ“ given variant price period
      âœ“ latest price update time is earlier than the request, return the latest price
      âœ“ get 0 while interval is zero

  LendPoolAddressesProvider
    âœ“ Test the accessibility of the LendPoolAddressesProvider
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0xc32B56a82144E29725978E8e90c96aA015B87b93
*** LendPool ***

Network: hardhat
tx: 0x78208dc2ecb5c354cca3ed9ae0a5fd34e2e977366712e3a2b609c860bef11b99
contract address: 0xc32B56a82144E29725978E8e90c96aA015B87b93
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 5095759

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0xc32B56a82144E29725978E8e90c96aA015B87b93 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    âœ“ Tests adding a proxied address with `setAddressAsProxy()`
    âœ“ Tests adding a non proxied address with `setAddress()`
    âœ“ Tests specific non-proxied addresses set via `setAddress()`

  LendPool: Borrow/repay test cases
    âœ“ Delegatee try to Borrow WETH to different onBehalf

  LendPool: Borrow negative test cases
    âœ“ Users 0 Deposits 100 WETH and user 1 tries to borrow 0 WETH (revert expected)
    âœ“ User 1 tries to use underpriced NFT as collateral to borrow 100 WETH (revert expected)
    âœ“ User 2 tries to uses user 1 owned NFT as collateral to borrow 10 WETH (revert expected)
    âœ“ Tries to uses NFT which id exceed max limit as collateral to borrow 10 WETH (revert expected)
    âœ“ Users 0 Deposits 100 WETH and user 1 tries to borrow but the timestamp exceeds

  LendPool: Borrow/repay test cases
    âœ“ User 2 deposits 1 WETH and 1000 DAI to account for rounding errors
    âœ“ User 0 deposits 100 WETH, user 1 uses NFT as collateral and borrows 1 WETH
    âœ“ User 1 uses existed collateral and borrows more 100 DAI (revert expected)
    âœ“ User 1 uses existed collateral and borrows more 2 WETH
    âœ“ User 1 tries to borrow more than the rest of the WETH liquidity (revert expected)
    âœ“ User 1 tries to repay 0 WETH (revert expected)
    âœ“ User 1 repays 0.5 WETH, enough to cover a small part of the interest
    âœ“ User 1 repays all WETH borrow after one year
    âœ“ User 0 withdraws the deposited WETH plus interest
    âœ“ User 1 deposits 1 USDC to account for rounding errors
    âœ“ User 1 deposits 1000 USDC, user 3 uses not owned NFT as collateral and borrows 10 USDC
    âœ“ user 2 uses owned NFT as collateral on behalf of user 3 and borrows 10 USDC
    âœ“ user 2 uses existed collateral on behalf of user 3 and borrows more 20 USDC
    âœ“ user 3 repay 10 USDC, a fraction of borrow amount
    âœ“ user 3 repay all USDC, full of borrow amount

  Configurator-NFT
    âœ“ Deactivates the BAYC NFT
    âœ“ Deactivates the BAYC NFT Token
    âœ“ Rectivates the BAYC NFT
    âœ“ Rectivates the BAYC NFT Token
    âœ“ Check the onlyAdmin on deactivateRNft 
    âœ“ Check the onlyAdmin on activateNft 
    âœ“ Freezes the BAYC NFT
    âœ“ Freezes the BAYC NFT Token
    âœ“ Unfreezes the BAYC NFT
    âœ“ Unfreezes the BAYC NFT Token
    âœ“ Check the onlyAdmin on freezeNft 
    âœ“ Check the onlyAdmin on unfreezeNft 
    âœ“ Deactivates the BAYC NFT as collateral
    âœ“ Activates the BAYC NFT as collateral
    âœ“ Check the onlyLtvManager on configureNftAsCollateral 
    âœ“ Deactivates the BAYC NFT as auction
    âœ“ Activates the BAYC NFT as auction
    âœ“ Check the onlyLtvManager on configureNftAsAuction 
    âœ“ Batch Deactivates the BAYC NFT as collateral
    âœ“ Batch Activates the BAYC NFT as collateral
    âœ“ Check the onlyAdmin on batchConfigNft 
    âœ“ Batch Deactivates the BAYC NFT as auction
    âœ“ Batch Activates the BAYC NFT as auction
    âœ“ Reverts when trying to disable the BAYC nft with liquidity on it
    âœ“ Config setMaxNumberOfNfts invalid value
    âœ“ Config setMaxNumberOfNfts invalid value overflowing
    âœ“ Check the onlyAdmin on setMaxNumberOfNfts 
    âœ“ Config the timeFrame for an X amount of time
    âœ“ Check if the config timestamp is correct
    âœ“ Check if general configurations are correct
    âœ“ Check the onlyAdmin on set treasury to new utoken
    âœ“ Check the zero check on set treasury to new utoken
    âœ“ Check the address is properly updated in WETH uToken
    âœ“ Check the zero check on set rescuer
    âœ“ (LendPool): Check the only pool admin in safe health factor 
    âœ“ (LendPool): Check invalid 0 value in safe health factor 
    âœ“ (LendPool): Check correct value in safe health factor 

  Configurator-Reserve
    âœ“ Reverts trying to set an invalid reserve factor
    âœ“ Deactivates the ETH reserve
    âœ“ Rectivates the ETH reserve
    âœ“ Check the onlyAdmin on deactivateReserve 
    âœ“ Check the onlyAdmin on activateReserve 
    âœ“ Freezes the ETH reserve
    âœ“ Unfreezes the ETH reserve
    âœ“ Check the onlyAdmin on freezeReserve 
    âœ“ Check the onlyAdmin on unfreezeReserve 
    âœ“ Deactivates the ETH reserve for borrowing
    âœ“ Activates the ETH reserve for borrowing
    âœ“ Check the onlyAdmin on disableBorrowingOnReserve 
    âœ“ Check the onlyAdmin on enableBorrowingOnReserve 
    âœ“ Changes the reserve factor of WETH
    âœ“ Check the onlyLendPoolManager on setReserveFactor
    âœ“ Batch Changes the reserve factor of WETH & DAI
    âœ“ Check the onlyPoolAdmin on batchConfigReserve
    âœ“ Reverts when trying to disable the DAI reserve with liquidity on it
    âœ“ Config setMaxNumberOfReserves valid value
    âœ“ Config setMaxNumberOfReserves invalid value
    âœ“ Config setMaxNumberOfReserves invalid value overflow
    âœ“ Check the onlyAdmin on setMaxNumberOfReserves 

  DataProvider
    âœ“ Borrows WETH using 1 BAYC
    âœ“ Query UI Reserve Data
    âœ“ Query UI NFT Data
    âœ“ Query UI Loan Data
    âœ“ Query Wallet Reserve Data
    âœ“ Query Wallet NFT Data

  LendPool: Deposit
    âœ“ User 0 Deposits 1000 DAI in an empty reserve
    âœ“ User 1 deposits 1000 DAI after user 0
    âœ“ User 0 deposits 1000 USDC in an empty reserve
    âœ“ User 1 deposits 1000 USDC after user 0
    âœ“ User 0 deposits 1 WETH in an empty reserve
    âœ“ User 1 deposits 1 WETH after user 0
    âœ“ User 1 deposits 0 WETH (revert expected)
    âœ“ User 1 deposits 0 DAI (revert expected)
    âœ“ User 1 deposits 100 DAI on behalf of user 2, user 2 tries to borrow 0.01 WETH

  Interest rate tests
*** InterestRate ***

Network: hardhat
tx: 0x9ec6d7eaa3be56eb5b25ba4988681e6e3304ce9dca0dfb4976eab3c877e128c3
contract address: 0x63A425c53CDA1415F8efE54e57cC507c756b96f2
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x63A425c53CDA1415F8efE54e57cC507c756b96f2 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    âœ“ Checks rates at 0% utilization rate, empty reserve
    âœ“ Checks rates at 80% utilization rate
    âœ“ Checks rates at 100% utilization rate

  LendPool: Malicious Hacker Rentrant
hacker do reentrant action: ACTION_DEPOSIT
hacker do reentrant action: ACTION_WITHDRAW
hacker do reentrant action: ACTION_BORROW
hacker do reentrant action: ACTION_REPAY
hacker do reentrant action: ACTION_AUCTION
hacker do reentrant action: ACTION_REDEEM
hacker do reentrant action: ACTION_LIQUIDATE_NFTX
    âœ“ Malicious hacker try to reentrant (should revert)

  LendPool: Liquidation negative test cases
    âœ“ User 0 deposit 100 WETH, user 1 mint NFT and borrow 10 WETH
    âœ“ User 1 liquidate on a non-existent NFT
    âœ“ User 2 auction on a loan health factor above 1
    âœ“ Drop loan health factor below 1
    âœ“ User 2 auction price is unable to cover borrow
    âœ“ User 2 auction price is less than liquidate price
    âœ“ User 2 auction price is enough to cover borrow and liqudiate price
    âœ“ User 3 auction price is lesser than user 2
    âœ“ User 2 liquidate before auction duration is end
    âœ“ User 1 redeem but bidFine is not fullfil to borrow amount of user 2 auction
    âœ“ User 1 redeem but amount is not fullfil to mininum repay amount
    âœ“ User 1 redeem but amount is not fullfil to maximum repay amount
    âœ“ Ends redeem duration
    âœ“ User 1 redeem after duration is end
    âœ“ Ends auction duration
    âœ“ User 3 auction after duration is end
    âœ“ User 2 auction consecutively

  LendPool: Liquidation
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Auctions the borrow
    âœ“ WETH - Can't liquidate on NFTX due to invalid loan state
    âœ“ USDC - Borrows USDC
    âœ“ USDC - Drop the health factor below 1
    âœ“ USDC - Auctions the borrow at first time
    âœ“ USDC - Auctions the borrow at second time with higher price
    âœ“ USDC - Can't liquidate on NFTX

  LendPool: Liquidation
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ USDC - Borrows USDC
    âœ“ USDC - Drop the health factor below 1

  LendPool: Redeem
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Auctions the borrow
    âœ“ WETH - Redeems the borrow
    âœ“ WETH - Repays the borrow
    âœ“ DAI - Borrows DAI
    âœ“ DAI - Drop the health factor below 1
    âœ“ DAI - Auctions the borrow
    âœ“ DAI - Redeems the borrow
    âœ“ DAI - Repays the borrow

  LendPool: Liquidation on SudoSwap
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Liquidates the borrow on SudoSwap
    âœ“ DAI - Borrows DAI
    âœ“ DAI - Drop the health factor below 1
    âœ“ DAI - Liquidates the borrow on SudoSwap

  LendPool: Liquidation
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Auctions the borrow
    âœ“ WETH - Liquidates the borrow
    âœ“ USDC - Borrows USDC
    âœ“ USDC - Drop the health factor below 1
    âœ“ USDC - Auctions the borrow at first time
    âœ“ USDC - Auctions the borrow at second time with higher price
    âœ“ USDC - Liquidates the borrow

  LendPoolLoan: Modifiers
    âœ“ Tries to invoke initNft not being the Pool
    âœ“ Tries to invoke createLoan not being the Pool
    âœ“ Tries to invoke updateLoan not being the Pool
    âœ“ Tries to invoke repayLoan not being the Pool
    âœ“ Tries to invoke auctionLoan not being the Pool
    âœ“ Tries to invoke redeemLoan not being the Pool
    âœ“ Tries to invoke liquidateLoan not being the Pool
    âœ“ Tries to invoke liquidateLoanNFTX not being the Pool

  NFTOracle: General functioning
    âœ“ Set Admin correctly
    âœ“ Set and get Mocknft price at 1000
    âœ“ Add 2 Multi Assets
    âœ“ Add 3 Multi Assets
    âœ“ Add 3 Multi Assets - BigNumbers
    âœ“ Single asset price updates
    âœ“ Multiple asset price updates

  NFTOracle: Reverting Errors
    âœ“ Should be reverted as NFTOracle is already initialized
    âœ“ Should be reverted as it is a non-existing collection
    âœ“ Should be reverted as price is 0
    âœ“ Should be reverted as the collection has been deleted
    âœ“ Should be reverted as contract is paused
    âœ“ Should be reverted as array lengths aren't matching (2 vs 3)
    âœ“ Testing overflows

  NFTOracle: Test Pause
    âœ“ Should revert as collection is paused
    âœ“ Should revert on multi-paused collections

  LendPool: Pause
    âœ“ Transfer
    âœ“ Deposit
    âœ“ Withdraw
    âœ“ Borrow
    âœ“ Repay
    âœ“ Liquidate
    âœ“ LiquidateNFTX

  PunkGateway: Delegate
    âœ“ Hacker try to borrow and delegate different onBehalf (should revert)
    âœ“ Hacker try to auction and delegate different onBehalf (should revert)

  PunkGateway
    âœ“ Owner can do emergency CryptoPunks recovery
    âœ“ Borrow some USDC and repay it
    âœ“ Borrow some ETH and repay it
    âœ“ Borrow all ETH and repay it

  PunkGateway-Liquidate
    âœ“ Borrow USDC and liquidate it

    1) Borrow USDC and redeem it
    âœ“ Borrow ETH and liquidate it

    2) Borrow ETH and redeem it

  Repay and transfer helper tests
    âœ“ borrow-repay-transfer

  LendPool: Rescue locked funds
BigNumber { value: "1000000000000000000000" }
    âœ“ User 1 transfers 100 DAI directly to pool, and rescuer returns funds
BigNumber { value: "1000000000000000000000" }
    âœ“ Prevents a random user from rescuing tokens 

  Upgradeability
    âœ“ Tries to update the DAI UToken implementation with a different address than the configuator
    âœ“ Upgrades the DAI UToken implementation 
    âœ“ Tries to update the DAI DebtToken implementation with a different address than the configuator
    âœ“ Upgrades the DAI DebtToken implementation 
    âœ“ Tries to update the LendPoolLoan implementation with a different address than the address provider
    âœ“ Upgrades the LendPoolLoan implementation 

  UToken: Modifiers
    âœ“ Tries to invoke mint not being the Pool
    âœ“ Tries to invoke burn not being the Pool
    âœ“ Tries to invoke mintToTreasury not being the Pool
    âœ“ Tries to invoke transferUnderlyingTo not being the Pool

  UToken
    âœ“ Check DAI basic parameters
    âœ“ User 0 deposits 1000 DAI, transfers uDai to user 1
    âœ“ User 1 receive uDai from user 0, transfers 50% to user 2

  WETHGateway - Delegate
    âœ“ Hacker try to delegate different onBehalf (should revert)
    âœ“ Borrower try to Borrow more ETH to different onBehalf (should revert)
Hacker try Borrow more ETH with others NFT
    âœ“ Hacker try to Borrow more ETH (should revert)

  WETHGateway
    âœ“ Deposit WETH via WethGateway 
    âœ“ Withdraw WETH - Partial
    âœ“ Withdraw WETH - Full
    âœ“ Borrow WETH and Full Repay with ETH
Partial Repay ETH loan with native ETH
Full Repay ETH loan with native ETH
    âœ“ Borrow ETH and Full Repay with ETH
    âœ“ Should revert if receiver function receives Ether if not WETH
    âœ“ Should revert if fallback functions is called with Ether
    âœ“ Should revert if fallback functions is called
    âœ“ Owner can do emergency ERC20 recovery
    âœ“ Owner can do emergency ERC721 recovery
*** SelfdestructTransferMock ***

Network: hardhat
tx: 0x5d6441836e1e9cf2a50fdd5b265ecece8b7b2cb9be828f8fa4dbd8895ea58e4a
contract address: 0x054bD77E1501117Aad9127fF51B4F130Eb839552
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000007
gas used: 88001

******

contracts-helpers:registerContractInJsonDb, contractId: SelfdestructTransferMock address: 0x054bD77E1501117Aad9127fF51B4F130Eb839552 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    âœ“ Owner can do emergency native ETH recovery

  WETHGateway - Liquidate
    âœ“ Borrow ETH and Liquidate it

    3) Borrow ETH and Redeem it

  LendPool: Withdraw negative test cases
    âœ“ Users 0 Deposits 1000 DAI and tries to withdraw 0 DAI (revert expected)
    âœ“ Users 0 tries to withdraw 1100 DAI from the 1000 DAI deposited (revert expected)
    âœ“ Users 1 borrows 100 DAI, users 0 tries to withdraw the 1000 DAI deposited (revert expected)
    âœ“ Users 1 deposits 1 WETH, users 0 borrows 0.01 WETH, users 1 tries to withdraw the 1 WETH deposited (revert expected)

  LendPool: Withdraw
    âœ“ User 0 Deposits 1000 DAI in an empty reserve
    âœ“ User 0 withdraws half of the deposited DAI
    âœ“ User 0 withdraws remaining half of the deposited DAI
    âœ“ User 0 Deposits 1 WETH in an empty reserve
    âœ“ User 0 withdraws half of the deposited WETH
    âœ“ User 0 withdraws remaining half of the deposited WETH
    âœ“ Users 0 and 1 Deposit 1000 DAI, both withdraw
    âœ“ Users 0 deposits 1000 DAI, user 1 Deposit 1000 USDC and 1 WETH, borrows 100 DAI. User 1 tries to withdraw all the USDC

Â·---------------------------------------------------------------------|---------------------------|-------------|-----------------------------Â·
|                         [90mSolc version: 0.8.4[39m                         Â·  [90mOptimizer enabled: true[39m  Â·  [90mRuns: 200[39m  Â·  [90mBlock limit: 12450000 gas[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mMethods[22m[39m                                                                                                                                    â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [1mContract[22m                           Â·  [1mMethod[22m                       Â·  [32mMin[39m        Â·  [32mMax[39m        Â·  [32mAvg[39m        Â·  [1m# calls[22m      Â·  [1meur (avg)[22m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m                  Â·  allInitialOwnersAssigned     Â·      [36m25618[39m  Â·      [31m45518[39m  Â·      38885  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m                  Â·  getPunk                      Â·      [36m74914[39m  Â·      [31m74926[39m  Â·      74924  Â·           [90m12[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m                  Â·  offerPunkForSaleToAddress    Â·      [36m99387[39m  Â·     [31m119299[39m  Â·     116454  Â·           [90m14[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m                  Â·  setInitialOwner              Â·      [36m28434[39m  Â·      [31m60589[39m  Â·      49871  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m                  Â·  transferPunk                 Â·          -  Â·          -  Â·      66575  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCustomERC721[39m                       Â·  safeTransferFrom             Â·          -  Â·          -  Â·      95752  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCustomERC721[39m                       Â·  setApprovalForAll            Â·      [36m26324[39m  Â·      [31m46224[39m  Â·      40101  Â·           [90m78[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCustomERC721[39m                       Â·  transferFrom                 Â·      [36m71346[39m  Â·      [31m96740[39m  Â·      91126  Â·           [90m69[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m                   Â·  approve                      Â·      [36m26342[39m  Â·      [31m60190[39m  Â·      46767  Â·          [90m158[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m                   Â·  transfer                     Â·      [36m34567[39m  Â·     [31m133413[39m  Â·      53967  Â·          [90m163[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setAddress                   Â·      [36m29133[39m  Â·      [31m49369[39m  Â·      41945  Â·           [90m20[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setAddressAsProxy            Â·          -  Â·          -  Â·     699944  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setEmergencyAdmin            Â·          -  Â·          -  Â·      47355  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setIncentivesController      Â·      [36m30275[39m  Â·      [31m47363[39m  Â·      38819  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolConfiguratorImpl  Â·          -  Â·          -  Â·     610427  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolImpl              Â·          -  Â·          -  Â·     698808  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolLiquidator        Â·      [36m27543[39m  Â·      [31m47443[39m  Â·      35110  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolLoanImpl          Â·      [36m43396[39m  Â·     [31m659480[39m  Â·     454119  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLSSVMRouter               Â·          -  Â·          -  Â·      47442  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setNFTOracle                 Â·          -  Â·          -  Â·      47421  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setNFTXVaultFactory          Â·          -  Â·          -  Â·      47377  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setPoolAdmin                 Â·          -  Â·          -  Â·      47444  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setReserveOracle             Â·          -  Â·          -  Â·      47354  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setSushiSwapRouter           Â·          -  Â·          -  Â·      47399  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setUIDataProvider            Â·          -  Â·          -  Â·      47295  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setUNFTRegistry              Â·      [36m27476[39m  Â·      [31m47376[39m  Â·      37426  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setUnlockdDataProvider       Â·          -  Â·          -  Â·      47421  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setWalletBalanceProvider     Â·          -  Â·          -  Â·      47463  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  transferOwnership            Â·          -  Â·          -  Â·      28645  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProviderRegistry[39m  Â·  registerAddressesProvider    Â·          -  Â·          -  Â·      92000  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchConfigNft               Â·      [36m88028[39m  Â·    [31m1105252[39m  Â·     753611  Â·           [90m12[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchConfigReserve           Â·      [36m80088[39m  Â·      [31m97629[39m  Â·      91782  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchInitNft                 Â·     [36m241624[39m  Â·     [31m256916[39m  Â·     249270  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchInitReserve             Â·    [36m1616376[39m  Â·    [31m1631536[39m  Â·    1621449  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  configureNftAsAuction        Â·      [36m68208[39m  Â·      [31m68244[39m  Â·      68226  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  configureNftsAsCollateral    Â·      [36m96917[39m  Â·     [31m133953[39m  Â·     111532  Â·           [90m58[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setActiveFlagOnNft           Â·      [36m78124[39m  Â·      [31m83729[39m  Â·      80927  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setActiveFlagOnNftByTokenId  Â·      [36m69729[39m  Â·      [31m69741[39m  Â·      69735  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setActiveFlagOnReserve       Â·      [36m66655[39m  Â·      [31m88835[39m  Â·      77745  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setBorrowingFlagOnReserve    Â·      [36m66623[39m  Â·      [31m66647[39m  Â·      66644  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setFreezeFlagOnNft           Â·      [36m66577[39m  Â·      [31m66590[39m  Â·      66584  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setFreezeFlagOnNftByTokenId  Â·      [36m69571[39m  Â·      [31m69583[39m  Â·      69577  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setFreezeFlagOnReserve       Â·      [36m66626[39m  Â·      [31m66638[39m  Â·      66632  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setLtvManagerStatus          Â·      [36m39630[39m  Â·      [31m59530[39m  Â·      45652  Â·           [90m76[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setNftMinBidFine             Â·      [36m68015[39m  Â·      [31m68039[39m  Â·      68027  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setNftRedeemThreshold        Â·      [36m68036[39m  Â·      [31m68060[39m  Â·      68048  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setPoolPause                 Â·      [36m61575[39m  Â·     [31m101218[39m  Â·      77269  Â·           [90m18[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setPoolRescuer               Â·      [36m63859[39m  Â·      [31m80959[39m  Â·      72409  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setReserveFactor             Â·          -  Â·          -  Â·      66920  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  updateDebtToken              Â·          -  Â·          -  Â·      89446  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  updateUToken                 Â·          -  Â·          -  Â·      89423  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMaliciousHackerERC721[39m              Â·  approveDelegate              Â·          -  Â·          -  Â·      87451  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMaliciousHackerERC721[39m              Â·  simulateAction               Â·      [36m26483[39m  Â·      [31m43583[39m  Â·      28926  Â·            [90m7[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockChainlinkOracle[39m                Â·  mockAddAnswer                Â·     [36m125897[39m  Â·     [31m245509[39m  Â·     149398  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockDebtTokenVersionN[39m              Â·  approveDelegation            Â·      [36m39048[39m  Â·      [31m56148[39m  Â·      51458  Â·           [90m30[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockIncentivesController[39m           Â·  resetHandleActionIsCalled    Â·          -  Â·          -  Â·      27882  Â·            [90m9[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  approveValuation             Â·          -  Â·          -  Â·      50300  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  auction                      Â·     [36m313256[39m  Â·     [31m503796[39m  Â·     441750  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  borrow                       Â·     [36m396110[39m  Â·     [31m831510[39m  Â·     743320  Â·           [90m49[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  deposit                      Â·     [36m179528[39m  Â·     [31m251418[39m  Â·     218825  Â·          [90m101[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  liquidate                    Â·     [36m500206[39m  Â·     [31m538485[39m  Â·     519346  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  liquidateSudoSwap            Â·     [36m632536[39m  Â·     [31m747528[39m  Â·     690032  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  redeem                       Â·     [36m376218[39m  Â·     [31m413984[39m  Â·     395101  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  repay                        Â·     [36m284521[39m  Â·     [31m454189[39m  Â·     379256  Â·           [90m14[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  rescue                       Â·          -  Â·          -  Â·      57185  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  setIsMarketSupported         Â·      [36m56551[39m  Â·      [31m78475[39m  Â·      61288  Â·           [90m70[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  setMaxNumberOfReserves       Â·          -  Â·          -  Â·      62697  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  setTimeframe                 Â·      [36m58166[39m  Â·      [31m78078[39m  Â·      60634  Â·           [90m31[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  setTreasuryAddress           Â·          -  Â·          -  Â·      80586  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  updateSafeHealthFactor       Â·      [36m40196[39m  Â·      [31m60096[39m  Â·      55109  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  withdraw                     Â·     [36m152923[39m  Â·     [31m218820[39m  Â·     187090  Â·           [90m24[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  addCollection                Â·      [36m47505[39m  Â·      [31m54843[39m  Â·      49232  Â·           [90m17[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  initialize                   Â·          -  Â·          -  Â·     113794  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  removeCollection             Â·          -  Â·          -  Â·      25685  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  setMultipleNFTPrices         Â·      [36m62686[39m  Â·      [31m84325[39m  Â·      73684  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  setNFTPrice                  Â·      [36m33049[39m  Â·      [31m60368[39m  Â·      43229  Â·          [90m119[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  setPause                     Â·      [36m27850[39m  Â·      [31m49762[39m  Â·      38806  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  setPriceManagerStatus        Â·      [36m33894[39m  Â·      [31m53794[39m  Â·      37273  Â·           [90m84[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  addAggregator                Â·      [36m75602[39m  Â·      [31m92702[39m  Â·      89282  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  initialize                   Â·          -  Â·          -  Â·      90917  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  mock_setBlockTimestamp       Â·          -  Â·          -  Â·      26541  Â·            [90m7[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  removeAggregator             Â·      [36m33119[39m  Â·      [31m37640[39m  Â·      34023  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  setAggregators               Â·          -  Â·          -  Â·     196520  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  auction                      Â·     [36m543440[39m  Â·     [31m546240[39m  Â·     544840  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  auctionETH                   Â·     [36m514941[39m  Â·     [31m517741[39m  Â·     516341  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  authorizeCallerWhitelist     Â·      [36m62136[39m  Â·     [31m103532[39m  Â·      81742  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  authorizeLendPoolERC20       Â·          -  Â·          -  Â·     157831  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  borrow                       Â·     [36m446542[39m  Â·    [31m1032260[39m  Â·     850700  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  borrowETH                    Â·     [36m467964[39m  Â·    [31m1052458[39m  Â·     922200  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  emergencyERC20Transfer       Â·          -  Â·          -  Â·      60324  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  emergencyERC721Transfer      Â·          -  Â·          -  Â·      99383  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  emergencyPunksTransfer       Â·          -  Â·          -  Â·      79826  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  liquidate                    Â·          -  Â·          -  Â·     749199  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  liquidateETH                 Â·          -  Â·          -  Â·     770373  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  repay                        Â·     [36m316518[39m  Â·     [31m566782[39m  Â·     441650  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  repayETH                     Â·     [36m362045[39m  Â·     [31m727672[39m  Â·     592159  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mRepayAndTransferHelper[39m             Â·  emergencyEtherTransfer       Â·          -  Â·          -  Â·      42635  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mRepayAndTransferHelper[39m             Â·  repayETHAndTransferERC721    Â·          -  Â·          -  Â·     636709  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mSelfdestructTransfer[39m               Â·  destroyAndTransfer           Â·      [36m29253[39m  Â·      [31m29265[39m  Â·      29263  Â·          [90m232[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mUNFTRegistry[39m                       Â·  createUNFT                   Â·     [36m725406[39m  Â·     [31m742551[39m  Â·     733979  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  auctionETH                   Â·     [36m489248[39m  Â·     [31m491900[39m  Â·     490574  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  authorizeLendPoolNFT         Â·          -  Â·          -  Â·      99328  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  borrowETH                    Â·     [36m421126[39m  Â·     [31m832207[39m  Â·     757989  Â·           [90m12[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  depositETH                   Â·     [36m197656[39m  Â·     [31m277112[39m  Â·     233196  Â·           [90m18[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  liquidateETH                 Â·          -  Â·          -  Â·     551606  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  repayETH                     Â·     [36m320076[39m  Â·     [31m519009[39m  Â·     431808  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  withdrawETH                  Â·     [36m262577[39m  Â·     [31m291924[39m  Â·     277251  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWrappedPunk[39m                        Â·  setApprovalForAll            Â·      [36m26420[39m  Â·      [31m46320[39m  Â·      34949  Â·           [90m14[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mDeployments[22m[39m                                                        Â·                                         Â·  [1m% of limit[22m   Â·             â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  BorrowLogic                                                        Â·          -  Â·          -  Â·    2066318  Â·       [90m16.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ConfiguratorLogic                                                  Â·          -  Â·          -  Â·    1970094  Â·       [90m15.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  CryptoPunksMarket                                                  Â·          -  Â·          -  Â·    2378109  Â·       [90m19.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  DebtToken                                                          Â·          -  Â·          -  Â·    1366344  Â·         [90m11 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  GenericLogic                                                       Â·          -  Â·          -  Â·      84290  Â·        [90m0.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  InterestRate                                                       Â·     [36m616243[39m  Â·     [31m616255[39m  Â·     616252  Â·        [90m4.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPool                                                           Â·          -  Â·          -  Â·    5095759  Â·       [90m40.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolAddressesProvider                                          Â·          -  Â·          -  Â·    2978496  Â·       [90m23.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolAddressesProviderRegistry                                  Â·          -  Â·          -  Â·     502283  Â·          [90m4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolConfigurator                                               Â·          -  Â·          -  Â·    5346518  Â·       [90m42.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolLoan                                                       Â·          -  Â·          -  Â·    3262299  Â·       [90m26.2 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LiquidateLogic                                                     Â·          -  Â·          -  Â·    3939677  Â·       [90m31.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LiquidateMarketsLogic                                              Â·          -  Â·          -  Â·    2995275  Â·       [90m24.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MaliciousHackerERC721                                              Â·          -  Â·          -  Â·     801955  Â·        [90m6.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockChainlinkOracle                                                Â·          -  Â·          -  Â·     620122  Â·          [90m5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockIncentivesController                                           Â·          -  Â·          -  Â·     142669  Â·        [90m1.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockNFTOracle                                                      Â·          -  Â·          -  Â·    1117453  Â·          [90m9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockReserveOracle                                                  Â·          -  Â·          -  Â·    1280668  Â·       [90m10.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  NftLogic                                                           Â·          -  Â·          -  Â·     141010  Â·        [90m1.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  NFTOracle                                                          Â·          -  Â·          -  Â·    1047527  Â·        [90m8.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  PunkGateway                                                        Â·          -  Â·          -  Â·    3304310  Â·       [90m26.5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  RepayAndTransferHelper                                             Â·          -  Â·          -  Â·     873271  Â·          [90m7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ReserveLogic                                                       Â·          -  Â·          -  Â·     171208  Â·        [90m1.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ReserveOracle                                                      Â·          -  Â·          -  Â·    1211618  Â·        [90m9.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  SelfdestructTransfer                                               Â·          -  Â·          -  Â·      88001  Â·        [90m0.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  SupplyLogic                                                        Â·          -  Â·          -  Â·    1184796  Â·        [90m9.5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UiPoolDataProvider                                                 Â·          -  Â·          -  Â·    3116123  Â·         [90m25 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UNFT                                                               Â·          -  Â·          -  Â·    1503057  Â·       [90m12.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UNFTRegistry                                                       Â·          -  Â·          -  Â·    2441516  Â·       [90m19.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdProtocolDataProvider                                        Â·          -  Â·          -  Â·    2888605  Â·       [90m23.2 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdProxyAdmin                                                  Â·          -  Â·          -  Â·     470704  Â·        [90m3.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdUpgradeableProxy                                            Â·     [36m689038[39m  Â·     [31m998847[39m  Â·     777214  Â·        [90m6.2 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UToken                                                             Â·          -  Â·          -  Â·    1983088  Â·       [90m15.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ValidationLogic                                                    Â·          -  Â·          -  Â·    1530121  Â·       [90m12.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  WalletBalanceProvider                                              Â·          -  Â·          -  Â·    1251342  Â·       [90m10.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  WETHGateway                                                        Â·          -  Â·          -  Â·    2420738  Â·       [90m19.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  WrappedPunk                                                        Â·          -  Â·          -  Â·    1992593  Â·         [90m16 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·---------------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------Â·

  251 passing (3m)
  3 failing

  1) PunkGateway-Liquidate
       Borrow USDC and redeem it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '202'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0xb16101f4b859580B810b683264102c49e12d0732","data":"0xb81922050000000000000000000000000000000000000000000000000000000000000068000000000000000000000000000000000000000000000000000000000093db9a00000000000000000000000000000000000000000000000000000000000ff209","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"PunkGateway","sourceName":"contracts/protocol/PunkGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IPunks} from \"../interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../interfaces/IWrappedPunks.sol\";\nimport {IPunkGateway} from \"../interfaces/IPunkGateway.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract PunkGateway is IPunkGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  IWETHGateway internal _wethGateway;\n\n  IPunks public punks;\n  IWrappedPunks public wrappedPunks;\n  address public proxy;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the PunkGateway contract is added to the\n   * LendPoolAddressesProvider of the market.\n   **/\n  function initialize(\n    address addressProvider,\n    address wethGateway,\n    address _punks,\n    address _wrappedPunks\n  ) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n    _wethGateway = IWETHGateway(wethGateway);\n\n    punks = IPunks(_punks);\n    wrappedPunks = IWrappedPunks(_wrappedPunks);\n    wrappedPunks.registerProxy();\n    proxy = wrappedPunks.proxyInfo(address(this));\n\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_getLendPool()), true);\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_wethGateway), true);\n  }\n\n  /**\n   * @notice Returns the LendPool address\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice Returns the LendPoolLoan address\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @notice Approves the lendpool for given tokens\n   * @param tokens the array of tokens\n   **/\n  function authorizeLendPoolERC20(address[] calldata tokens) external nonReentrant onlyOwner {\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ) {\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), 0);\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), type(uint256).max);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Authorizes/unauthorizes an array of callers to the whitelist\n   * @param callers the array of callers\n   * @param callers the authorization status\n   **/\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callersLength = callers.length;\n    for (uint256 i = 0; i < callersLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if caller is whitelisted\n   * @param caller caller address\n   **/\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @notice Checks the onBehalfOf address is valid for a given callet\n   * @param onBehalfOf the allowed address\n   **/\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @notice Deposits a punk given its index\n   * - E.g. User deposit NFT Punk and receives the wrapped asset\n   * @param punkIndex The index of the CryptoPunk to deposit\n   **/\n  function _depositPunk(uint256 punkIndex) internal {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    if (loanId != 0) {\n      return;\n    }\n\n    address owner = punks.punkIndexToAddress(punkIndex);\n\n    require(owner == _msgSender(), \"PunkGateway: not owner of punkIndex\");\n\n    punks.buyPunk(punkIndex);\n\n    punks.transferPunk(proxy, punkIndex);\n\n    wrappedPunks.mint(punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrow(\n    address reserveAsset,\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    _depositPunk(punkIndex);\n\n    cachedPool.borrow(reserveAsset, amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n\n    IERC20Upgradeable(reserveAsset).transfer(onBehalfOf, amount);\n  }\n\n  function _withdrawPunk(uint256 punkIndex, address onBehalfOf) internal {\n    address owner = wrappedPunks.ownerOf(punkIndex);\n    require(owner == _msgSender(), \"PunkGateway: caller is not owner\");\n    require(owner == onBehalfOf, \"PunkGateway: onBehalfOf is not owner\");\n\n    wrappedPunks.safeTransferFrom(onBehalfOf, address(this), punkIndex);\n    wrappedPunks.burn(punkIndex);\n    punks.transferPunk(onBehalfOf, punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repay(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256, bool) {\n    return _repay(punkIndex, amount);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk used as collateral\n   * @param amount The amount to repay\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repay(uint256 punkIndex, uint256 amount) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n    (, uint256 debt) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n\n    if (amount > debt) {\n      amount = debt;\n    }\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), amount);\n\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(address(wrappedPunks), punkIndex, amount);\n\n    if (burn) {\n      require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auction(uint256 punkIndex, uint256 bidPrice, address onBehalfOf) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), bidPrice);\n\n    cachedPool.auction(address(wrappedPunks), punkIndex, bidPrice, onBehalfOf);\n  }\n\n  function redeem(uint256 punkIndex, uint256 amount, uint256 bidFine) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), (amount + bidFine));\n\n    uint256 paybackAmount = cachedPool.redeem(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    if ((amount + bidFine) > paybackAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, ((amount + bidFine) - paybackAmount));\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidate(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    if (amount > 0) {\n      IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), amount);\n    }\n\n    uint256 extraRetAmount = cachedPool.liquidate(address(wrappedPunks), punkIndex, amount);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    if (amount > extraRetAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, (amount - extraRetAmount));\n    }\n\n    return (extraRetAmount);\n  }\n\n  /**\n   * @notice Liquidate punk in NFTX\n   * @param punkIndex The index of the CryptoPunk to liquidate\n   **/\n  function liquidateNFTX(uint256 punkIndex, uint256 amountOutMin) external override nonReentrant returns (uint256) {\n    require(_addressProvider.getLendPoolLiquidator() == _msgSender(), Errors.CALLER_NOT_POOL_LIQUIDATOR);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    uint256 remainAmount = cachedPool.liquidateNFTX(address(wrappedPunks), punkIndex, amountOutMin);\n\n    return (remainAmount);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _depositPunk(punkIndex);\n    _wethGateway.borrowETH(amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repayETH(uint256 punkIndex, uint256 amount) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 paybackAmount, bool burn) = _repayETH(punkIndex, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk with native ETH\n   * - E.g. User repays 100 ETH, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk to repay\n   * @param amount The amount to repay\n   * @param accAmount The accumulated amount\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repayETH(uint256 punkIndex, uint256 amount, uint256 accAmount) internal returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n    require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    (uint256 paybackAmount, bool burn) = _wethGateway.repayETH{value: repayDebtAmount}(\n      address(wrappedPunks),\n      punkIndex,\n      amount\n    );\n\n    if (burn) {\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(uint256 punkIndex, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _wethGateway.auctionETH{value: msg.value}(address(wrappedPunks), punkIndex, onBehalfOf);\n  }\n\n  function redeemETH(\n    uint256 punkIndex,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    //DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    uint256 paybackAmount = _wethGateway.redeemETH{value: msg.value}(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(uint256 punkIndex) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    uint256 extraAmount = _wethGateway.liquidateETH{value: msg.value}(address(wrappedPunks), punkIndex);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    // refund remaining dust eth\n    if (msg.value > extraAmount) {\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return extraAmount;\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":271,"range":[9705,9773]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000001;\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000002;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    require(\n      _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n        _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n      Errors.LP_CALLER_NOT_NFT_HOLDER\n    );\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,   \n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset, \n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n \n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor; \n    emit SafeHealthFactorUpdated(newSafeHealthFactor); \n  } \n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param uToken the utoken to update the treasury address to\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address uToken, address treasury) external override onlyLendPoolConfigurator {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    IUToken(uToken).setTreasuryAddress(treasury);\n    emit TreasuryAddressUpdated(uToken, treasury);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":326,"range":[12637,13039]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":362,"range":[14216,14425]},"functionType":1},{"type":0,"sourceReference":{"function":"calculateOptimalMinRedeemValue","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/GenericLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Unlockd\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct CalculateLoanDataVars {\n    uint256 reserveUnitPrice;\n    uint256 reserveUnit;\n    uint256 reserveDecimals;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalCollateralInReserve;\n    uint256 totalDebtInETH;\n    uint256 totalDebtInReserve;\n    uint256 nftLtv;\n    uint256 nftLiquidationThreshold;\n    address nftAsset;\n    uint256 nftTokenId;\n    uint256 nftUnitPrice;\n    uint256 minRedeemValue;\n  }\n\n  /**\n   * @dev Calculates the nft loan data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress the underlying NFT asset\n   * @param nftTokenId the token Id for the NFT\n   * @param nftConfig Config of the nft by tokenId\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\n   **/\n  function calculateLoanData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    // calculate total borrow balance for the loan\n    if (loanId != 0) {\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\n        reserveAddress,\n        reserveData,\n        loanAddress,\n        loanId,\n        reserveOracle\n      );\n    }\n\n    // calculate total collateral balance for the nft\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\n      reserveAddress,\n      reserveData,\n      nftAddress,\n      nftTokenId,\n      reserveOracle,\n      nftOracle\n    );\n\n    // calculate health by borrow and collateral\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInReserve,\n      vars.totalDebtInReserve,\n      vars.nftLiquidationThreshold\n    );\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\n  }\n\n  /**\n   * @dev Calculates the nft debt data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftDebtData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\n\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\n  }\n\n  /**\n   * @dev Calculates the nft collateral data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress The underlying NFT asset\n   * @param nftTokenId The underlying NFT token Id\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The nft price oracle address\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftCollateralData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256) {\n    reserveData;\n\n    CalculateLoanDataVars memory vars;\n \n    // calculate total collateral balance for the nft\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.totalCollateralInETH = vars.nftUnitPrice;\n\n    if (reserveAddress != address(0)) {\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\n      vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\n    }\n\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\n  }\n\n  /**\n   * @dev Calculates the optimal min redeem value\n   * @param borrowAmount The debt\n   * @param nftAddress The nft address\n   * @param nftTokenId The token id\n   * @param nftOracle The nft oracle address\n   * @param liquidationThreshold The liquidation threshold\n   * @param safeHealthFactor The safe health factor value\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateOptimalMinRedeemValue(\n    uint256 borrowAmount,\n    address nftAddress,\n    uint256 nftTokenId,\n    address nftOracle,\n    uint256 liquidationThreshold,\n    uint256 safeHealthFactor\n  ) internal view returns (uint256) {\n    CalculateLoanDataVars memory vars;\n\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.minRedeemValue =  borrowAmount - ((vars.nftUnitPrice.percentMul(liquidationThreshold)).wadDiv(safeHealthFactor)); \n    if(vars.nftUnitPrice < vars.minRedeemValue){\n      return vars.nftUnitPrice;\n    }\n\n    return vars.minRedeemValue;\n  }\n\n   function calculateOptimalMaxRedeemValue(\n    uint256 debt,\n    uint256 minRedeem\n  ) internal pure returns (uint256) {\n    return debt - ((debt - minRedeem).wadDiv(2 ether));\n  }\n\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total debt\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebt == 0) return type(uint256).max;\n\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\n  }\n\n  \n\n  /**\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow for the user\n   **/\n\n  function calculateAvailableBorrows(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\n\n    if (availableBorrows < totalDebt) {\n      return 0;\n    }\n\n    availableBorrows = availableBorrows - totalDebt;\n    return availableBorrows;\n  }\n\n  struct CalcLiquidatePriceLocalVars {\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 nftPriceInETH;\n    uint256 nftPriceInReserve;\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n  }\n\n  /**\n   * @dev Calculates the loan liquidation price\n   * @param loanId the loan Id\n   * @param reserveAsset The underlying asset of the reserve\n   * @param reserveData the reserve data\n   * @param nftAsset the underlying NFT asset\n   * @param nftTokenId the NFT token Id\n   * @param nftConfig The NFT data\n   * @param poolLoan The pool loan address\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The borrow amount, threshold price and liquidation price\n   **/\n  function calculateLoanLiquidatePrice(\n    uint256 loanId,\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address poolLoan,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalcLiquidatePriceLocalVars memory vars;\n\n    /*\n     * 0                   CR                  LH                  100\n     * |___________________|___________________|___________________|\n     *  <       Borrowing with Interest        <\n     * CR: Callteral Ratio;\n     * LH: Liquidate Threshold;\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\n     */\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\n \n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftConfig.getCollateralParams();\n\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getNFTPrice(nftAsset, nftTokenId);\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n\n    vars.nftPriceInReserve = ((10 ** vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\n\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\n\n    vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\n\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\n  }\n\n  struct CalcLoanBidFineLocalVars {\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 baseBidFineInReserve;\n    uint256 minBidFinePct;\n    uint256 minBidFineInReserve;\n    uint256 bidFineInReserve;\n    uint256 debtAmount;\n  }\n\n  function calculateLoanBidFine(\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    address poolLoan,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    nftAsset;\n\n    if (loanData.bidPrice == 0) {\n      return (0, 0);\n    }\n\n    CalcLoanBidFineLocalVars memory vars;\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n    vars.baseBidFineInReserve = (1 ether * 10 ** vars.reserveDecimals) / vars.reservePriceInETH;\n\n    vars.minBidFinePct = nftConfig.getMinBidFine();\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\n\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\n\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftConfig.getRedeemFine());\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\n      vars.bidFineInReserve = vars.minBidFineInReserve;\n    }\n\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\n  }\n}\n","line":199,"range":[7478,7555]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":461,"range":[17747,17813]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,50,48,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033230320000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)

  2) PunkGateway-Liquidate
       Borrow ETH and redeem it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '202'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0xb16101f4b859580B810b683264102c49e12d0732","value":{"type":"BigNumber","hex":"0x94faa47de030da08"},"data":"0xcf1c37b2000000000000000000000000000000000000000000000000000000000000006a000000000000000000000000000000000000000000000000867a0804e105953c0000000000000000000000000000000000000000000000000e809c78ff2b44cc","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeemETH","contract":"PunkGateway","sourceName":"contracts/protocol/PunkGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IPunks} from \"../interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../interfaces/IWrappedPunks.sol\";\nimport {IPunkGateway} from \"../interfaces/IPunkGateway.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract PunkGateway is IPunkGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  IWETHGateway internal _wethGateway;\n\n  IPunks public punks;\n  IWrappedPunks public wrappedPunks;\n  address public proxy;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the PunkGateway contract is added to the\n   * LendPoolAddressesProvider of the market.\n   **/\n  function initialize(\n    address addressProvider,\n    address wethGateway,\n    address _punks,\n    address _wrappedPunks\n  ) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n    _wethGateway = IWETHGateway(wethGateway);\n\n    punks = IPunks(_punks);\n    wrappedPunks = IWrappedPunks(_wrappedPunks);\n    wrappedPunks.registerProxy();\n    proxy = wrappedPunks.proxyInfo(address(this));\n\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_getLendPool()), true);\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_wethGateway), true);\n  }\n\n  /**\n   * @notice Returns the LendPool address\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice Returns the LendPoolLoan address\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @notice Approves the lendpool for given tokens\n   * @param tokens the array of tokens\n   **/\n  function authorizeLendPoolERC20(address[] calldata tokens) external nonReentrant onlyOwner {\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ) {\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), 0);\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), type(uint256).max);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Authorizes/unauthorizes an array of callers to the whitelist\n   * @param callers the array of callers\n   * @param callers the authorization status\n   **/\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callersLength = callers.length;\n    for (uint256 i = 0; i < callersLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if caller is whitelisted\n   * @param caller caller address\n   **/\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @notice Checks the onBehalfOf address is valid for a given callet\n   * @param onBehalfOf the allowed address\n   **/\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @notice Deposits a punk given its index\n   * - E.g. User deposit NFT Punk and receives the wrapped asset\n   * @param punkIndex The index of the CryptoPunk to deposit\n   **/\n  function _depositPunk(uint256 punkIndex) internal {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    if (loanId != 0) {\n      return;\n    }\n\n    address owner = punks.punkIndexToAddress(punkIndex);\n\n    require(owner == _msgSender(), \"PunkGateway: not owner of punkIndex\");\n\n    punks.buyPunk(punkIndex);\n\n    punks.transferPunk(proxy, punkIndex);\n\n    wrappedPunks.mint(punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrow(\n    address reserveAsset,\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    _depositPunk(punkIndex);\n\n    cachedPool.borrow(reserveAsset, amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n\n    IERC20Upgradeable(reserveAsset).transfer(onBehalfOf, amount);\n  }\n\n  function _withdrawPunk(uint256 punkIndex, address onBehalfOf) internal {\n    address owner = wrappedPunks.ownerOf(punkIndex);\n    require(owner == _msgSender(), \"PunkGateway: caller is not owner\");\n    require(owner == onBehalfOf, \"PunkGateway: onBehalfOf is not owner\");\n\n    wrappedPunks.safeTransferFrom(onBehalfOf, address(this), punkIndex);\n    wrappedPunks.burn(punkIndex);\n    punks.transferPunk(onBehalfOf, punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repay(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256, bool) {\n    return _repay(punkIndex, amount);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk used as collateral\n   * @param amount The amount to repay\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repay(uint256 punkIndex, uint256 amount) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n    (, uint256 debt) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n\n    if (amount > debt) {\n      amount = debt;\n    }\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), amount);\n\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(address(wrappedPunks), punkIndex, amount);\n\n    if (burn) {\n      require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auction(uint256 punkIndex, uint256 bidPrice, address onBehalfOf) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), bidPrice);\n\n    cachedPool.auction(address(wrappedPunks), punkIndex, bidPrice, onBehalfOf);\n  }\n\n  function redeem(uint256 punkIndex, uint256 amount, uint256 bidFine) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), (amount + bidFine));\n\n    uint256 paybackAmount = cachedPool.redeem(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    if ((amount + bidFine) > paybackAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, ((amount + bidFine) - paybackAmount));\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidate(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    if (amount > 0) {\n      IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), amount);\n    }\n\n    uint256 extraRetAmount = cachedPool.liquidate(address(wrappedPunks), punkIndex, amount);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    if (amount > extraRetAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, (amount - extraRetAmount));\n    }\n\n    return (extraRetAmount);\n  }\n\n  /**\n   * @notice Liquidate punk in NFTX\n   * @param punkIndex The index of the CryptoPunk to liquidate\n   **/\n  function liquidateNFTX(uint256 punkIndex, uint256 amountOutMin) external override nonReentrant returns (uint256) {\n    require(_addressProvider.getLendPoolLiquidator() == _msgSender(), Errors.CALLER_NOT_POOL_LIQUIDATOR);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    uint256 remainAmount = cachedPool.liquidateNFTX(address(wrappedPunks), punkIndex, amountOutMin);\n\n    return (remainAmount);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _depositPunk(punkIndex);\n    _wethGateway.borrowETH(amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repayETH(uint256 punkIndex, uint256 amount) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 paybackAmount, bool burn) = _repayETH(punkIndex, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk with native ETH\n   * - E.g. User repays 100 ETH, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk to repay\n   * @param amount The amount to repay\n   * @param accAmount The accumulated amount\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repayETH(uint256 punkIndex, uint256 amount, uint256 accAmount) internal returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n    require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    (uint256 paybackAmount, bool burn) = _wethGateway.repayETH{value: repayDebtAmount}(\n      address(wrappedPunks),\n      punkIndex,\n      amount\n    );\n\n    if (burn) {\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(uint256 punkIndex, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _wethGateway.auctionETH{value: msg.value}(address(wrappedPunks), punkIndex, onBehalfOf);\n  }\n\n  function redeemETH(\n    uint256 punkIndex,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    //DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    uint256 paybackAmount = _wethGateway.redeemETH{value: msg.value}(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(uint256 punkIndex) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    uint256 extraAmount = _wethGateway.liquidateETH{value: msg.value}(address(wrappedPunks), punkIndex);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    // refund remaining dust eth\n    if (msg.value > extraAmount) {\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return extraAmount;\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":407,"range":[14510,14601]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeemETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n  \n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    (address reserveAsset, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    require(reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(address nftAsset, uint256 nftTokenId, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(address nftAsset, uint256 nftTokenId) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":276,"range":[9389,9445]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000001;\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000002;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    require(\n      _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n        _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n      Errors.LP_CALLER_NOT_NFT_HOLDER\n    );\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,   \n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset, \n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n \n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor; \n    emit SafeHealthFactorUpdated(newSafeHealthFactor); \n  } \n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param uToken the utoken to update the treasury address to\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address uToken, address treasury) external override onlyLendPoolConfigurator {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    IUToken(uToken).setTreasuryAddress(treasury);\n    emit TreasuryAddressUpdated(uToken, treasury);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":326,"range":[12637,13039]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":362,"range":[14216,14425]},"functionType":1},{"type":0,"sourceReference":{"function":"calculateOptimalMinRedeemValue","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/GenericLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Unlockd\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct CalculateLoanDataVars {\n    uint256 reserveUnitPrice;\n    uint256 reserveUnit;\n    uint256 reserveDecimals;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalCollateralInReserve;\n    uint256 totalDebtInETH;\n    uint256 totalDebtInReserve;\n    uint256 nftLtv;\n    uint256 nftLiquidationThreshold;\n    address nftAsset;\n    uint256 nftTokenId;\n    uint256 nftUnitPrice;\n    uint256 minRedeemValue;\n  }\n\n  /**\n   * @dev Calculates the nft loan data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress the underlying NFT asset\n   * @param nftTokenId the token Id for the NFT\n   * @param nftConfig Config of the nft by tokenId\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\n   **/\n  function calculateLoanData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    // calculate total borrow balance for the loan\n    if (loanId != 0) {\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\n        reserveAddress,\n        reserveData,\n        loanAddress,\n        loanId,\n        reserveOracle\n      );\n    }\n\n    // calculate total collateral balance for the nft\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\n      reserveAddress,\n      reserveData,\n      nftAddress,\n      nftTokenId,\n      reserveOracle,\n      nftOracle\n    );\n\n    // calculate health by borrow and collateral\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInReserve,\n      vars.totalDebtInReserve,\n      vars.nftLiquidationThreshold\n    );\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\n  }\n\n  /**\n   * @dev Calculates the nft debt data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftDebtData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\n\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\n  }\n\n  /**\n   * @dev Calculates the nft collateral data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress The underlying NFT asset\n   * @param nftTokenId The underlying NFT token Id\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The nft price oracle address\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftCollateralData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256) {\n    reserveData;\n\n    CalculateLoanDataVars memory vars;\n \n    // calculate total collateral balance for the nft\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.totalCollateralInETH = vars.nftUnitPrice;\n\n    if (reserveAddress != address(0)) {\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\n      vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\n    }\n\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\n  }\n\n  /**\n   * @dev Calculates the optimal min redeem value\n   * @param borrowAmount The debt\n   * @param nftAddress The nft address\n   * @param nftTokenId The token id\n   * @param nftOracle The nft oracle address\n   * @param liquidationThreshold The liquidation threshold\n   * @param safeHealthFactor The safe health factor value\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateOptimalMinRedeemValue(\n    uint256 borrowAmount,\n    address nftAddress,\n    uint256 nftTokenId,\n    address nftOracle,\n    uint256 liquidationThreshold,\n    uint256 safeHealthFactor\n  ) internal view returns (uint256) {\n    CalculateLoanDataVars memory vars;\n\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.minRedeemValue =  borrowAmount - ((vars.nftUnitPrice.percentMul(liquidationThreshold)).wadDiv(safeHealthFactor)); \n    if(vars.nftUnitPrice < vars.minRedeemValue){\n      return vars.nftUnitPrice;\n    }\n\n    return vars.minRedeemValue;\n  }\n\n   function calculateOptimalMaxRedeemValue(\n    uint256 debt,\n    uint256 minRedeem\n  ) internal pure returns (uint256) {\n    return debt - ((debt - minRedeem).wadDiv(2 ether));\n  }\n\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total debt\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebt == 0) return type(uint256).max;\n\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\n  }\n\n  \n\n  /**\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow for the user\n   **/\n\n  function calculateAvailableBorrows(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\n\n    if (availableBorrows < totalDebt) {\n      return 0;\n    }\n\n    availableBorrows = availableBorrows - totalDebt;\n    return availableBorrows;\n  }\n\n  struct CalcLiquidatePriceLocalVars {\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 nftPriceInETH;\n    uint256 nftPriceInReserve;\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n  }\n\n  /**\n   * @dev Calculates the loan liquidation price\n   * @param loanId the loan Id\n   * @param reserveAsset The underlying asset of the reserve\n   * @param reserveData the reserve data\n   * @param nftAsset the underlying NFT asset\n   * @param nftTokenId the NFT token Id\n   * @param nftConfig The NFT data\n   * @param poolLoan The pool loan address\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The borrow amount, threshold price and liquidation price\n   **/\n  function calculateLoanLiquidatePrice(\n    uint256 loanId,\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address poolLoan,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalcLiquidatePriceLocalVars memory vars;\n\n    /*\n     * 0                   CR                  LH                  100\n     * |___________________|___________________|___________________|\n     *  <       Borrowing with Interest        <\n     * CR: Callteral Ratio;\n     * LH: Liquidate Threshold;\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\n     */\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\n \n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftConfig.getCollateralParams();\n\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getNFTPrice(nftAsset, nftTokenId);\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n\n    vars.nftPriceInReserve = ((10 ** vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\n\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\n\n    vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\n\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\n  }\n\n  struct CalcLoanBidFineLocalVars {\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 baseBidFineInReserve;\n    uint256 minBidFinePct;\n    uint256 minBidFineInReserve;\n    uint256 bidFineInReserve;\n    uint256 debtAmount;\n  }\n\n  function calculateLoanBidFine(\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    address poolLoan,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    nftAsset;\n\n    if (loanData.bidPrice == 0) {\n      return (0, 0);\n    }\n\n    CalcLoanBidFineLocalVars memory vars;\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n    vars.baseBidFineInReserve = (1 ether * 10 ** vars.reserveDecimals) / vars.reservePriceInETH;\n\n    vars.minBidFinePct = nftConfig.getMinBidFine();\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\n\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\n\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftConfig.getRedeemFine());\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\n      vars.bidFineInReserve = vars.minBidFineInReserve;\n    }\n\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\n  }\n}\n","line":199,"range":[7478,7555]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":461,"range":[17747,17813]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,50,48,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033230320000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)

  3) WETHGateway - Liquidate
       Borrow ETH and Redeem it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '202'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0x51bda59320165617F7209a38D08b11ccefF58F1a","value":{"type":"BigNumber","hex":"0x0129f500fee7dcd987"},"data":"0xceac58c00000000000000000000000009278420bf7548970799c56ef9a0b08186251533000000000000000000000000000000000000000000000000000000000000000740000000000000000000000000000000000000000000000010cf3c7194892ad190000000000000000000000000000000000000000000000001d0139e59f4a2c6e","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeemETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n  \n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    (address reserveAsset, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    require(reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(address nftAsset, uint256 nftTokenId, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(address nftAsset, uint256 nftTokenId) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":276,"range":[9389,9445]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000001;\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000002;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    require(\n      _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n        _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n      Errors.LP_CALLER_NOT_NFT_HOLDER\n    );\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,   \n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset, \n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n \n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor; \n    emit SafeHealthFactorUpdated(newSafeHealthFactor); \n  } \n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param uToken the utoken to update the treasury address to\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address uToken, address treasury) external override onlyLendPoolConfigurator {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    IUToken(uToken).setTreasuryAddress(treasury);\n    emit TreasuryAddressUpdated(uToken, treasury);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":326,"range":[12637,13039]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":362,"range":[14216,14425]},"functionType":1},{"type":0,"sourceReference":{"function":"calculateOptimalMinRedeemValue","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/GenericLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Unlockd\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct CalculateLoanDataVars {\n    uint256 reserveUnitPrice;\n    uint256 reserveUnit;\n    uint256 reserveDecimals;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalCollateralInReserve;\n    uint256 totalDebtInETH;\n    uint256 totalDebtInReserve;\n    uint256 nftLtv;\n    uint256 nftLiquidationThreshold;\n    address nftAsset;\n    uint256 nftTokenId;\n    uint256 nftUnitPrice;\n    uint256 minRedeemValue;\n  }\n\n  /**\n   * @dev Calculates the nft loan data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress the underlying NFT asset\n   * @param nftTokenId the token Id for the NFT\n   * @param nftConfig Config of the nft by tokenId\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\n   **/\n  function calculateLoanData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    // calculate total borrow balance for the loan\n    if (loanId != 0) {\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\n        reserveAddress,\n        reserveData,\n        loanAddress,\n        loanId,\n        reserveOracle\n      );\n    }\n\n    // calculate total collateral balance for the nft\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\n      reserveAddress,\n      reserveData,\n      nftAddress,\n      nftTokenId,\n      reserveOracle,\n      nftOracle\n    );\n\n    // calculate health by borrow and collateral\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInReserve,\n      vars.totalDebtInReserve,\n      vars.nftLiquidationThreshold\n    );\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\n  }\n\n  /**\n   * @dev Calculates the nft debt data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftDebtData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\n\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\n  }\n\n  /**\n   * @dev Calculates the nft collateral data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress The underlying NFT asset\n   * @param nftTokenId The underlying NFT token Id\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The nft price oracle address\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftCollateralData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256) {\n    reserveData;\n\n    CalculateLoanDataVars memory vars;\n \n    // calculate total collateral balance for the nft\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.totalCollateralInETH = vars.nftUnitPrice;\n\n    if (reserveAddress != address(0)) {\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\n      vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\n    }\n\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\n  }\n\n  /**\n   * @dev Calculates the optimal min redeem value\n   * @param borrowAmount The debt\n   * @param nftAddress The nft address\n   * @param nftTokenId The token id\n   * @param nftOracle The nft oracle address\n   * @param liquidationThreshold The liquidation threshold\n   * @param safeHealthFactor The safe health factor value\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateOptimalMinRedeemValue(\n    uint256 borrowAmount,\n    address nftAddress,\n    uint256 nftTokenId,\n    address nftOracle,\n    uint256 liquidationThreshold,\n    uint256 safeHealthFactor\n  ) internal view returns (uint256) {\n    CalculateLoanDataVars memory vars;\n\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.minRedeemValue =  borrowAmount - ((vars.nftUnitPrice.percentMul(liquidationThreshold)).wadDiv(safeHealthFactor)); \n    if(vars.nftUnitPrice < vars.minRedeemValue){\n      return vars.nftUnitPrice;\n    }\n\n    return vars.minRedeemValue;\n  }\n\n   function calculateOptimalMaxRedeemValue(\n    uint256 debt,\n    uint256 minRedeem\n  ) internal pure returns (uint256) {\n    return debt - ((debt - minRedeem).wadDiv(2 ether));\n  }\n\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total debt\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebt == 0) return type(uint256).max;\n\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\n  }\n\n  \n\n  /**\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow for the user\n   **/\n\n  function calculateAvailableBorrows(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\n\n    if (availableBorrows < totalDebt) {\n      return 0;\n    }\n\n    availableBorrows = availableBorrows - totalDebt;\n    return availableBorrows;\n  }\n\n  struct CalcLiquidatePriceLocalVars {\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 nftPriceInETH;\n    uint256 nftPriceInReserve;\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n  }\n\n  /**\n   * @dev Calculates the loan liquidation price\n   * @param loanId the loan Id\n   * @param reserveAsset The underlying asset of the reserve\n   * @param reserveData the reserve data\n   * @param nftAsset the underlying NFT asset\n   * @param nftTokenId the NFT token Id\n   * @param nftConfig The NFT data\n   * @param poolLoan The pool loan address\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The borrow amount, threshold price and liquidation price\n   **/\n  function calculateLoanLiquidatePrice(\n    uint256 loanId,\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address poolLoan,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalcLiquidatePriceLocalVars memory vars;\n\n    /*\n     * 0                   CR                  LH                  100\n     * |___________________|___________________|___________________|\n     *  <       Borrowing with Interest        <\n     * CR: Callteral Ratio;\n     * LH: Liquidate Threshold;\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\n     */\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\n \n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftConfig.getCollateralParams();\n\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getNFTPrice(nftAsset, nftTokenId);\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n\n    vars.nftPriceInReserve = ((10 ** vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\n\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\n\n    vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\n\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\n  }\n\n  struct CalcLoanBidFineLocalVars {\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 baseBidFineInReserve;\n    uint256 minBidFinePct;\n    uint256 minBidFineInReserve;\n    uint256 bidFineInReserve;\n    uint256 debtAmount;\n  }\n\n  function calculateLoanBidFine(\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    address poolLoan,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    nftAsset;\n\n    if (loanData.bidPrice == 0) {\n      return (0, 0);\n    }\n\n    CalcLoanBidFineLocalVars memory vars;\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n    vars.baseBidFineInReserve = (1 ether * 10 ** vars.reserveDecimals) / vars.reservePriceInETH;\n\n    vars.minBidFinePct = nftConfig.getMinBidFine();\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\n\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\n\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftConfig.getRedeemFine());\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\n      vars.bidFineInReserve = vars.minBidFineInReserve;\n    }\n\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\n  }\n}\n","line":199,"range":[7478,7555]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":461,"range":[17747,17813]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,50,48,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033230320000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)



