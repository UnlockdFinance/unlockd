
> @unlockddao/unlockd-protocol@1.0.2 test:file
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/__setup.spec.ts ./test/${TEST_FILE}


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/Users/adri/work/unlockd-protocol-v1/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  goerli
  - Provider URL: eth-goerli.g.alchemy.com
  - Network : hardhat
Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 1000000.0 ETH
LendPool Liquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH


Migration started


Deploy Punks Market and Wrapped Punk
*** CryptoPunksMarket ***

Network: hardhat
tx: 0x67afc5b971d207e75f3498c82fc72d142659cf9e5d27e7ea60a251cc160db823
contract address: 0x1864c9342339c36588F7f31d1079690a7003c7a2
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000042103
gas used: 2378109

******

contracts-helpers:registerContractInJsonDb, contractId: CryptoPunksMarket address: 0x1864c9342339c36588F7f31d1079690a7003c7a2 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WrappedPunk ***

Network: hardhat
tx: 0xe728bedb02bee455dab430156f43961f57d5a9fe0ff3ae48a1aaf1095051e0c2
contract address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000038851
gas used: 1992593

******

contracts-helpers:registerContractInJsonDb, contractId: WrappedPunk address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy proxy admin
*** UnlockdProxyAdminPool ***

Network: hardhat
tx: 0xd8fe84a47275e5c108cc974c34fe7dc1fced7b74c87287816c1b5f4cc057cacf
contract address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000031139
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminPool address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
ProxyAdminPool Address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** UnlockdProxyAdminFund ***

Network: hardhat
tx: 0xf9687bddd351d5744b1d8accd8f7e7d49ccc45a61e6ff48c5df0902db09aeeeb
contract address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000027541
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminFund address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProxyAdminFund Address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy address provider
- Deploying new Address Provider:
*** LendPoolAddressesProvider ***

Network: hardhat
tx: 0x95ec82ad756e8b69365935e3afe679993fa59cd4945e510f9826e1b273560bab
contract address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000024359
gas used: 2978496

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProvider address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
- Deploying a new Address Provider Registry:
*** LendPoolAddressesProviderRegistry ***

Network: hardhat
tx: 0x74bc06db09d3fe7b338e23b7aac662665f927306555d151d4b08f603824ff54b
contract address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000022772
gas used: 502283

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProviderRegistry address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deployed Registry Address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Added LendPoolAddressesProvider with address "0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977" to registry located at 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
LSSVM ROUTER ADDRESS: 0x25b4EfC43c9dCAe134233CD577fFca7CfAd6748F
Pool Admin 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Emergency Admin 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3
LendPool Liquidator 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
SushiSwap Router 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506
NFTXVault Factory 0xe01Cf5099e700c282A56E815ABd0C4948298Afae


Deploy Incentives Controller
Deploying new Incentives Controller Implementation...
*** MockIncentivesController ***

Network: hardhat
tx: 0x13f2a4a181bd6e42bcfbed55b2948c24f6cbe8df18323014b8f9d5ef61219b07
contract address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000006991
gas used: 142669

******

contracts-helpers:registerContractInJsonDb, contractId: MockIncentivesController address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy UNFT Registry
Deploying new UnftRegistry implementation...
*** UNFT ***

Network: hardhat
tx: 0xdb1c1b9d5a05012416ff674516c86b3a9992ab294ea4362b5480c3c091d4c529
contract address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000005377
gas used: 1503057

******

contracts-helpers:registerContractInJsonDb, contractId: UNFT address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:insertContractAddressInDb, id: UNFTRegistryImpl address 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
*** UNFTRegistry ***

Network: hardhat
tx: 0x6538e206c72d4582502561e69be0633c125630beb0c077735834f3dc46f1d292
contract address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004868
gas used: 2441516

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Invalid Proxy Admin address in pool config. Trying to fetch from deployed contracts...
*** UNFTRegistry ***

Network: hardhat
tx: 0x8ce3f7e1d37f8d4b20cda5f3c5e9e8431dde1655ba18687d5a6f95a52278694b
contract address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004499
gas used: 740488

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UNFT created successfully for token WPUNKS with address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UNFT Token: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 0xfC856EeEaE446258cc8f17C5421c507115dc912d
UNFT created successfully for token BAYC with address 0x9278420Bf7548970799c56ef9A0B081862515330
UNFT Token: 0x9278420Bf7548970799c56ef9A0B081862515330 0x06cF13D8aD87307d50540223D3A08f63CDF8A211


Deploy lend pool
Setting UNFTRegistry to address provider...
Setting IncentivesController to address provider...
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x38423594a581dece179ba4fa765fae61c3ba8cf96973b8e83d5b046ae5d0866c
contract address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000002131
gas used: 84278

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ReserveLogic ***

Network: hardhat
tx: 0x600484e35a44f4a615ffa58f3fcee7b8049f9f3cdf15dd65315ccbd9376dbd4e
contract address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001869
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** NftLogic ***

Network: hardhat
tx: 0xc17f90485ee1499cfbe95745defe40c7607d73c11588adfa41efb6a517ff36c7
contract address: 0x5c769753F192449c3c6AeC7BF2145928eb261699
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001642
gas used: 141022

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0x5c769753F192449c3c6AeC7BF2145928eb261699 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ValidationLogic ***

Network: hardhat
tx: 0x54d09ed96409fcef791c02c18994ce20c1ad991457f0b42135f9ea299445b9fc
contract address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001442
gas used: 1528605

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** SupplyLogic ***

Network: hardhat
tx: 0x061e122abff21426642167a8d08ac8c7434e0a1d02f540fe410cd07cb86c66d3
contract address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001307
gas used: 1184808

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** BorrowLogic ***

Network: hardhat
tx: 0xaf6bcaf880077ac8454be12eb41a588ace70e4ea55545c58dfab5266df762a33
contract address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001175
gas used: 2066318

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateLogic ***

Network: hardhat
tx: 0x4f2359412aaee5554478bf8bd30fc709cb05cce3e125cf537544809e656ea1d9
contract address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001077
gas used: 3804663

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0xcb87ba62ac8e24c3bbbb0060054bf7086c0129e82909e1940a178455de3f66da
contract address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001025
gas used: 2912395

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ConfiguratorLogic ***

Network: hardhat
tx: 0x0bc40510c4f7e488917b449ee06a7220c811f4a6e161158009b57015d7c72284
contract address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000957
gas used: 1970094

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
*** LendPool ***

Network: hardhat
tx: 0xa24ae86b348da36db114bd052e1706e8c5ef58f34430c13e568f64ceac959574
contract address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000876
gas used: 4943082

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool implementation with address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
contracts-helpers:insertContractAddressInDb, id: LendPool address 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
*** LendPoolLoan ***

Network: hardhat
tx: 0xdf5c741fc3efd48874e4421a195476ac03dc205313b7c77c05a291e47bf9ad08
contract address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000760
gas used: 3232544

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool loan implementation with address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0xa85e569EF873Cec2a82012C08057397F93aed686
*** LendPoolConfigurator ***

Network: hardhat
tx: 0x4af2d4056a4c31a7bf4973e4277eb426bb4d9e2f51f8b29f9bcd0ac1eab6eb39
contract address: 0xa85e569EF873Cec2a82012C08057397F93aed686
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000636
gas used: 5196741

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0xa85e569EF873Cec2a82012C08057397F93aed686 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool configurator implementation with address: 0xa85e569EF873Cec2a82012C08057397F93aed686
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
Deploying UToken implementation UToken
*** UToken ***

Network: hardhat
tx: 0xda067e27819460bf4530ca97357480c334cfd963e3391b2e7788353e9ea9965f
contract address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000485
gas used: 1927519

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** DebtToken ***

Network: hardhat
tx: 0xb6215056f685b9ff3fabb9d956d7ed0037988720030b5006bc3d031e813abd32
contract address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000444
gas used: 1366344

******

contracts-helpers:registerContractInJsonDb, contractId: DebtToken address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy reserve oracle
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0xd81cfDb25C4a27795c17A893F7813590614f2A90
*** ReserveOracle ***

Network: hardhat
tx: 0xc31ca987afd8de64f62fa188f4583970a3dfd7ca066e61acfbe91ff498c00985
contract address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000309
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x244b1a29ed9cbfe146bab6c3bf2bf7686c8a2b4279d6c2b51b9470644c2e7e59
contract address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000278
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Reserve Oracle: proxy 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD, implementation 0xd81cfDb25C4a27795c17A893F7813590614f2A90
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0xb63ad0ca591eba688df2f64f2c48acc633d6d927b67a88876bcc7193f56a7f77
contract address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000191
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xb32ecc23bc6325ad7578cee1ec42ab59f7ad7c59b8c91100a18f00b9f322f8e2
contract address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000152
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy nft oracle
contracts-helpers:insertContractAddressInDb, id: NFTOracleImpl address 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
*** NFTOracle ***

Network: hardhat
tx: 0x5fc3822aa20b47287c2e2b7abc95f3245085c0a802c0f86618f2be3ed085eb5e
contract address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000135
gas used: 1047527

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new nft oracle proxy & implementation...
*** NFTOracle ***

Network: hardhat
tx: 0x911173a3e4b074d1349b73126755e2a85e73c31d65ad51208fea3ae84e6ec85c
contract address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000121
gas used: 712030

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
NFT Oracle: proxy 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482, implementation 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0x4d11889fb4391938c1fc86bcf977bdf808b86b4b13cd8fc4e45ddd44b3a8b9ce
contract address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000065
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize lend pool
Init & Config Reserve assets
RESERVES: WETH,[object Object],DAI,[object Object],USDC,[object Object]
*** InterestRate ***

Network: hardhat
tx: 0x8022d3dfe2408dba196c66a666ae40b78d4047e338ade8a9179d19eb3453c89c
contract address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000052
gas used: 616243

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
*** InterestRate ***

Network: hardhat
tx: 0xc05aae48956baed2eaf66171d8647fc16e974ca0b4e9c4551cd4b9294e9426dd
contract address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000047
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableTwo address 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
*** InterestRate ***

Network: hardhat
tx: 0x1da49dba71ac0be209d4cd71e0a97737bd2e0b9b2f23e2d4dd20909e2e234086
contract address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000042
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableThree address 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
- Reserves initialization in 3 txs
  - Reserve ready for: WETH 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
    * gasUsed 1631513
  - Reserve ready for: DAI 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
    * gasUsed 1616353
  - Reserve ready for: USDC 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
    * gasUsed 1616413
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure Reserves
  - Params for WETH: 3000 true
  - Params for DAI: 3000 true
  - Params for USDC: 3000 true
- Configure reserves in 1 txs
  - batchConfigReserve for: WETH, DAI, USDC
Init & Config NFT assets
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- NFTs initialization in 2 txs
  - NFT ready for: WPUNKS 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
    * gasUsed 256961
  - NFT ready for: BAYC 0x9278420Bf7548970799c56ef9A0B081862515330
    * gasUsed 241669
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure NFTs
  - Params for WPUNKS: 4000 9000 500 24 24 500 5000 2000 10000 9999
  - Params for BAYC: 4000 9000 500 24 24 500 5000 2000 10000 9999
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- Configure NFTs in 4 txs
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC


Deploy WETH Gateway
contracts-helpers:insertContractAddressInDb, id: WETHGatewayImpl address 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
*** WETHGateway ***

Network: hardhat
tx: 0x8cf2757cda767afc83e34a00191f09959ee411836c6109719bf0865cae5d2cf5
contract address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 2587824

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WETHGateway ***

Network: hardhat
tx: 0xbcbd6a88cd7c774e27435a3e64e2576c32228e3ebe40cd0fc67340e0013ea837
contract address: 0x51bda59320165617F7209a38D08b11ccefF58F1a
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 745688

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x51bda59320165617F7209a38D08b11ccefF58F1a deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy PUNK Gateway
wethGateWay.address 0x51bda59320165617F7209a38D08b11ccefF58F1a
CryptoPunksMarket.address 0x1864c9342339c36588F7f31d1079690a7003c7a2
WPUNKS.address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
contracts-helpers:insertContractAddressInDb, id: PunkGatewayImpl address 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
*** PunkGateway ***

Network: hardhat
tx: 0xadda1fd531c22582b1bfee378c90018ec21615902a82e769dd9e5d2182c10554
contract address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 3290566

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new PunkGateway proxy & implementation...
*** PunkGateway ***

Network: hardhat
tx: 0x02a7165960142c887f825c0e37f39e3a337bd523ff638a14f2d7549ec0bb06e8
contract address: 0xb16101f4b859580B810b683264102c49e12d0732
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 998847

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xb16101f4b859580B810b683264102c49e12d0732 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize gateway
WETHGateway: authorizeLendPoolNFT: [
  '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
  '0x9278420Bf7548970799c56ef9A0B081862515330'
]
PunkGateway: authorizeLendPoolERC20: [
  '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6',
  '0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36',
  '0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557'
]


Deploy data provider
*** WalletBalanceProvider ***

Network: hardhat
tx: 0x9c48f63a209185fef70dfd98b8e9e7e0beda06150534e5ccfc00b50ddc087a88
contract address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 1251342

******

contracts-helpers:registerContractInJsonDb, contractId: WalletBalanceProvider address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
WalletBalancerProvider deployed at: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0xbea41fab6df21451f0c41b3348df9d8b06bd90481ab0aedda6567a89adf5c362
contract address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 2888605

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProtocolDataProvider deployed at: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
*** UIPoolDataProvider ***

Network: hardhat
tx: 0x6aa6a6554f4f39d634bd8ea55027e80f5109f15e52a21a5a49bd5eaa2729d3c4
contract address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 3116123

******

contracts-helpers:registerContractInJsonDb, contractId: UIPoolDataProvider address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UiPoolDataProvider deployed at: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 47
CryptoPunksMarket: 0x1864c9342339c36588F7f31d1079690a7003c7a2
WrappedPunk: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UnlockdProxyAdminPool: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
UnlockdProxyAdminFund: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
LendPoolAddressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
LendPoolAddressesProviderRegistry: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
MockIncentivesController: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
UnlockdProxyAdminTest: 0x8b89F971cA1A5dE1B7df7f554a3024eE84FeeB05
UNFT: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
UNFTRegistryImpl: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
UNFTRegistry: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
GenericLogic: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
ReserveLogic: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
NftLogic: 0x5c769753F192449c3c6AeC7BF2145928eb261699
ValidationLogic: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
SupplyLogic: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
BorrowLogic: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
LiquidateLogic: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
LiquidateMarketsLogic: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
ConfiguratorLogic: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
LendPoolImpl: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
LendPool: 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
LendPoolLoanImpl: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
LendPoolLoan: 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
LendPoolConfiguratorImpl: 0xa85e569EF873Cec2a82012C08057397F93aed686
LendPoolConfigurator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
UToken: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
DebtToken: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
ReserveOracleImpl: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
ReserveOracle: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
MockReserveOracle: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
MockChainlinkOracle: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
NFTOracleImpl: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
NFTOracle: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
MockNFTOracle: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
InterestRate: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
rateStrategyWETH: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
rateStrategyStableTwo: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
rateStrategyStableThree: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
WETHGatewayImpl: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
WETHGateway: 0x51bda59320165617F7209a38D08b11ccefF58F1a
PunkGatewayImpl: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
PunkGateway: 0xb16101f4b859580B810b683264102c49e12d0732
WalletBalanceProvider: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
UnlockdProtocolDataProvider: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
UIPoolDataProvider: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
SelfdestructTransferMock: 0x3C2AeD703EF55ABE3C9D1080418406Fae704bae0 

Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.917146815373146597
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.917146815373146597
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 999999.999817306911354971
LendPoolLiquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.917146815373146597
-> Initialize make suite...
uDai 0xa6388056eCA8e9546E68E58A17EF2D00c30B300E
uUSDC 0x1e217a095DbF898A732d8419aBBedf8b7df3AD8b
uWETH 0xf1b719001AccaC7666C8c987F4e3acBAeF6E1C45
daiAdd 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
usdcAdd 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
wethAdd 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
allUNftTokens [
  [
    'WPUNKS',
    '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    'UBoundWPUNKS',
    '0xfC856EeEaE446258cc8f17C5421c507115dc912d',
    nftSymbol: 'WPUNKS',
    nftAddress: '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    uNftSymbol: 'UBoundWPUNKS',
    uNftAddress: '0xfC856EeEaE446258cc8f17C5421c507115dc912d'
  ],
  [
    'BAYC',
    '0x9278420Bf7548970799c56ef9A0B081862515330',
    'UBoundBAYC',
    '0x06cF13D8aD87307d50540223D3A08f63CDF8A211',
    nftSymbol: 'BAYC',
    nftAddress: '0x9278420Bf7548970799c56ef9A0B081862515330',
    uNftSymbol: 'UBoundBAYC',
    uNftAddress: '0x06cF13D8aD87307d50540223D3A08f63CDF8A211'
  ]
]
0x9278420Bf7548970799c56ef9A0B081862515330

***************
Setup and snapshot finished
***************

  Configurator-NFT
    âœ“ Deactivates the BAYC NFT
    âœ“ Deactivates the BAYC NFT Token
    âœ“ Rectivates the BAYC NFT
    âœ“ Rectivates the BAYC NFT Token
    âœ“ Check the onlyAdmin on deactivateRNft 
    âœ“ Check the onlyAdmin on activateNft 
    âœ“ Freezes the BAYC NFT
    âœ“ Freezes the BAYC NFT Token
    âœ“ Unfreezes the BAYC NFT
    âœ“ Unfreezes the BAYC NFT Token
    âœ“ Check the onlyAdmin on freezeNft 
    âœ“ Check the onlyAdmin on unfreezeNft 
    âœ“ Deactivates the BAYC NFT as collateral
    âœ“ Activates the BAYC NFT as collateral
    âœ“ Check the onlyLtvManager on configureNftAsCollateral 

    1) Deactivates the BAYC NFT as auction

    2) Activates the BAYC NFT as auction
    âœ“ Check the onlyLtvManager on configureNftAsAuction 
    âœ“ Batch Deactivates the BAYC NFT as collateral
    âœ“ Batch Activates the BAYC NFT as collateral
    âœ“ Check the onlyAdmin on batchConfigNft 
    âœ“ Batch Deactivates the BAYC NFT as auction
    âœ“ Batch Activates the BAYC NFT as auction
    âœ“ Reverts when trying to disable the BAYC nft with liquidity on it
    âœ“ Config setMaxNumberOfNfts invalid value
    âœ“ Config setMaxNumberOfNfts invalid value overflowing
    âœ“ Check the onlyAdmin on setMaxNumberOfNfts 
    âœ“ Config the timeFrame for an X amount of time
    âœ“ Check if the config timestamp is correct
    âœ“ Check if general configurations are correct

Â·---------------------------------------------------------------------|---------------------------|-------------|-----------------------------Â·
|                         [90mSolc version: 0.8.4[39m                         Â·  [90mOptimizer enabled: true[39m  Â·  [90mRuns: 200[39m  Â·  [90mBlock limit: 12450000 gas[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mMethods[22m[39m                                                                                                                                    â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [1mContract[22m                           Â·  [1mMethod[22m                       Â·  [32mMin[39m        Â·  [32mMax[39m        Â·  [32mAvg[39m        Â·  [1m# calls[22m      Â·  [1meur (avg)[22m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m                  Â·  allInitialOwnersAssigned     Â·          -  Â·          -  Â·      45518  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCustomERC721[39m                       Â·  setApprovalForAll            Â·          -  Â·          -  Â·      46224  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCustomERC721[39m                       Â·  transferFrom                 Â·          -  Â·          -  Â·      96740  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m                   Â·  approve                      Â·          -  Â·          -  Â·      46135  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m                   Â·  transfer                     Â·          -  Â·          -  Â·      34659  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setAddress                   Â·          -  Â·          -  Â·      49033  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setEmergencyAdmin            Â·          -  Â·          -  Â·      47355  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setIncentivesController      Â·      [36m30275[39m  Â·      [31m47363[39m  Â·      38819  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolConfiguratorImpl  Â·          -  Â·          -  Â·     610449  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolImpl              Â·          -  Â·          -  Â·     698786  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolLiquidator        Â·          -  Â·          -  Â·      47443  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLendPoolLoanImpl          Â·          -  Â·          -  Â·     659480  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setLSSVMRouter               Â·          -  Â·          -  Â·      47442  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setNFTOracle                 Â·          -  Â·          -  Â·      47421  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setNFTXVaultFactory          Â·          -  Â·          -  Â·      47377  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setPoolAdmin                 Â·          -  Â·          -  Â·      47444  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setReserveOracle             Â·          -  Â·          -  Â·      47354  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setSushiSwapRouter           Â·          -  Â·          -  Â·      47399  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setUIDataProvider            Â·          -  Â·          -  Â·      47295  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setUNFTRegistry              Â·      [36m27476[39m  Â·      [31m47376[39m  Â·      37426  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setUnlockdDataProvider       Â·          -  Â·          -  Â·      47421  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m          Â·  setWalletBalanceProvider     Â·          -  Â·          -  Â·      47463  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProviderRegistry[39m  Â·  registerAddressesProvider    Â·          -  Â·          -  Â·      92000  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchConfigNft               Â·      [36m88006[39m  Â·    [31m1104812[39m  Â·     753310  Â·           [90m12[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchConfigReserve           Â·          -  Â·          -  Â·      97648  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchInitNft                 Â·     [36m241669[39m  Â·     [31m256961[39m  Â·     249315  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  batchInitReserve             Â·    [36m1616353[39m  Â·    [31m1631513[39m  Â·    1621426  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  configureNftsAsCollateral    Â·      [36m96929[39m  Â·     [31m133929[39m  Â·     112291  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setActiveFlagOnNft           Â·      [36m78169[39m  Â·      [31m83774[39m  Â·      80972  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setActiveFlagOnNftByTokenId  Â·      [36m69663[39m  Â·      [31m69675[39m  Â·      69669  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setBorrowingFlagOnReserve    Â·          -  Â·          -  Â·      66646  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setFreezeFlagOnNft           Â·      [36m66644[39m  Â·      [31m66657[39m  Â·      66651  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setFreezeFlagOnNftByTokenId  Â·      [36m69593[39m  Â·      [31m69605[39m  Â·      69599  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setLtvManagerStatus          Â·      [36m39630[39m  Â·      [31m59530[39m  Â·      49580  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m               Â·  setPoolPause                 Â·      [36m81475[39m  Â·     [31m101218[39m  Â·      91347  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  borrow                       Â·          -  Â·          -  Â·     763086  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  deposit                      Â·          -  Â·          -  Â·     228063  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m               Â·  setTimeframe                 Â·      [36m60988[39m  Â·      [31m78100[39m  Â·      69547  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  addCollection                Â·          -  Â·          -  Â·      54843  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  initialize                   Â·          -  Â·          -  Â·     113794  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m                      Â·  setPriceManagerStatus        Â·          -  Â·          -  Â·      33894  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  initialize                   Â·          -  Â·          -  Â·      90917  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m                  Â·  setAggregators               Â·          -  Â·          -  Â·     196520  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                        Â·  authorizeLendPoolERC20       Â·          -  Â·          -  Â·     157809  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mSelfdestructTransfer[39m               Â·  destroyAndTransfer           Â·          -  Â·          -  Â·      29265  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mUNFTRegistry[39m                       Â·  createUNFT                   Â·     [36m725406[39m  Â·     [31m742551[39m  Â·     733979  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                        Â·  authorizeLendPoolNFT         Â·          -  Â·          -  Â·      99328  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mDeployments[22m[39m                                                        Â·                                         Â·  [1m% of limit[22m   Â·             â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  BorrowLogic                                                        Â·          -  Â·          -  Â·    2066318  Â·       [90m16.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ConfiguratorLogic                                                  Â·          -  Â·          -  Â·    1970094  Â·       [90m15.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  CryptoPunksMarket                                                  Â·          -  Â·          -  Â·    2378109  Â·       [90m19.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  DebtToken                                                          Â·          -  Â·          -  Â·    1366344  Â·         [90m11 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  GenericLogic                                                       Â·          -  Â·          -  Â·      84278  Â·        [90m0.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  InterestRate                                                       Â·     [36m616243[39m  Â·     [31m616255[39m  Â·     616251  Â·        [90m4.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPool                                                           Â·          -  Â·          -  Â·    4943082  Â·       [90m39.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolAddressesProvider                                          Â·          -  Â·          -  Â·    2978496  Â·       [90m23.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolAddressesProviderRegistry                                  Â·          -  Â·          -  Â·     502283  Â·          [90m4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolConfigurator                                               Â·          -  Â·          -  Â·    5196741  Â·       [90m41.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolLoan                                                       Â·          -  Â·          -  Â·    3232544  Â·         [90m26 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LiquidateLogic                                                     Â·          -  Â·          -  Â·    3804663  Â·       [90m30.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LiquidateMarketsLogic                                              Â·          -  Â·          -  Â·    2912395  Â·       [90m23.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockChainlinkOracle                                                Â·          -  Â·          -  Â·     620122  Â·          [90m5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockIncentivesController                                           Â·          -  Â·          -  Â·     142669  Â·        [90m1.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockNFTOracle                                                      Â·          -  Â·          -  Â·    1117453  Â·          [90m9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockReserveOracle                                                  Â·          -  Â·          -  Â·    1280668  Â·       [90m10.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  NftLogic                                                           Â·          -  Â·          -  Â·     141022  Â·        [90m1.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  NFTOracle                                                          Â·          -  Â·          -  Â·    1047527  Â·        [90m8.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  PunkGateway                                                        Â·          -  Â·          -  Â·    3290566  Â·       [90m26.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ReserveLogic                                                       Â·          -  Â·          -  Â·     171208  Â·        [90m1.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ReserveOracle                                                      Â·          -  Â·          -  Â·    1211618  Â·        [90m9.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  SelfdestructTransfer                                               Â·          -  Â·          -  Â·      88001  Â·        [90m0.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  SupplyLogic                                                        Â·          -  Â·          -  Â·    1184808  Â·        [90m9.5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UiPoolDataProvider                                                 Â·          -  Â·          -  Â·    3116123  Â·         [90m25 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UNFT                                                               Â·          -  Â·          -  Â·    1503057  Â·       [90m12.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UNFTRegistry                                                       Â·          -  Â·          -  Â·    2441516  Â·       [90m19.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdProtocolDataProvider                                        Â·          -  Â·          -  Â·    2888605  Â·       [90m23.2 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdProxyAdmin                                                  Â·          -  Â·          -  Â·     470704  Â·        [90m3.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdUpgradeableProxy                                            Â·     [36m689038[39m  Â·     [31m998847[39m  Â·     777218  Â·        [90m6.2 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UToken                                                             Â·          -  Â·          -  Â·    1927519  Â·       [90m15.5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ValidationLogic                                                    Â·          -  Â·          -  Â·    1528605  Â·       [90m12.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  WalletBalanceProvider                                              Â·          -  Â·          -  Â·    1251342  Â·       [90m10.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  WETHGateway                                                        Â·          -  Â·          -  Â·    2587824  Â·       [90m20.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  WrappedPunk                                                        Â·          -  Â·          -  Â·    1992593  Â·         [90m16 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·---------------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------Â·

  28 passing (23s)
  2 failing

  1) Configurator-NFT
       Deactivates the BAYC NFT as auction:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '107'", method="estimateGas", transaction={"from":"0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15","to":"0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A","data":"0x095213a30000000000000000000000009278420bf7548970799c56ef9a0b0818625153300000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"configureNftAsAuction","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":424,"range":[14802,15666]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyPoolAdmin","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":40,"range":[1795,1881]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,49,48,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130370000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)

  2) Configurator-NFT
       Activates the BAYC NFT as auction:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '107'", method="estimateGas", transaction={"from":"0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15","to":"0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A","data":"0x095213a30000000000000000000000009278420bf7548970799c56ef9a0b0818625153300000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"configureNftAsAuction","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":424,"range":[14802,15666]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyPoolAdmin","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":40,"range":[1795,1881]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,49,48,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130370000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)



