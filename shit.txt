
> @unlockddao/unlockd-protocol@1.0.2 test
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/*.spec.ts


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/Users/adri/work/unlockd-protocol-v1/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  goerli
  - Provider URL: eth-goerli.g.alchemy.com
  - Network : hardhat
Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 1000000.0 ETH
LendPool Liquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH


Migration started


Deploy Punks Market and Wrapped Punk
*** CryptoPunksMarket ***

Network: hardhat
tx: 0x67afc5b971d207e75f3498c82fc72d142659cf9e5d27e7ea60a251cc160db823
contract address: 0x1864c9342339c36588F7f31d1079690a7003c7a2
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000042103
gas used: 2378109

******

contracts-helpers:registerContractInJsonDb, contractId: CryptoPunksMarket address: 0x1864c9342339c36588F7f31d1079690a7003c7a2 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WrappedPunk ***

Network: hardhat
tx: 0xe728bedb02bee455dab430156f43961f57d5a9fe0ff3ae48a1aaf1095051e0c2
contract address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000038851
gas used: 1992593

******

contracts-helpers:registerContractInJsonDb, contractId: WrappedPunk address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy proxy admin
*** UnlockdProxyAdminPool ***

Network: hardhat
tx: 0xd8fe84a47275e5c108cc974c34fe7dc1fced7b74c87287816c1b5f4cc057cacf
contract address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000031139
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminPool address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
ProxyAdminPool Address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** UnlockdProxyAdminFund ***

Network: hardhat
tx: 0xf9687bddd351d5744b1d8accd8f7e7d49ccc45a61e6ff48c5df0902db09aeeeb
contract address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000027541
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminFund address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProxyAdminFund Address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy address provider
- Deploying new Address Provider:
*** LendPoolAddressesProvider ***

Network: hardhat
tx: 0x2d2851ab2b937bf38bd23645e2f23fb9b278acd1041b1ddc3934ee1eef6412aa
contract address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000024359
gas used: 2978496

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProvider address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
- Deploying a new Address Provider Registry:
*** LendPoolAddressesProviderRegistry ***

Network: hardhat
tx: 0xf350605065cb33d0d48da55a91d75c05e9a80658f9b818c9861c89172e257d5f
contract address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000022772
gas used: 502283

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProviderRegistry address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deployed Registry Address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Added LendPoolAddressesProvider with address "0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977" to registry located at 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
LSSVM ROUTER ADDRESS: 0x25b4EfC43c9dCAe134233CD577fFca7CfAd6748F
Pool Admin 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Emergency Admin 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3
LendPool Liquidator 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
SushiSwap Router 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506
NFTXVault Factory 0xe01Cf5099e700c282A56E815ABd0C4948298Afae


Deploy Incentives Controller
Deploying new Incentives Controller Implementation...
*** MockIncentivesController ***

Network: hardhat
tx: 0x13f2a4a181bd6e42bcfbed55b2948c24f6cbe8df18323014b8f9d5ef61219b07
contract address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000006991
gas used: 142669

******

contracts-helpers:registerContractInJsonDb, contractId: MockIncentivesController address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy UNFT Registry
Deploying new UnftRegistry implementation...
*** UNFT ***

Network: hardhat
tx: 0xdb1c1b9d5a05012416ff674516c86b3a9992ab294ea4362b5480c3c091d4c529
contract address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000005377
gas used: 1503057

******

contracts-helpers:registerContractInJsonDb, contractId: UNFT address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:insertContractAddressInDb, id: UNFTRegistryImpl address 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
*** UNFTRegistry ***

Network: hardhat
tx: 0x6538e206c72d4582502561e69be0633c125630beb0c077735834f3dc46f1d292
contract address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004868
gas used: 2441516

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Invalid Proxy Admin address in pool config. Trying to fetch from deployed contracts...
*** UNFTRegistry ***

Network: hardhat
tx: 0x7effe466cacfb2236a2e3e51c11335370dbbfc2af0edbb3b6b9d45568b2b4ed2
contract address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004499
gas used: 740488

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UNFT created successfully for token WPUNKS with address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UNFT Token: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 0xfC856EeEaE446258cc8f17C5421c507115dc912d
UNFT created successfully for token BAYC with address 0x9278420Bf7548970799c56ef9A0B081862515330
UNFT Token: 0x9278420Bf7548970799c56ef9A0B081862515330 0x06cF13D8aD87307d50540223D3A08f63CDF8A211


Deploy lend pool
Setting UNFTRegistry to address provider...
Setting IncentivesController to address provider...
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x50be9fb2adfb68f71fc41542a9b63367140c7fdc4e0700b160196af1c998d844
contract address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000002131
gas used: 84290

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ReserveLogic ***

Network: hardhat
tx: 0xbcd5f851e240b1ad9cd74d6b2a4d270e9fb137d96bbb9dd901777352fe2f8f4d
contract address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001869
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** NftLogic ***

Network: hardhat
tx: 0x22eae7d101e8f18127afd75978147bfd36b35bb70eec9701f4638531ca9a8a3c
contract address: 0x5c769753F192449c3c6AeC7BF2145928eb261699
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001642
gas used: 141010

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0x5c769753F192449c3c6AeC7BF2145928eb261699 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ValidationLogic ***

Network: hardhat
tx: 0xf93491a2191e77cd1119ad51545680cace92888274d5dd88acc80c3a9a2c322b
contract address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001442
gas used: 1530121

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** SupplyLogic ***

Network: hardhat
tx: 0x52ad6561a6644188456903398271de7a8fe8bd15385e5f03e983f19d5762546f
contract address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001307
gas used: 1184796

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** BorrowLogic ***

Network: hardhat
tx: 0xbae4c097cf71fcf952da0b99faaed50b2d49dc0349e64f5fc528cc5b1d560fe3
contract address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001175
gas used: 2066318

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateLogic ***

Network: hardhat
tx: 0x19aa1b5d2c35376888c538cef2430cb61ff40afb6d018b24d72fcdab79855557
contract address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001077
gas used: 3939677

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0x9e958ebcd47d6512f95c1c251dbee57e46d279daa06c9513e16fe3a454ea1da5
contract address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001028
gas used: 2995275

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ConfiguratorLogic ***

Network: hardhat
tx: 0xc36e97dfe58f20df08877fdcb0056b447b821e82de1d6dd94b24d195dffc2f4e
contract address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000962
gas used: 1970094

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
*** LendPool ***

Network: hardhat
tx: 0x4535c1451188553d96b3f7cc8d52165f3871010795b009ddaeda505d8d121512
contract address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000880
gas used: 5095759

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool implementation with address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
contracts-helpers:insertContractAddressInDb, id: LendPool address 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
*** LendPoolLoan ***

Network: hardhat
tx: 0x3c47420198582059161a31da1bd22aba04c83d5a25bd14063abd469a9dbccd6d
contract address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000766
gas used: 3262299

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool loan implementation with address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0xa85e569EF873Cec2a82012C08057397F93aed686
*** LendPoolConfigurator ***

Network: hardhat
tx: 0xf3a5025fe878cf72b1c1d6f5cbd7557dc5cf797dd039fb8aea8a23d3e6adcdbf
contract address: 0xa85e569EF873Cec2a82012C08057397F93aed686
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000641
gas used: 5346518

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0xa85e569EF873Cec2a82012C08057397F93aed686 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool configurator implementation with address: 0xa85e569EF873Cec2a82012C08057397F93aed686
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
Deploying UToken implementation UToken
*** UToken ***

Network: hardhat
tx: 0xec8ad84bf15f5095ffa6a770f5366fd1fadce3749becc457927d23427928a801
contract address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000491
gas used: 1983088

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** DebtToken ***

Network: hardhat
tx: 0x3d437fb6461d97e7afeec5374a3cedbf3ba5dc2daeef669f947fd1ae80660c8c
contract address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000450
gas used: 1366344

******

contracts-helpers:registerContractInJsonDb, contractId: DebtToken address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy reserve oracle
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0xd81cfDb25C4a27795c17A893F7813590614f2A90
*** ReserveOracle ***

Network: hardhat
tx: 0x204cccc22c382758535e6c1abb54ff8547f3d05b9e04d52a7a173d65301c034b
contract address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000313
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x3b00956f251d62ec5ecb8e9bc89e6a7ccf60812ef29dee172f8fd61461ca4889
contract address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000282
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Reserve Oracle: proxy 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD, implementation 0xd81cfDb25C4a27795c17A893F7813590614f2A90
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0x9690b60248da3cd6e53f0c4afa423109a5429c35ba3b3cb34ab1994eca1ec904
contract address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000194
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xab9163c6b945317e85eed4498822eb591a6c4bda662f15bb3e922e95cccd3694
contract address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000154
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy nft oracle
contracts-helpers:insertContractAddressInDb, id: NFTOracleImpl address 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
*** NFTOracle ***

Network: hardhat
tx: 0xb060ae12c18612015c12c110ba4aba551d73c1b821d4e5f13d8c350d41304ce5
contract address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000137
gas used: 1047527

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new nft oracle proxy & implementation...
*** NFTOracle ***

Network: hardhat
tx: 0xd3266ca8a44039d60bb99540199f42180a40e850a307ef3c3effa2eafd8ac0f3
contract address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000123
gas used: 712030

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
NFT Oracle: proxy 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482, implementation 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0x2e8ea41966be8b0994b0a80df72e371148f1b831feacaf460bb584c575f03227
contract address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000066
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize lend pool
Init & Config Reserve assets
RESERVES: WETH,[object Object],DAI,[object Object],USDC,[object Object]
*** InterestRate ***

Network: hardhat
tx: 0xf513aa90999a147e235e0cc4b29e1e86c02f7dce61616e086bb7db31a6f8c9b2
contract address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000053
gas used: 616243

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
*** InterestRate ***

Network: hardhat
tx: 0xbc625206726bbac5dc3ac44b3a05df3176a0722250728f789e2f4533305080da
contract address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000048
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableTwo address 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
*** InterestRate ***

Network: hardhat
tx: 0xb7cd213fb503d54c1764b0f9072cab7e410bbee2bc50fa5ae2f14bd83df974d8
contract address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000043
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableThree address 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
- Reserves initialization in 3 txs
  - Reserve ready for: WETH 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
    * gasUsed 1631536
  - Reserve ready for: DAI 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
    * gasUsed 1616376
  - Reserve ready for: USDC 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
    * gasUsed 1616436
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure Reserves
  - Params for WETH: 3000 true
  - Params for DAI: 3000 true
  - Params for USDC: 3000 true
- Configure reserves in 1 txs
  - batchConfigReserve for: WETH, DAI, USDC
Init & Config NFT assets
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- NFTs initialization in 2 txs
  - NFT ready for: WPUNKS 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
    * gasUsed 256916
  - NFT ready for: BAYC 0x9278420Bf7548970799c56ef9A0B081862515330
    * gasUsed 241624
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure NFTs
  - Params for WPUNKS: 4000 9000 500 24 24 500 5000 2000 10000 9999
  - Params for BAYC: 4000 9000 500 24 24 500 5000 2000 10000 9999
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- Configure NFTs in 4 txs
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC


Deploy WETH Gateway
contracts-helpers:insertContractAddressInDb, id: WETHGatewayImpl address 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
*** WETHGateway ***

Network: hardhat
tx: 0x0e0d66bf5cfc006340d5cd7606fd834b2f71e5f4f9b58581a4e9130af1a70692
contract address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 2420738

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WETHGateway ***

Network: hardhat
tx: 0x6d03cbac55cae78ab06141f97990448af35b27a6542ffa3fb3b14d4858d4bdd2
contract address: 0x51bda59320165617F7209a38D08b11ccefF58F1a
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 745667

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x51bda59320165617F7209a38D08b11ccefF58F1a deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy PUNK Gateway
wethGateWay.address 0x51bda59320165617F7209a38D08b11ccefF58F1a
CryptoPunksMarket.address 0x1864c9342339c36588F7f31d1079690a7003c7a2
WPUNKS.address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
contracts-helpers:insertContractAddressInDb, id: PunkGatewayImpl address 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
*** PunkGateway ***

Network: hardhat
tx: 0xeb14ee86a92c1b32de1bf47652dbe2c7baf42187bae35ff683165b7f1f4c391d
contract address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 3304310

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new PunkGateway proxy & implementation...
*** PunkGateway ***

Network: hardhat
tx: 0xe497468701478e9cb6329a257808193d7df117faab927e83f8c131c646f75b00
contract address: 0xb16101f4b859580B810b683264102c49e12d0732
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 998847

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xb16101f4b859580B810b683264102c49e12d0732 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize gateway
WETHGateway: authorizeLendPoolNFT: [
  '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
  '0x9278420Bf7548970799c56ef9A0B081862515330'
]
PunkGateway: authorizeLendPoolERC20: [
  '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6',
  '0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36',
  '0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557'
]


Deploy data provider
*** WalletBalanceProvider ***

Network: hardhat
tx: 0xf84aea80d4991194695f64a52794c3930c48ad30a7e270d22ec0952d0d430bd4
contract address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 1251342

******

contracts-helpers:registerContractInJsonDb, contractId: WalletBalanceProvider address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
WalletBalancerProvider deployed at: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0xff36285743a6aea6935ac2fe7a7537ad09ea118b87d92e332d65323b00eb4a49
contract address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 2888605

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProtocolDataProvider deployed at: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
*** UIPoolDataProvider ***

Network: hardhat
tx: 0x1f4938a06a35a4840f691ec5197dbcd79272757ead4de68ad62954be068dc89a
contract address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 3116123

******

contracts-helpers:registerContractInJsonDb, contractId: UIPoolDataProvider address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UiPoolDataProvider deployed at: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 47
CryptoPunksMarket: 0x1864c9342339c36588F7f31d1079690a7003c7a2
WrappedPunk: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UnlockdProxyAdminPool: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
UnlockdProxyAdminFund: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
LendPoolAddressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
LendPoolAddressesProviderRegistry: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
MockIncentivesController: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
UnlockdProxyAdminTest: 0x8b89F971cA1A5dE1B7df7f554a3024eE84FeeB05
UNFT: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
UNFTRegistryImpl: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
UNFTRegistry: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
GenericLogic: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
ReserveLogic: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
NftLogic: 0x5c769753F192449c3c6AeC7BF2145928eb261699
ValidationLogic: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
SupplyLogic: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
BorrowLogic: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
LiquidateLogic: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
LiquidateMarketsLogic: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
ConfiguratorLogic: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
LendPoolImpl: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
LendPool: 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
LendPoolLoanImpl: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
LendPoolLoan: 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
LendPoolConfiguratorImpl: 0xa85e569EF873Cec2a82012C08057397F93aed686
LendPoolConfigurator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
UToken: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
DebtToken: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
ReserveOracleImpl: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
ReserveOracle: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
MockReserveOracle: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
MockChainlinkOracle: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
NFTOracleImpl: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
NFTOracle: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
MockNFTOracle: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
InterestRate: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
rateStrategyWETH: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
rateStrategyStableTwo: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
rateStrategyStableThree: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
WETHGatewayImpl: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
WETHGateway: 0x51bda59320165617F7209a38D08b11ccefF58F1a
PunkGatewayImpl: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
PunkGateway: 0xb16101f4b859580B810b683264102c49e12d0732
WalletBalanceProvider: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
UnlockdProtocolDataProvider: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
UIPoolDataProvider: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
SelfdestructTransferMock: 0xC8bcB2Fd3EA4D38BC62663Cf782805724eFa6Bb0 

Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.91669127871942287
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.91669127871942287
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 999999.999817306910258813
LendPoolLiquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.91669127871942287
-> Initialize make suite...
uDai 0xa6388056eCA8e9546E68E58A17EF2D00c30B300E
uUSDC 0x1e217a095DbF898A732d8419aBBedf8b7df3AD8b
uWETH 0xf1b719001AccaC7666C8c987F4e3acBAeF6E1C45
daiAdd 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
usdcAdd 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
wethAdd 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
allUNftTokens [
  [
    'WPUNKS',
    '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    'UBoundWPUNKS',
    '0xfC856EeEaE446258cc8f17C5421c507115dc912d',
    nftSymbol: 'WPUNKS',
    nftAddress: '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    uNftSymbol: 'UBoundWPUNKS',
    uNftAddress: '0xfC856EeEaE446258cc8f17C5421c507115dc912d'
  ],
  [
    'BAYC',
    '0x9278420Bf7548970799c56ef9A0B081862515330',
    'UBoundBAYC',
    '0x06cF13D8aD87307d50540223D3A08f63CDF8A211',
    nftSymbol: 'BAYC',
    nftAddress: '0x9278420Bf7548970799c56ef9A0B081862515330',
    uNftSymbol: 'UBoundBAYC',
    uNftAddress: '0x06cF13D8aD87307d50540223D3A08f63CDF8A211'
  ]
]
0x9278420Bf7548970799c56ef9A0B081862515330

***************
Setup and snapshot finished
***************

  ReserveOracle
    ✓ ReserveOracle: Add Aggregator
    ✓ ReserveOracle: Remove Aggregator
    ✓ ReserveOracle: get latest price
    ✓ ReserveOracle: get eth price
    ✓ ReserveOracle: get latest timestamp
    ReserveOracle-TWAP
      ✓ twap price
      ✓ asking interval more than asset has
      ✓ asking interval less than asset has
      ✓ given variant price period
      ✓ latest price update time is earlier than the request, return the latest price
      ✓ get 0 while interval is zero

  LendPoolAddressesProvider
    ✓ Test the accessibility of the LendPoolAddressesProvider
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0xc32B56a82144E29725978E8e90c96aA015B87b93
*** LendPool ***

Network: hardhat
tx: 0x78208dc2ecb5c354cca3ed9ae0a5fd34e2e977366712e3a2b609c860bef11b99
contract address: 0xc32B56a82144E29725978E8e90c96aA015B87b93
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 5095759

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0xc32B56a82144E29725978E8e90c96aA015B87b93 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    ✓ Tests adding a proxied address with `setAddressAsProxy()`
    ✓ Tests adding a non proxied address with `setAddress()`
    ✓ Tests specific non-proxied addresses set via `setAddress()`

  LendPool: Borrow/repay test cases
    ✓ Delegatee try to Borrow WETH to different onBehalf

  LendPool: Borrow negative test cases
    ✓ Users 0 Deposits 100 WETH and user 1 tries to borrow 0 WETH (revert expected)
    ✓ User 1 tries to use underpriced NFT as collateral to borrow 100 WETH (revert expected)
    ✓ User 2 tries to uses user 1 owned NFT as collateral to borrow 10 WETH (revert expected)
    ✓ Tries to uses NFT which id exceed max limit as collateral to borrow 10 WETH (revert expected)
    ✓ Users 0 Deposits 100 WETH and user 1 tries to borrow but the timestamp exceeds

  LendPool: Borrow/repay test cases
    ✓ User 2 deposits 1 WETH and 1000 DAI to account for rounding errors
    ✓ User 0 deposits 100 WETH, user 1 uses NFT as collateral and borrows 1 WETH
    ✓ User 1 uses existed collateral and borrows more 100 DAI (revert expected)
    ✓ User 1 uses existed collateral and borrows more 2 WETH
    ✓ User 1 tries to borrow more than the rest of the WETH liquidity (revert expected)
    ✓ User 1 tries to repay 0 WETH (revert expected)
    ✓ User 1 repays 0.5 WETH, enough to cover a small part of the interest
    ✓ User 1 repays all WETH borrow after one year
    ✓ User 0 withdraws the deposited WETH plus interest
    ✓ User 1 deposits 1 USDC to account for rounding errors
    ✓ User 1 deposits 1000 USDC, user 3 uses not owned NFT as collateral and borrows 10 USDC
    ✓ user 2 uses owned NFT as collateral on behalf of user 3 and borrows 10 USDC
    ✓ user 2 uses existed collateral on behalf of user 3 and borrows more 20 USDC
    ✓ user 3 repay 10 USDC, a fraction of borrow amount
    ✓ user 3 repay all USDC, full of borrow amount

  Configurator-NFT
    ✓ Deactivates the BAYC NFT
    ✓ Deactivates the BAYC NFT Token
    ✓ Rectivates the BAYC NFT
    ✓ Rectivates the BAYC NFT Token
    ✓ Check the onlyAdmin on deactivateRNft 
    ✓ Check the onlyAdmin on activateNft 
    ✓ Freezes the BAYC NFT
    ✓ Freezes the BAYC NFT Token
    ✓ Unfreezes the BAYC NFT
    ✓ Unfreezes the BAYC NFT Token
    ✓ Check the onlyAdmin on freezeNft 
    ✓ Check the onlyAdmin on unfreezeNft 
    ✓ Deactivates the BAYC NFT as collateral
    ✓ Activates the BAYC NFT as collateral
    ✓ Check the onlyLtvManager on configureNftAsCollateral 
    ✓ Deactivates the BAYC NFT as auction
    ✓ Activates the BAYC NFT as auction
    ✓ Check the onlyLtvManager on configureNftAsAuction 
    ✓ Batch Deactivates the BAYC NFT as collateral
    ✓ Batch Activates the BAYC NFT as collateral
    ✓ Check the onlyAdmin on batchConfigNft 
    ✓ Batch Deactivates the BAYC NFT as auction
    ✓ Batch Activates the BAYC NFT as auction
    ✓ Reverts when trying to disable the BAYC nft with liquidity on it
    ✓ Config setMaxNumberOfNfts invalid value
    ✓ Config setMaxNumberOfNfts invalid value overflowing
    ✓ Check the onlyAdmin on setMaxNumberOfNfts 
    ✓ Config the timeFrame for an X amount of time
    ✓ Check if the config timestamp is correct
    ✓ Check if general configurations are correct
    ✓ Check the onlyAdmin on set treasury to new utoken
    ✓ Check the zero check on set treasury to new utoken
    ✓ Check the address is properly updated in WETH uToken
    ✓ Check the zero check on set rescuer
    ✓ (LendPool): Check the only pool admin in safe health factor 
    ✓ (LendPool): Check invalid 0 value in safe health factor 
    ✓ (LendPool): Check correct value in safe health factor 

  Configurator-Reserve
    ✓ Reverts trying to set an invalid reserve factor
    ✓ Deactivates the ETH reserve
    ✓ Rectivates the ETH reserve
    ✓ Check the onlyAdmin on deactivateReserve 
    ✓ Check the onlyAdmin on activateReserve 
    ✓ Freezes the ETH reserve
    ✓ Unfreezes the ETH reserve
    ✓ Check the onlyAdmin on freezeReserve 
    ✓ Check the onlyAdmin on unfreezeReserve 
    ✓ Deactivates the ETH reserve for borrowing
    ✓ Activates the ETH reserve for borrowing
    ✓ Check the onlyAdmin on disableBorrowingOnReserve 
    ✓ Check the onlyAdmin on enableBorrowingOnReserve 
    ✓ Changes the reserve factor of WETH
    ✓ Check the onlyLendPoolManager on setReserveFactor
    ✓ Batch Changes the reserve factor of WETH & DAI
    ✓ Check the onlyPoolAdmin on batchConfigReserve
    ✓ Reverts when trying to disable the DAI reserve with liquidity on it
    ✓ Config setMaxNumberOfReserves valid value
    ✓ Config setMaxNumberOfReserves invalid value
    ✓ Config setMaxNumberOfReserves invalid value overflow
    ✓ Check the onlyAdmin on setMaxNumberOfReserves 

  DataProvider
    ✓ Borrows WETH using 1 BAYC
    ✓ Query UI Reserve Data
    ✓ Query UI NFT Data
    ✓ Query UI Loan Data
    ✓ Query Wallet Reserve Data
    ✓ Query Wallet NFT Data

  LendPool: Deposit
    ✓ User 0 Deposits 1000 DAI in an empty reserve
    ✓ User 1 deposits 1000 DAI after user 0
    ✓ User 0 deposits 1000 USDC in an empty reserve
    ✓ User 1 deposits 1000 USDC after user 0
    ✓ User 0 deposits 1 WETH in an empty reserve
    ✓ User 1 deposits 1 WETH after user 0
    ✓ User 1 deposits 0 WETH (revert expected)
    ✓ User 1 deposits 0 DAI (revert expected)
    ✓ User 1 deposits 100 DAI on behalf of user 2, user 2 tries to borrow 0.01 WETH

  Interest rate tests
*** InterestRate ***

Network: hardhat
tx: 0x9ec6d7eaa3be56eb5b25ba4988681e6e3304ce9dca0dfb4976eab3c877e128c3
contract address: 0x63A425c53CDA1415F8efE54e57cC507c756b96f2
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x63A425c53CDA1415F8efE54e57cC507c756b96f2 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    ✓ Checks rates at 0% utilization rate, empty reserve
    ✓ Checks rates at 80% utilization rate
    ✓ Checks rates at 100% utilization rate

  LendPool: Malicious Hacker Rentrant
hacker do reentrant action: ACTION_DEPOSIT
hacker do reentrant action: ACTION_WITHDRAW
hacker do reentrant action: ACTION_BORROW
hacker do reentrant action: ACTION_REPAY
hacker do reentrant action: ACTION_AUCTION
hacker do reentrant action: ACTION_REDEEM
hacker do reentrant action: ACTION_LIQUIDATE_NFTX
    ✓ Malicious hacker try to reentrant (should revert)

  LendPool: Liquidation negative test cases
    ✓ User 0 deposit 100 WETH, user 1 mint NFT and borrow 10 WETH
    ✓ User 1 liquidate on a non-existent NFT
    ✓ User 2 auction on a loan health factor above 1
    ✓ Drop loan health factor below 1
    ✓ User 2 auction price is unable to cover borrow
    ✓ User 2 auction price is less than liquidate price
    ✓ User 2 auction price is enough to cover borrow and liqudiate price
    ✓ User 3 auction price is lesser than user 2
    ✓ User 2 liquidate before auction duration is end
    ✓ User 1 redeem but bidFine is not fullfil to borrow amount of user 2 auction
    ✓ User 1 redeem but amount is not fullfil to mininum repay amount
    ✓ User 1 redeem but amount is not fullfil to maximum repay amount
    ✓ Ends redeem duration
    ✓ User 1 redeem after duration is end
    ✓ Ends auction duration
    ✓ User 3 auction after duration is end
    ✓ User 2 auction consecutively

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Auctions the borrow
    ✓ WETH - Can't liquidate on NFTX due to invalid loan state
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1
    ✓ USDC - Auctions the borrow at first time
    ✓ USDC - Auctions the borrow at second time with higher price
    ✓ USDC - Can't liquidate on NFTX

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1

  LendPool: Redeem
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Auctions the borrow
    ✓ WETH - Redeems the borrow
    ✓ WETH - Repays the borrow
    ✓ DAI - Borrows DAI
    ✓ DAI - Drop the health factor below 1
    ✓ DAI - Auctions the borrow
    ✓ DAI - Redeems the borrow
    ✓ DAI - Repays the borrow

  LendPool: Liquidation on SudoSwap
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Liquidates the borrow on SudoSwap
    ✓ DAI - Borrows DAI
    ✓ DAI - Drop the health factor below 1
    ✓ DAI - Liquidates the borrow on SudoSwap

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Auctions the borrow
    ✓ WETH - Liquidates the borrow
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1
    ✓ USDC - Auctions the borrow at first time
    ✓ USDC - Auctions the borrow at second time with higher price
    ✓ USDC - Liquidates the borrow

  LendPoolLoan: Modifiers
    ✓ Tries to invoke initNft not being the Pool
    ✓ Tries to invoke createLoan not being the Pool
    ✓ Tries to invoke updateLoan not being the Pool
    ✓ Tries to invoke repayLoan not being the Pool
    ✓ Tries to invoke auctionLoan not being the Pool
    ✓ Tries to invoke redeemLoan not being the Pool
    ✓ Tries to invoke liquidateLoan not being the Pool
    ✓ Tries to invoke liquidateLoanNFTX not being the Pool

  NFTOracle: General functioning
    ✓ Set Admin correctly
    ✓ Set and get Mocknft price at 1000
    ✓ Add 2 Multi Assets
    ✓ Add 3 Multi Assets
    ✓ Add 3 Multi Assets - BigNumbers
    ✓ Single asset price updates
    ✓ Multiple asset price updates

  NFTOracle: Reverting Errors
    ✓ Should be reverted as NFTOracle is already initialized
    ✓ Should be reverted as it is a non-existing collection
    ✓ Should be reverted as price is 0
    ✓ Should be reverted as the collection has been deleted
    ✓ Should be reverted as contract is paused
    ✓ Should be reverted as array lengths aren't matching (2 vs 3)
    ✓ Testing overflows

  NFTOracle: Test Pause
    ✓ Should revert as collection is paused
    ✓ Should revert on multi-paused collections

  LendPool: Pause
    ✓ Transfer
    ✓ Deposit
    ✓ Withdraw
    ✓ Borrow
    ✓ Repay
    ✓ Liquidate
    ✓ LiquidateNFTX

  PunkGateway: Delegate
    ✓ Hacker try to borrow and delegate different onBehalf (should revert)
    ✓ Hacker try to auction and delegate different onBehalf (should revert)

  PunkGateway
    ✓ Owner can do emergency CryptoPunks recovery
    ✓ Borrow some USDC and repay it
    ✓ Borrow some ETH and repay it
    ✓ Borrow all ETH and repay it

  PunkGateway-Liquidate
    ✓ Borrow USDC and liquidate it

    1) Borrow USDC and redeem it
    ✓ Borrow ETH and liquidate it

    2) Borrow ETH and redeem it

  Repay and transfer helper tests
    ✓ borrow-repay-transfer

  LendPool: Rescue locked funds
BigNumber { value: "1000000000000000000000" }
    ✓ User 1 transfers 100 DAI directly to pool, and rescuer returns funds
BigNumber { value: "1000000000000000000000" }
    ✓ Prevents a random user from rescuing tokens 

  Upgradeability
    ✓ Tries to update the DAI UToken implementation with a different address than the configuator
    ✓ Upgrades the DAI UToken implementation 
    ✓ Tries to update the DAI DebtToken implementation with a different address than the configuator
    ✓ Upgrades the DAI DebtToken implementation 
    ✓ Tries to update the LendPoolLoan implementation with a different address than the address provider
    ✓ Upgrades the LendPoolLoan implementation 

  UToken: Modifiers
    ✓ Tries to invoke mint not being the Pool
    ✓ Tries to invoke burn not being the Pool
    ✓ Tries to invoke mintToTreasury not being the Pool
    ✓ Tries to invoke transferUnderlyingTo not being the Pool

  UToken
    ✓ Check DAI basic parameters
    ✓ User 0 deposits 1000 DAI, transfers uDai to user 1
    ✓ User 1 receive uDai from user 0, transfers 50% to user 2

  WETHGateway - Delegate
    ✓ Hacker try to delegate different onBehalf (should revert)
    ✓ Borrower try to Borrow more ETH to different onBehalf (should revert)
Hacker try Borrow more ETH with others NFT
    ✓ Hacker try to Borrow more ETH (should revert)

  WETHGateway
    ✓ Deposit WETH via WethGateway 
    ✓ Withdraw WETH - Partial
    ✓ Withdraw WETH - Full
    ✓ Borrow WETH and Full Repay with ETH
Partial Repay ETH loan with native ETH
Full Repay ETH loan with native ETH
    ✓ Borrow ETH and Full Repay with ETH
    ✓ Should revert if receiver function receives Ether if not WETH
    ✓ Should revert if fallback functions is called with Ether
    ✓ Should revert if fallback functions is called
    ✓ Owner can do emergency ERC20 recovery
    ✓ Owner can do emergency ERC721 recovery
*** SelfdestructTransferMock ***

Network: hardhat
tx: 0x5d6441836e1e9cf2a50fdd5b265ecece8b7b2cb9be828f8fa4dbd8895ea58e4a
contract address: 0x054bD77E1501117Aad9127fF51B4F130Eb839552
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000007
gas used: 88001

******

contracts-helpers:registerContractInJsonDb, contractId: SelfdestructTransferMock address: 0x054bD77E1501117Aad9127fF51B4F130Eb839552 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
    ✓ Owner can do emergency native ETH recovery

  WETHGateway - Liquidate
    ✓ Borrow ETH and Liquidate it

    3) Borrow ETH and Redeem it

  LendPool: Withdraw negative test cases
    ✓ Users 0 Deposits 1000 DAI and tries to withdraw 0 DAI (revert expected)
    ✓ Users 0 tries to withdraw 1100 DAI from the 1000 DAI deposited (revert expected)
    ✓ Users 1 borrows 100 DAI, users 0 tries to withdraw the 1000 DAI deposited (revert expected)
    ✓ Users 1 deposits 1 WETH, users 0 borrows 0.01 WETH, users 1 tries to withdraw the 1 WETH deposited (revert expected)

  LendPool: Withdraw
    ✓ User 0 Deposits 1000 DAI in an empty reserve
    ✓ User 0 withdraws half of the deposited DAI
    ✓ User 0 withdraws remaining half of the deposited DAI
    ✓ User 0 Deposits 1 WETH in an empty reserve
    ✓ User 0 withdraws half of the deposited WETH
    ✓ User 0 withdraws remaining half of the deposited WETH
    ✓ Users 0 and 1 Deposit 1000 DAI, both withdraw
    ✓ Users 0 deposits 1000 DAI, user 1 Deposit 1000 USDC and 1 WETH, borrows 100 DAI. User 1 tries to withdraw all the USDC

·---------------------------------------------------------------------|---------------------------|-------------|-----------------------------·
|                         [90mSolc version: 0.8.4[39m                         ·  [90mOptimizer enabled: true[39m  ·  [90mRuns: 200[39m  ·  [90mBlock limit: 12450000 gas[39m  │
······································································|···························|·············|······························
|  [32m[1mMethods[22m[39m                                                                                                                                    │
······································|·······························|·············|·············|·············|···············|··············
|  [1mContract[22m                           ·  [1mMethod[22m                       ·  [32mMin[39m        ·  [32mMax[39m        ·  [32mAvg[39m        ·  [1m# calls[22m      ·  [1meur (avg)[22m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  allInitialOwnersAssigned     ·      [36m25618[39m  ·      [31m45518[39m  ·      38885  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  getPunk                      ·      [36m74914[39m  ·      [31m74926[39m  ·      74924  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  offerPunkForSaleToAddress    ·      [36m99387[39m  ·     [31m119299[39m  ·     116454  ·           [90m14[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  setInitialOwner              ·      [36m28434[39m  ·      [31m60589[39m  ·      49871  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  transferPunk                 ·          -  ·          -  ·      66575  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCustomERC721[39m                       ·  safeTransferFrom             ·          -  ·          -  ·      95752  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCustomERC721[39m                       ·  setApprovalForAll            ·      [36m26324[39m  ·      [31m46224[39m  ·      40101  ·           [90m78[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCustomERC721[39m                       ·  transferFrom                 ·      [36m71346[39m  ·      [31m96740[39m  ·      91126  ·           [90m69[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  approve                      ·      [36m26342[39m  ·      [31m60190[39m  ·      46767  ·          [90m158[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  transfer                     ·      [36m34567[39m  ·     [31m133413[39m  ·      53967  ·          [90m163[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setAddress                   ·      [36m29133[39m  ·      [31m49369[39m  ·      41945  ·           [90m20[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setAddressAsProxy            ·          -  ·          -  ·     699944  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setEmergencyAdmin            ·          -  ·          -  ·      47355  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setIncentivesController      ·      [36m30275[39m  ·      [31m47363[39m  ·      38819  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolConfiguratorImpl  ·          -  ·          -  ·     610427  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolImpl              ·          -  ·          -  ·     698808  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolLiquidator        ·      [36m27543[39m  ·      [31m47443[39m  ·      35110  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolLoanImpl          ·      [36m43396[39m  ·     [31m659480[39m  ·     454119  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLSSVMRouter               ·          -  ·          -  ·      47442  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setNFTOracle                 ·          -  ·          -  ·      47421  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setNFTXVaultFactory          ·          -  ·          -  ·      47377  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setPoolAdmin                 ·          -  ·          -  ·      47444  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setReserveOracle             ·          -  ·          -  ·      47354  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setSushiSwapRouter           ·          -  ·          -  ·      47399  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUIDataProvider            ·          -  ·          -  ·      47295  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUNFTRegistry              ·      [36m27476[39m  ·      [31m47376[39m  ·      37426  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUnlockdDataProvider       ·          -  ·          -  ·      47421  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setWalletBalanceProvider     ·          -  ·          -  ·      47463  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  transferOwnership            ·          -  ·          -  ·      28645  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProviderRegistry[39m  ·  registerAddressesProvider    ·          -  ·          -  ·      92000  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchConfigNft               ·      [36m88028[39m  ·    [31m1105252[39m  ·     753611  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchConfigReserve           ·      [36m80088[39m  ·      [31m97629[39m  ·      91782  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchInitNft                 ·     [36m241624[39m  ·     [31m256916[39m  ·     249270  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchInitReserve             ·    [36m1616376[39m  ·    [31m1631536[39m  ·    1621449  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  configureNftAsAuction        ·      [36m68208[39m  ·      [31m68244[39m  ·      68226  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  configureNftsAsCollateral    ·      [36m96917[39m  ·     [31m133953[39m  ·     111532  ·           [90m58[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnNft           ·      [36m78124[39m  ·      [31m83729[39m  ·      80927  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnNftByTokenId  ·      [36m69729[39m  ·      [31m69741[39m  ·      69735  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnReserve       ·      [36m66655[39m  ·      [31m88835[39m  ·      77745  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setBorrowingFlagOnReserve    ·      [36m66623[39m  ·      [31m66647[39m  ·      66644  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnNft           ·      [36m66577[39m  ·      [31m66590[39m  ·      66584  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnNftByTokenId  ·      [36m69571[39m  ·      [31m69583[39m  ·      69577  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnReserve       ·      [36m66626[39m  ·      [31m66638[39m  ·      66632  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setLtvManagerStatus          ·      [36m39630[39m  ·      [31m59530[39m  ·      45652  ·           [90m76[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setNftMinBidFine             ·      [36m68015[39m  ·      [31m68039[39m  ·      68027  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setNftRedeemThreshold        ·      [36m68036[39m  ·      [31m68060[39m  ·      68048  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setPoolPause                 ·      [36m61575[39m  ·     [31m101218[39m  ·      77269  ·           [90m18[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setPoolRescuer               ·      [36m63859[39m  ·      [31m80959[39m  ·      72409  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setReserveFactor             ·          -  ·          -  ·      66920  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  updateDebtToken              ·          -  ·          -  ·      89446  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  updateUToken                 ·          -  ·          -  ·      89423  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMaliciousHackerERC721[39m              ·  approveDelegate              ·          -  ·          -  ·      87451  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMaliciousHackerERC721[39m              ·  simulateAction               ·      [36m26483[39m  ·      [31m43583[39m  ·      28926  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockChainlinkOracle[39m                ·  mockAddAnswer                ·     [36m125897[39m  ·     [31m245509[39m  ·     149398  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockDebtTokenVersionN[39m              ·  approveDelegation            ·      [36m39048[39m  ·      [31m56148[39m  ·      51458  ·           [90m30[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockIncentivesController[39m           ·  resetHandleActionIsCalled    ·          -  ·          -  ·      27882  ·            [90m9[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  approveValuation             ·          -  ·          -  ·      50300  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  auction                      ·     [36m313256[39m  ·     [31m503796[39m  ·     441750  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  borrow                       ·     [36m396110[39m  ·     [31m831510[39m  ·     743320  ·           [90m49[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  deposit                      ·     [36m179528[39m  ·     [31m251418[39m  ·     218825  ·          [90m101[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  liquidate                    ·     [36m500206[39m  ·     [31m538485[39m  ·     519346  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  liquidateSudoSwap            ·     [36m632536[39m  ·     [31m747528[39m  ·     690032  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  redeem                       ·     [36m376218[39m  ·     [31m413984[39m  ·     395101  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  repay                        ·     [36m284521[39m  ·     [31m454189[39m  ·     379256  ·           [90m14[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  rescue                       ·          -  ·          -  ·      57185  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setIsMarketSupported         ·      [36m56551[39m  ·      [31m78475[39m  ·      61288  ·           [90m70[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setMaxNumberOfReserves       ·          -  ·          -  ·      62697  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setTimeframe                 ·      [36m58166[39m  ·      [31m78078[39m  ·      60634  ·           [90m31[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setTreasuryAddress           ·          -  ·          -  ·      80586  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  updateSafeHealthFactor       ·      [36m40196[39m  ·      [31m60096[39m  ·      55109  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  withdraw                     ·     [36m152923[39m  ·     [31m218820[39m  ·     187090  ·           [90m24[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  addCollection                ·      [36m47505[39m  ·      [31m54843[39m  ·      49232  ·           [90m17[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  initialize                   ·          -  ·          -  ·     113794  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  removeCollection             ·          -  ·          -  ·      25685  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setMultipleNFTPrices         ·      [36m62686[39m  ·      [31m84325[39m  ·      73684  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setNFTPrice                  ·      [36m33049[39m  ·      [31m60368[39m  ·      43229  ·          [90m119[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setPause                     ·      [36m27850[39m  ·      [31m49762[39m  ·      38806  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setPriceManagerStatus        ·      [36m33894[39m  ·      [31m53794[39m  ·      37273  ·           [90m84[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  addAggregator                ·      [36m75602[39m  ·      [31m92702[39m  ·      89282  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  initialize                   ·          -  ·          -  ·      90917  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  mock_setBlockTimestamp       ·          -  ·          -  ·      26541  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  removeAggregator             ·      [36m33119[39m  ·      [31m37640[39m  ·      34023  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  setAggregators               ·          -  ·          -  ·     196520  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  auction                      ·     [36m543440[39m  ·     [31m546240[39m  ·     544840  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  auctionETH                   ·     [36m514941[39m  ·     [31m517741[39m  ·     516341  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  authorizeCallerWhitelist     ·      [36m62136[39m  ·     [31m103532[39m  ·      81742  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  authorizeLendPoolERC20       ·          -  ·          -  ·     157831  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  borrow                       ·     [36m446542[39m  ·    [31m1032260[39m  ·     850700  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  borrowETH                    ·     [36m467964[39m  ·    [31m1052458[39m  ·     922200  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  emergencyERC20Transfer       ·          -  ·          -  ·      60324  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  emergencyERC721Transfer      ·          -  ·          -  ·      99383  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  emergencyPunksTransfer       ·          -  ·          -  ·      79826  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  liquidate                    ·          -  ·          -  ·     749199  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  liquidateETH                 ·          -  ·          -  ·     770373  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  repay                        ·     [36m316518[39m  ·     [31m566782[39m  ·     441650  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  repayETH                     ·     [36m362045[39m  ·     [31m727672[39m  ·     592159  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mRepayAndTransferHelper[39m             ·  emergencyEtherTransfer       ·          -  ·          -  ·      42635  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mRepayAndTransferHelper[39m             ·  repayETHAndTransferERC721    ·          -  ·          -  ·     636709  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mSelfdestructTransfer[39m               ·  destroyAndTransfer           ·      [36m29253[39m  ·      [31m29265[39m  ·      29263  ·          [90m232[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mUNFTRegistry[39m                       ·  createUNFT                   ·     [36m725406[39m  ·     [31m742551[39m  ·     733979  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  auctionETH                   ·     [36m489248[39m  ·     [31m491900[39m  ·     490574  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  authorizeLendPoolNFT         ·          -  ·          -  ·      99328  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  borrowETH                    ·     [36m421126[39m  ·     [31m832207[39m  ·     757989  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  depositETH                   ·     [36m197656[39m  ·     [31m277112[39m  ·     233196  ·           [90m18[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  liquidateETH                 ·          -  ·          -  ·     551606  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  repayETH                     ·     [36m320076[39m  ·     [31m519009[39m  ·     431808  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  withdrawETH                  ·     [36m262577[39m  ·     [31m291924[39m  ·     277251  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWrappedPunk[39m                        ·  setApprovalForAll            ·      [36m26420[39m  ·      [31m46320[39m  ·      34949  ·           [90m14[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [32m[1mDeployments[22m[39m                                                        ·                                         ·  [1m% of limit[22m   ·             │
······································································|·············|·············|·············|···············|··············
|  BorrowLogic                                                        ·          -  ·          -  ·    2066318  ·       [90m16.6 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ConfiguratorLogic                                                  ·          -  ·          -  ·    1970094  ·       [90m15.8 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  CryptoPunksMarket                                                  ·          -  ·          -  ·    2378109  ·       [90m19.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  DebtToken                                                          ·          -  ·          -  ·    1366344  ·         [90m11 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  GenericLogic                                                       ·          -  ·          -  ·      84290  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  InterestRate                                                       ·     [36m616243[39m  ·     [31m616255[39m  ·     616252  ·        [90m4.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPool                                                           ·          -  ·          -  ·    5095759  ·       [90m40.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolAddressesProvider                                          ·          -  ·          -  ·    2978496  ·       [90m23.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolAddressesProviderRegistry                                  ·          -  ·          -  ·     502283  ·          [90m4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolConfigurator                                               ·          -  ·          -  ·    5346518  ·       [90m42.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolLoan                                                       ·          -  ·          -  ·    3262299  ·       [90m26.2 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LiquidateLogic                                                     ·          -  ·          -  ·    3939677  ·       [90m31.6 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LiquidateMarketsLogic                                              ·          -  ·          -  ·    2995275  ·       [90m24.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MaliciousHackerERC721                                              ·          -  ·          -  ·     801955  ·        [90m6.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockChainlinkOracle                                                ·          -  ·          -  ·     620122  ·          [90m5 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockIncentivesController                                           ·          -  ·          -  ·     142669  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockNFTOracle                                                      ·          -  ·          -  ·    1117453  ·          [90m9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockReserveOracle                                                  ·          -  ·          -  ·    1280668  ·       [90m10.3 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  NftLogic                                                           ·          -  ·          -  ·     141010  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  NFTOracle                                                          ·          -  ·          -  ·    1047527  ·        [90m8.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  PunkGateway                                                        ·          -  ·          -  ·    3304310  ·       [90m26.5 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  RepayAndTransferHelper                                             ·          -  ·          -  ·     873271  ·          [90m7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ReserveLogic                                                       ·          -  ·          -  ·     171208  ·        [90m1.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ReserveOracle                                                      ·          -  ·          -  ·    1211618  ·        [90m9.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  SelfdestructTransfer                                               ·          -  ·          -  ·      88001  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  SupplyLogic                                                        ·          -  ·          -  ·    1184796  ·        [90m9.5 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UiPoolDataProvider                                                 ·          -  ·          -  ·    3116123  ·         [90m25 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UNFT                                                               ·          -  ·          -  ·    1503057  ·       [90m12.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UNFTRegistry                                                       ·          -  ·          -  ·    2441516  ·       [90m19.6 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UnlockdProtocolDataProvider                                        ·          -  ·          -  ·    2888605  ·       [90m23.2 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UnlockdProxyAdmin                                                  ·          -  ·          -  ·     470704  ·        [90m3.8 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UnlockdUpgradeableProxy                                            ·     [36m689038[39m  ·     [31m998847[39m  ·     777214  ·        [90m6.2 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UToken                                                             ·          -  ·          -  ·    1983088  ·       [90m15.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ValidationLogic                                                    ·          -  ·          -  ·    1530121  ·       [90m12.3 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  WalletBalanceProvider                                              ·          -  ·          -  ·    1251342  ·       [90m10.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  WETHGateway                                                        ·          -  ·          -  ·    2420738  ·       [90m19.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  WrappedPunk                                                        ·          -  ·          -  ·    1992593  ·         [90m16 %[39m  ·          [32m[90m-[32m[39m  │
·---------------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------·

  251 passing (3m)
  3 failing

  1) PunkGateway-Liquidate
       Borrow USDC and redeem it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '202'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0xb16101f4b859580B810b683264102c49e12d0732","data":"0xb81922050000000000000000000000000000000000000000000000000000000000000068000000000000000000000000000000000000000000000000000000000093db9a00000000000000000000000000000000000000000000000000000000000ff209","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"PunkGateway","sourceName":"contracts/protocol/PunkGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IPunks} from \"../interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../interfaces/IWrappedPunks.sol\";\nimport {IPunkGateway} from \"../interfaces/IPunkGateway.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract PunkGateway is IPunkGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  IWETHGateway internal _wethGateway;\n\n  IPunks public punks;\n  IWrappedPunks public wrappedPunks;\n  address public proxy;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the PunkGateway contract is added to the\n   * LendPoolAddressesProvider of the market.\n   **/\n  function initialize(\n    address addressProvider,\n    address wethGateway,\n    address _punks,\n    address _wrappedPunks\n  ) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n    _wethGateway = IWETHGateway(wethGateway);\n\n    punks = IPunks(_punks);\n    wrappedPunks = IWrappedPunks(_wrappedPunks);\n    wrappedPunks.registerProxy();\n    proxy = wrappedPunks.proxyInfo(address(this));\n\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_getLendPool()), true);\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_wethGateway), true);\n  }\n\n  /**\n   * @notice Returns the LendPool address\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice Returns the LendPoolLoan address\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @notice Approves the lendpool for given tokens\n   * @param tokens the array of tokens\n   **/\n  function authorizeLendPoolERC20(address[] calldata tokens) external nonReentrant onlyOwner {\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ) {\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), 0);\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), type(uint256).max);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Authorizes/unauthorizes an array of callers to the whitelist\n   * @param callers the array of callers\n   * @param callers the authorization status\n   **/\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callersLength = callers.length;\n    for (uint256 i = 0; i < callersLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if caller is whitelisted\n   * @param caller caller address\n   **/\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @notice Checks the onBehalfOf address is valid for a given callet\n   * @param onBehalfOf the allowed address\n   **/\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @notice Deposits a punk given its index\n   * - E.g. User deposit NFT Punk and receives the wrapped asset\n   * @param punkIndex The index of the CryptoPunk to deposit\n   **/\n  function _depositPunk(uint256 punkIndex) internal {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    if (loanId != 0) {\n      return;\n    }\n\n    address owner = punks.punkIndexToAddress(punkIndex);\n\n    require(owner == _msgSender(), \"PunkGateway: not owner of punkIndex\");\n\n    punks.buyPunk(punkIndex);\n\n    punks.transferPunk(proxy, punkIndex);\n\n    wrappedPunks.mint(punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrow(\n    address reserveAsset,\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    _depositPunk(punkIndex);\n\n    cachedPool.borrow(reserveAsset, amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n\n    IERC20Upgradeable(reserveAsset).transfer(onBehalfOf, amount);\n  }\n\n  function _withdrawPunk(uint256 punkIndex, address onBehalfOf) internal {\n    address owner = wrappedPunks.ownerOf(punkIndex);\n    require(owner == _msgSender(), \"PunkGateway: caller is not owner\");\n    require(owner == onBehalfOf, \"PunkGateway: onBehalfOf is not owner\");\n\n    wrappedPunks.safeTransferFrom(onBehalfOf, address(this), punkIndex);\n    wrappedPunks.burn(punkIndex);\n    punks.transferPunk(onBehalfOf, punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repay(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256, bool) {\n    return _repay(punkIndex, amount);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk used as collateral\n   * @param amount The amount to repay\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repay(uint256 punkIndex, uint256 amount) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n    (, uint256 debt) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n\n    if (amount > debt) {\n      amount = debt;\n    }\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), amount);\n\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(address(wrappedPunks), punkIndex, amount);\n\n    if (burn) {\n      require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auction(uint256 punkIndex, uint256 bidPrice, address onBehalfOf) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), bidPrice);\n\n    cachedPool.auction(address(wrappedPunks), punkIndex, bidPrice, onBehalfOf);\n  }\n\n  function redeem(uint256 punkIndex, uint256 amount, uint256 bidFine) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), (amount + bidFine));\n\n    uint256 paybackAmount = cachedPool.redeem(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    if ((amount + bidFine) > paybackAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, ((amount + bidFine) - paybackAmount));\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidate(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    if (amount > 0) {\n      IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), amount);\n    }\n\n    uint256 extraRetAmount = cachedPool.liquidate(address(wrappedPunks), punkIndex, amount);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    if (amount > extraRetAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, (amount - extraRetAmount));\n    }\n\n    return (extraRetAmount);\n  }\n\n  /**\n   * @notice Liquidate punk in NFTX\n   * @param punkIndex The index of the CryptoPunk to liquidate\n   **/\n  function liquidateNFTX(uint256 punkIndex, uint256 amountOutMin) external override nonReentrant returns (uint256) {\n    require(_addressProvider.getLendPoolLiquidator() == _msgSender(), Errors.CALLER_NOT_POOL_LIQUIDATOR);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    uint256 remainAmount = cachedPool.liquidateNFTX(address(wrappedPunks), punkIndex, amountOutMin);\n\n    return (remainAmount);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _depositPunk(punkIndex);\n    _wethGateway.borrowETH(amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repayETH(uint256 punkIndex, uint256 amount) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 paybackAmount, bool burn) = _repayETH(punkIndex, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk with native ETH\n   * - E.g. User repays 100 ETH, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk to repay\n   * @param amount The amount to repay\n   * @param accAmount The accumulated amount\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repayETH(uint256 punkIndex, uint256 amount, uint256 accAmount) internal returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n    require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    (uint256 paybackAmount, bool burn) = _wethGateway.repayETH{value: repayDebtAmount}(\n      address(wrappedPunks),\n      punkIndex,\n      amount\n    );\n\n    if (burn) {\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(uint256 punkIndex, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _wethGateway.auctionETH{value: msg.value}(address(wrappedPunks), punkIndex, onBehalfOf);\n  }\n\n  function redeemETH(\n    uint256 punkIndex,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    //DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    uint256 paybackAmount = _wethGateway.redeemETH{value: msg.value}(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(uint256 punkIndex) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    uint256 extraAmount = _wethGateway.liquidateETH{value: msg.value}(address(wrappedPunks), punkIndex);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    // refund remaining dust eth\n    if (msg.value > extraAmount) {\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return extraAmount;\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":271,"range":[9705,9773]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000001;\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000002;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    require(\n      _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n        _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n      Errors.LP_CALLER_NOT_NFT_HOLDER\n    );\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,   \n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset, \n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n \n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor; \n    emit SafeHealthFactorUpdated(newSafeHealthFactor); \n  } \n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param uToken the utoken to update the treasury address to\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address uToken, address treasury) external override onlyLendPoolConfigurator {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    IUToken(uToken).setTreasuryAddress(treasury);\n    emit TreasuryAddressUpdated(uToken, treasury);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":326,"range":[12637,13039]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":362,"range":[14216,14425]},"functionType":1},{"type":0,"sourceReference":{"function":"calculateOptimalMinRedeemValue","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/GenericLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Unlockd\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct CalculateLoanDataVars {\n    uint256 reserveUnitPrice;\n    uint256 reserveUnit;\n    uint256 reserveDecimals;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalCollateralInReserve;\n    uint256 totalDebtInETH;\n    uint256 totalDebtInReserve;\n    uint256 nftLtv;\n    uint256 nftLiquidationThreshold;\n    address nftAsset;\n    uint256 nftTokenId;\n    uint256 nftUnitPrice;\n    uint256 minRedeemValue;\n  }\n\n  /**\n   * @dev Calculates the nft loan data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress the underlying NFT asset\n   * @param nftTokenId the token Id for the NFT\n   * @param nftConfig Config of the nft by tokenId\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\n   **/\n  function calculateLoanData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    // calculate total borrow balance for the loan\n    if (loanId != 0) {\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\n        reserveAddress,\n        reserveData,\n        loanAddress,\n        loanId,\n        reserveOracle\n      );\n    }\n\n    // calculate total collateral balance for the nft\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\n      reserveAddress,\n      reserveData,\n      nftAddress,\n      nftTokenId,\n      reserveOracle,\n      nftOracle\n    );\n\n    // calculate health by borrow and collateral\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInReserve,\n      vars.totalDebtInReserve,\n      vars.nftLiquidationThreshold\n    );\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\n  }\n\n  /**\n   * @dev Calculates the nft debt data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftDebtData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\n\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\n  }\n\n  /**\n   * @dev Calculates the nft collateral data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress The underlying NFT asset\n   * @param nftTokenId The underlying NFT token Id\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The nft price oracle address\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftCollateralData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256) {\n    reserveData;\n\n    CalculateLoanDataVars memory vars;\n \n    // calculate total collateral balance for the nft\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.totalCollateralInETH = vars.nftUnitPrice;\n\n    if (reserveAddress != address(0)) {\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\n      vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\n    }\n\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\n  }\n\n  /**\n   * @dev Calculates the optimal min redeem value\n   * @param borrowAmount The debt\n   * @param nftAddress The nft address\n   * @param nftTokenId The token id\n   * @param nftOracle The nft oracle address\n   * @param liquidationThreshold The liquidation threshold\n   * @param safeHealthFactor The safe health factor value\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateOptimalMinRedeemValue(\n    uint256 borrowAmount,\n    address nftAddress,\n    uint256 nftTokenId,\n    address nftOracle,\n    uint256 liquidationThreshold,\n    uint256 safeHealthFactor\n  ) internal view returns (uint256) {\n    CalculateLoanDataVars memory vars;\n\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.minRedeemValue =  borrowAmount - ((vars.nftUnitPrice.percentMul(liquidationThreshold)).wadDiv(safeHealthFactor)); \n    if(vars.nftUnitPrice < vars.minRedeemValue){\n      return vars.nftUnitPrice;\n    }\n\n    return vars.minRedeemValue;\n  }\n\n   function calculateOptimalMaxRedeemValue(\n    uint256 debt,\n    uint256 minRedeem\n  ) internal pure returns (uint256) {\n    return debt - ((debt - minRedeem).wadDiv(2 ether));\n  }\n\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total debt\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebt == 0) return type(uint256).max;\n\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\n  }\n\n  \n\n  /**\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow for the user\n   **/\n\n  function calculateAvailableBorrows(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\n\n    if (availableBorrows < totalDebt) {\n      return 0;\n    }\n\n    availableBorrows = availableBorrows - totalDebt;\n    return availableBorrows;\n  }\n\n  struct CalcLiquidatePriceLocalVars {\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 nftPriceInETH;\n    uint256 nftPriceInReserve;\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n  }\n\n  /**\n   * @dev Calculates the loan liquidation price\n   * @param loanId the loan Id\n   * @param reserveAsset The underlying asset of the reserve\n   * @param reserveData the reserve data\n   * @param nftAsset the underlying NFT asset\n   * @param nftTokenId the NFT token Id\n   * @param nftConfig The NFT data\n   * @param poolLoan The pool loan address\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The borrow amount, threshold price and liquidation price\n   **/\n  function calculateLoanLiquidatePrice(\n    uint256 loanId,\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address poolLoan,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalcLiquidatePriceLocalVars memory vars;\n\n    /*\n     * 0                   CR                  LH                  100\n     * |___________________|___________________|___________________|\n     *  <       Borrowing with Interest        <\n     * CR: Callteral Ratio;\n     * LH: Liquidate Threshold;\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\n     */\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\n \n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftConfig.getCollateralParams();\n\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getNFTPrice(nftAsset, nftTokenId);\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n\n    vars.nftPriceInReserve = ((10 ** vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\n\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\n\n    vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\n\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\n  }\n\n  struct CalcLoanBidFineLocalVars {\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 baseBidFineInReserve;\n    uint256 minBidFinePct;\n    uint256 minBidFineInReserve;\n    uint256 bidFineInReserve;\n    uint256 debtAmount;\n  }\n\n  function calculateLoanBidFine(\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    address poolLoan,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    nftAsset;\n\n    if (loanData.bidPrice == 0) {\n      return (0, 0);\n    }\n\n    CalcLoanBidFineLocalVars memory vars;\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n    vars.baseBidFineInReserve = (1 ether * 10 ** vars.reserveDecimals) / vars.reservePriceInETH;\n\n    vars.minBidFinePct = nftConfig.getMinBidFine();\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\n\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\n\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftConfig.getRedeemFine());\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\n      vars.bidFineInReserve = vars.minBidFineInReserve;\n    }\n\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\n  }\n}\n","line":199,"range":[7478,7555]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":461,"range":[17747,17813]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,50,48,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033230320000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)

  2) PunkGateway-Liquidate
       Borrow ETH and redeem it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '202'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0xb16101f4b859580B810b683264102c49e12d0732","value":{"type":"BigNumber","hex":"0x94faa47de030da08"},"data":"0xcf1c37b2000000000000000000000000000000000000000000000000000000000000006a000000000000000000000000000000000000000000000000867a0804e105953c0000000000000000000000000000000000000000000000000e809c78ff2b44cc","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeemETH","contract":"PunkGateway","sourceName":"contracts/protocol/PunkGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IPunks} from \"../interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../interfaces/IWrappedPunks.sol\";\nimport {IPunkGateway} from \"../interfaces/IPunkGateway.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract PunkGateway is IPunkGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  IWETHGateway internal _wethGateway;\n\n  IPunks public punks;\n  IWrappedPunks public wrappedPunks;\n  address public proxy;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the PunkGateway contract is added to the\n   * LendPoolAddressesProvider of the market.\n   **/\n  function initialize(\n    address addressProvider,\n    address wethGateway,\n    address _punks,\n    address _wrappedPunks\n  ) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n    _wethGateway = IWETHGateway(wethGateway);\n\n    punks = IPunks(_punks);\n    wrappedPunks = IWrappedPunks(_wrappedPunks);\n    wrappedPunks.registerProxy();\n    proxy = wrappedPunks.proxyInfo(address(this));\n\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_getLendPool()), true);\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_wethGateway), true);\n  }\n\n  /**\n   * @notice Returns the LendPool address\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice Returns the LendPoolLoan address\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @notice Approves the lendpool for given tokens\n   * @param tokens the array of tokens\n   **/\n  function authorizeLendPoolERC20(address[] calldata tokens) external nonReentrant onlyOwner {\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ) {\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), 0);\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), type(uint256).max);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Authorizes/unauthorizes an array of callers to the whitelist\n   * @param callers the array of callers\n   * @param callers the authorization status\n   **/\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callersLength = callers.length;\n    for (uint256 i = 0; i < callersLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if caller is whitelisted\n   * @param caller caller address\n   **/\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @notice Checks the onBehalfOf address is valid for a given callet\n   * @param onBehalfOf the allowed address\n   **/\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @notice Deposits a punk given its index\n   * - E.g. User deposit NFT Punk and receives the wrapped asset\n   * @param punkIndex The index of the CryptoPunk to deposit\n   **/\n  function _depositPunk(uint256 punkIndex) internal {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    if (loanId != 0) {\n      return;\n    }\n\n    address owner = punks.punkIndexToAddress(punkIndex);\n\n    require(owner == _msgSender(), \"PunkGateway: not owner of punkIndex\");\n\n    punks.buyPunk(punkIndex);\n\n    punks.transferPunk(proxy, punkIndex);\n\n    wrappedPunks.mint(punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrow(\n    address reserveAsset,\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    _depositPunk(punkIndex);\n\n    cachedPool.borrow(reserveAsset, amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n\n    IERC20Upgradeable(reserveAsset).transfer(onBehalfOf, amount);\n  }\n\n  function _withdrawPunk(uint256 punkIndex, address onBehalfOf) internal {\n    address owner = wrappedPunks.ownerOf(punkIndex);\n    require(owner == _msgSender(), \"PunkGateway: caller is not owner\");\n    require(owner == onBehalfOf, \"PunkGateway: onBehalfOf is not owner\");\n\n    wrappedPunks.safeTransferFrom(onBehalfOf, address(this), punkIndex);\n    wrappedPunks.burn(punkIndex);\n    punks.transferPunk(onBehalfOf, punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repay(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256, bool) {\n    return _repay(punkIndex, amount);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk used as collateral\n   * @param amount The amount to repay\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repay(uint256 punkIndex, uint256 amount) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n    (, uint256 debt) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n\n    if (amount > debt) {\n      amount = debt;\n    }\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), amount);\n\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(address(wrappedPunks), punkIndex, amount);\n\n    if (burn) {\n      require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auction(uint256 punkIndex, uint256 bidPrice, address onBehalfOf) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), bidPrice);\n\n    cachedPool.auction(address(wrappedPunks), punkIndex, bidPrice, onBehalfOf);\n  }\n\n  function redeem(uint256 punkIndex, uint256 amount, uint256 bidFine) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), (amount + bidFine));\n\n    uint256 paybackAmount = cachedPool.redeem(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    if ((amount + bidFine) > paybackAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, ((amount + bidFine) - paybackAmount));\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidate(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    if (amount > 0) {\n      IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), amount);\n    }\n\n    uint256 extraRetAmount = cachedPool.liquidate(address(wrappedPunks), punkIndex, amount);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    if (amount > extraRetAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, (amount - extraRetAmount));\n    }\n\n    return (extraRetAmount);\n  }\n\n  /**\n   * @notice Liquidate punk in NFTX\n   * @param punkIndex The index of the CryptoPunk to liquidate\n   **/\n  function liquidateNFTX(uint256 punkIndex, uint256 amountOutMin) external override nonReentrant returns (uint256) {\n    require(_addressProvider.getLendPoolLiquidator() == _msgSender(), Errors.CALLER_NOT_POOL_LIQUIDATOR);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    uint256 remainAmount = cachedPool.liquidateNFTX(address(wrappedPunks), punkIndex, amountOutMin);\n\n    return (remainAmount);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _depositPunk(punkIndex);\n    _wethGateway.borrowETH(amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repayETH(uint256 punkIndex, uint256 amount) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 paybackAmount, bool burn) = _repayETH(punkIndex, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk with native ETH\n   * - E.g. User repays 100 ETH, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk to repay\n   * @param amount The amount to repay\n   * @param accAmount The accumulated amount\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repayETH(uint256 punkIndex, uint256 amount, uint256 accAmount) internal returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n    require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    (uint256 paybackAmount, bool burn) = _wethGateway.repayETH{value: repayDebtAmount}(\n      address(wrappedPunks),\n      punkIndex,\n      amount\n    );\n\n    if (burn) {\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(uint256 punkIndex, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _wethGateway.auctionETH{value: msg.value}(address(wrappedPunks), punkIndex, onBehalfOf);\n  }\n\n  function redeemETH(\n    uint256 punkIndex,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    //DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    uint256 paybackAmount = _wethGateway.redeemETH{value: msg.value}(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(uint256 punkIndex) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    uint256 extraAmount = _wethGateway.liquidateETH{value: msg.value}(address(wrappedPunks), punkIndex);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    // refund remaining dust eth\n    if (msg.value > extraAmount) {\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return extraAmount;\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":407,"range":[14510,14601]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeemETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n  \n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    (address reserveAsset, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    require(reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(address nftAsset, uint256 nftTokenId, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(address nftAsset, uint256 nftTokenId) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":276,"range":[9389,9445]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000001;\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000002;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    require(\n      _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n        _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n      Errors.LP_CALLER_NOT_NFT_HOLDER\n    );\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,   \n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset, \n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n \n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor; \n    emit SafeHealthFactorUpdated(newSafeHealthFactor); \n  } \n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param uToken the utoken to update the treasury address to\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address uToken, address treasury) external override onlyLendPoolConfigurator {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    IUToken(uToken).setTreasuryAddress(treasury);\n    emit TreasuryAddressUpdated(uToken, treasury);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":326,"range":[12637,13039]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":362,"range":[14216,14425]},"functionType":1},{"type":0,"sourceReference":{"function":"calculateOptimalMinRedeemValue","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/GenericLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Unlockd\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct CalculateLoanDataVars {\n    uint256 reserveUnitPrice;\n    uint256 reserveUnit;\n    uint256 reserveDecimals;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalCollateralInReserve;\n    uint256 totalDebtInETH;\n    uint256 totalDebtInReserve;\n    uint256 nftLtv;\n    uint256 nftLiquidationThreshold;\n    address nftAsset;\n    uint256 nftTokenId;\n    uint256 nftUnitPrice;\n    uint256 minRedeemValue;\n  }\n\n  /**\n   * @dev Calculates the nft loan data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress the underlying NFT asset\n   * @param nftTokenId the token Id for the NFT\n   * @param nftConfig Config of the nft by tokenId\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\n   **/\n  function calculateLoanData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    // calculate total borrow balance for the loan\n    if (loanId != 0) {\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\n        reserveAddress,\n        reserveData,\n        loanAddress,\n        loanId,\n        reserveOracle\n      );\n    }\n\n    // calculate total collateral balance for the nft\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\n      reserveAddress,\n      reserveData,\n      nftAddress,\n      nftTokenId,\n      reserveOracle,\n      nftOracle\n    );\n\n    // calculate health by borrow and collateral\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInReserve,\n      vars.totalDebtInReserve,\n      vars.nftLiquidationThreshold\n    );\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\n  }\n\n  /**\n   * @dev Calculates the nft debt data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftDebtData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\n\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\n  }\n\n  /**\n   * @dev Calculates the nft collateral data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress The underlying NFT asset\n   * @param nftTokenId The underlying NFT token Id\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The nft price oracle address\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftCollateralData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256) {\n    reserveData;\n\n    CalculateLoanDataVars memory vars;\n \n    // calculate total collateral balance for the nft\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.totalCollateralInETH = vars.nftUnitPrice;\n\n    if (reserveAddress != address(0)) {\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\n      vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\n    }\n\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\n  }\n\n  /**\n   * @dev Calculates the optimal min redeem value\n   * @param borrowAmount The debt\n   * @param nftAddress The nft address\n   * @param nftTokenId The token id\n   * @param nftOracle The nft oracle address\n   * @param liquidationThreshold The liquidation threshold\n   * @param safeHealthFactor The safe health factor value\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateOptimalMinRedeemValue(\n    uint256 borrowAmount,\n    address nftAddress,\n    uint256 nftTokenId,\n    address nftOracle,\n    uint256 liquidationThreshold,\n    uint256 safeHealthFactor\n  ) internal view returns (uint256) {\n    CalculateLoanDataVars memory vars;\n\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.minRedeemValue =  borrowAmount - ((vars.nftUnitPrice.percentMul(liquidationThreshold)).wadDiv(safeHealthFactor)); \n    if(vars.nftUnitPrice < vars.minRedeemValue){\n      return vars.nftUnitPrice;\n    }\n\n    return vars.minRedeemValue;\n  }\n\n   function calculateOptimalMaxRedeemValue(\n    uint256 debt,\n    uint256 minRedeem\n  ) internal pure returns (uint256) {\n    return debt - ((debt - minRedeem).wadDiv(2 ether));\n  }\n\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total debt\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebt == 0) return type(uint256).max;\n\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\n  }\n\n  \n\n  /**\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow for the user\n   **/\n\n  function calculateAvailableBorrows(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\n\n    if (availableBorrows < totalDebt) {\n      return 0;\n    }\n\n    availableBorrows = availableBorrows - totalDebt;\n    return availableBorrows;\n  }\n\n  struct CalcLiquidatePriceLocalVars {\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 nftPriceInETH;\n    uint256 nftPriceInReserve;\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n  }\n\n  /**\n   * @dev Calculates the loan liquidation price\n   * @param loanId the loan Id\n   * @param reserveAsset The underlying asset of the reserve\n   * @param reserveData the reserve data\n   * @param nftAsset the underlying NFT asset\n   * @param nftTokenId the NFT token Id\n   * @param nftConfig The NFT data\n   * @param poolLoan The pool loan address\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The borrow amount, threshold price and liquidation price\n   **/\n  function calculateLoanLiquidatePrice(\n    uint256 loanId,\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address poolLoan,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalcLiquidatePriceLocalVars memory vars;\n\n    /*\n     * 0                   CR                  LH                  100\n     * |___________________|___________________|___________________|\n     *  <       Borrowing with Interest        <\n     * CR: Callteral Ratio;\n     * LH: Liquidate Threshold;\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\n     */\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\n \n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftConfig.getCollateralParams();\n\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getNFTPrice(nftAsset, nftTokenId);\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n\n    vars.nftPriceInReserve = ((10 ** vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\n\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\n\n    vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\n\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\n  }\n\n  struct CalcLoanBidFineLocalVars {\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 baseBidFineInReserve;\n    uint256 minBidFinePct;\n    uint256 minBidFineInReserve;\n    uint256 bidFineInReserve;\n    uint256 debtAmount;\n  }\n\n  function calculateLoanBidFine(\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    address poolLoan,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    nftAsset;\n\n    if (loanData.bidPrice == 0) {\n      return (0, 0);\n    }\n\n    CalcLoanBidFineLocalVars memory vars;\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n    vars.baseBidFineInReserve = (1 ether * 10 ** vars.reserveDecimals) / vars.reservePriceInETH;\n\n    vars.minBidFinePct = nftConfig.getMinBidFine();\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\n\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\n\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftConfig.getRedeemFine());\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\n      vars.bidFineInReserve = vars.minBidFineInReserve;\n    }\n\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\n  }\n}\n","line":199,"range":[7478,7555]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":461,"range":[17747,17813]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,50,48,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033230320000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)

  3) WETHGateway - Liquidate
       Borrow ETH and Redeem it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '202'", method="estimateGas", transaction={"from":"0xBeC583E93262AD87b08cFFbD4D8d97FC80e191Ac","to":"0x51bda59320165617F7209a38D08b11ccefF58F1a","value":{"type":"BigNumber","hex":"0x0129f500fee7dcd987"},"data":"0xceac58c00000000000000000000000009278420bf7548970799c56ef9a0b08186251533000000000000000000000000000000000000000000000000000000000000000740000000000000000000000000000000000000000000000010cf3c7194892ad190000000000000000000000000000000000000000000000001d0139e59f4a2c6e","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeemETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n  \n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    (address reserveAsset, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    require(reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(address nftAsset, uint256 nftTokenId, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(address nftAsset, uint256 nftTokenId) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":276,"range":[9389,9445]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"redeem","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000001;\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = 0xADDE000000000000000000000000000000000000000000000000000000000002;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    require(\n      _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n        _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n      Errors.LP_CALLER_NOT_NFT_HOLDER\n    );\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,   \n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset, \n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n \n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor; \n    emit SafeHealthFactorUpdated(newSafeHealthFactor); \n  } \n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param uToken the utoken to update the treasury address to\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address uToken, address treasury) external override onlyLendPoolConfigurator {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    IUToken(uToken).setTreasuryAddress(treasury);\n    emit TreasuryAddressUpdated(uToken, treasury);\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":326,"range":[12637,13039]},"functionType":1},{"type":0,"sourceReference":{"function":"executeRedeem","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":362,"range":[14216,14425]},"functionType":1},{"type":0,"sourceReference":{"function":"calculateOptimalMinRedeemValue","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/GenericLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Unlockd\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct CalculateLoanDataVars {\n    uint256 reserveUnitPrice;\n    uint256 reserveUnit;\n    uint256 reserveDecimals;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalCollateralInReserve;\n    uint256 totalDebtInETH;\n    uint256 totalDebtInReserve;\n    uint256 nftLtv;\n    uint256 nftLiquidationThreshold;\n    address nftAsset;\n    uint256 nftTokenId;\n    uint256 nftUnitPrice;\n    uint256 minRedeemValue;\n  }\n\n  /**\n   * @dev Calculates the nft loan data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress the underlying NFT asset\n   * @param nftTokenId the token Id for the NFT\n   * @param nftConfig Config of the nft by tokenId\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\n   **/\n  function calculateLoanData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    // calculate total borrow balance for the loan\n    if (loanId != 0) {\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\n        reserveAddress,\n        reserveData,\n        loanAddress,\n        loanId,\n        reserveOracle\n      );\n    }\n\n    // calculate total collateral balance for the nft\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\n      reserveAddress,\n      reserveData,\n      nftAddress,\n      nftTokenId,\n      reserveOracle,\n      nftOracle\n    );\n\n    // calculate health by borrow and collateral\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInReserve,\n      vars.totalDebtInReserve,\n      vars.nftLiquidationThreshold\n    );\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\n  }\n\n  /**\n   * @dev Calculates the nft debt data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param loanAddress The loan address\n   * @param loanId The loan identifier\n   * @param reserveOracle The price oracle address of reserve\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftDebtData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    CalculateLoanDataVars memory vars;\n\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\n\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\n  }\n\n  /**\n   * @dev Calculates the nft collateral data.\n   * this includes the total collateral/borrow balances in Reserve,\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\n   * @param reserveAddress the underlying asset of the reserve\n   * @param reserveData Data of the reserve\n   * @param nftAddress The underlying NFT asset\n   * @param nftTokenId The underlying NFT token Id\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The nft price oracle address\n   * @return The total debt in ETH and the total debt in the Reserve\n   **/\n  function calculateNftCollateralData(\n    address reserveAddress,\n    DataTypes.ReserveData storage reserveData,\n    address nftAddress,\n    uint256 nftTokenId,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256) {\n    reserveData;\n\n    CalculateLoanDataVars memory vars;\n \n    // calculate total collateral balance for the nft\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.totalCollateralInETH = vars.nftUnitPrice;\n\n    if (reserveAddress != address(0)) {\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\n      vars.reserveUnit = 10 ** vars.reserveDecimals;\n\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\n    }\n\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\n  }\n\n  /**\n   * @dev Calculates the optimal min redeem value\n   * @param borrowAmount The debt\n   * @param nftAddress The nft address\n   * @param nftTokenId The token id\n   * @param nftOracle The nft oracle address\n   * @param liquidationThreshold The liquidation threshold\n   * @param safeHealthFactor The safe health factor value\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateOptimalMinRedeemValue(\n    uint256 borrowAmount,\n    address nftAddress,\n    uint256 nftTokenId,\n    address nftOracle,\n    uint256 liquidationThreshold,\n    uint256 safeHealthFactor\n  ) internal view returns (uint256) {\n    CalculateLoanDataVars memory vars;\n\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getNFTPrice(nftAddress, nftTokenId);\n    vars.minRedeemValue =  borrowAmount - ((vars.nftUnitPrice.percentMul(liquidationThreshold)).wadDiv(safeHealthFactor)); \n    if(vars.nftUnitPrice < vars.minRedeemValue){\n      return vars.nftUnitPrice;\n    }\n\n    return vars.minRedeemValue;\n  }\n\n   function calculateOptimalMaxRedeemValue(\n    uint256 debt,\n    uint256 minRedeem\n  ) internal pure returns (uint256) {\n    return debt - ((debt - minRedeem).wadDiv(2 ether));\n  }\n\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total debt\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebt == 0) return type(uint256).max;\n\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\n  }\n\n  \n\n  /**\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateral The total collateral\n   * @param totalDebt The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow for the user\n   **/\n\n  function calculateAvailableBorrows(\n    uint256 totalCollateral,\n    uint256 totalDebt,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\n\n    if (availableBorrows < totalDebt) {\n      return 0;\n    }\n\n    availableBorrows = availableBorrows - totalDebt;\n    return availableBorrows;\n  }\n\n  struct CalcLiquidatePriceLocalVars {\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 nftPriceInETH;\n    uint256 nftPriceInReserve;\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n  }\n\n  /**\n   * @dev Calculates the loan liquidation price\n   * @param loanId the loan Id\n   * @param reserveAsset The underlying asset of the reserve\n   * @param reserveData the reserve data\n   * @param nftAsset the underlying NFT asset\n   * @param nftTokenId the NFT token Id\n   * @param nftConfig The NFT data\n   * @param poolLoan The pool loan address\n   * @param reserveOracle The price oracle address of reserve\n   * @param nftOracle The price oracle address of nft\n   * @return The borrow amount, threshold price and liquidation price\n   **/\n  function calculateLoanLiquidatePrice(\n    uint256 loanId,\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    uint256 nftTokenId,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address poolLoan,\n    address reserveOracle,\n    address nftOracle\n  ) internal view returns (uint256, uint256, uint256) {\n    CalcLiquidatePriceLocalVars memory vars;\n\n    /*\n     * 0                   CR                  LH                  100\n     * |___________________|___________________|___________________|\n     *  <       Borrowing with Interest        <\n     * CR: Callteral Ratio;\n     * LH: Liquidate Threshold;\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\n     */\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\n \n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftConfig.getCollateralParams();\n\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getNFTPrice(nftAsset, nftTokenId);\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n\n    vars.nftPriceInReserve = ((10 ** vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\n\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\n\n    vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\n\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\n  }\n\n  struct CalcLoanBidFineLocalVars {\n    uint256 reserveDecimals;\n    uint256 reservePriceInETH;\n    uint256 baseBidFineInReserve;\n    uint256 minBidFinePct;\n    uint256 minBidFineInReserve;\n    uint256 bidFineInReserve;\n    uint256 debtAmount;\n  }\n\n  function calculateLoanBidFine(\n    address reserveAsset,\n    DataTypes.ReserveData storage reserveData,\n    address nftAsset,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    address poolLoan,\n    address reserveOracle\n  ) internal view returns (uint256, uint256) {\n    nftAsset;\n\n    if (loanData.bidPrice == 0) {\n      return (0, 0);\n    }\n\n    CalcLoanBidFineLocalVars memory vars;\n\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\n    vars.baseBidFineInReserve = (1 ether * 10 ** vars.reserveDecimals) / vars.reservePriceInETH;\n\n    vars.minBidFinePct = nftConfig.getMinBidFine();\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\n\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\n\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftConfig.getRedeemFine());\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\n      vars.bidFineInReserve = vars.minBidFineInReserve;\n    }\n\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\n  }\n}\n","line":199,"range":[7478,7555]},"functionType":1},{"type":4,"sourceReference":{"function":"executeLiquidate","contract":"LiquidateLogic","sourceName":"contracts/libraries/logic/LiquidateLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {ILSSVMPair} from \"../../interfaces/sudoswap/ILSSVMPair.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport {NFTXSeller} from \"../markets/NFTXSeller.sol\";\n\n/**\n * @title LiquidateLogic library\n * @author Unlockd\n * @notice Implements the logic to liquidate feature\n */\nlibrary LiquidateLogic {\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Emitted when a borrower's loan is auctioned.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param bidPrice The price of the underlying reserve given by the bidder\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the NFT\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Auction(\n    address user,\n    address indexed reserve,\n    uint256 bidPrice,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted on redeem()\n   * @param user The address of the user initiating the redeem(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param borrowAmount The borrow amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Redeem(\n    address user,\n    address indexed reserve,\n    uint256 borrowAmount,\n    uint256 fineAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  /**\n   * @dev Emitted when a borrower's loan is liquidated.\n   * @param user The address of the user initiating the auction\n   * @param reserve The address of the underlying asset of the reserve\n   * @param repayAmount The amount of reserve repaid by the liquidator\n   * @param remainAmount The amount of reserve received by the borrower\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Liquidate(\n    address user,\n    address indexed reserve,\n    uint256 repayAmount,\n    uint256 remainAmount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct AuctionLocalVars {\n    address loanAddress;\n    address reserveOracle;\n    address nftOracle;\n    address initiator;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 borrowAmount;\n    uint256 auctionEndTimestamp;\n    uint256 minBidDelta;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\n   * @dev Emits the `Auction()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the auction function\n   */\n  function executeAuction(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    mapping(address => mapping(uint8 => bool)) storage isMarketSupported,\n    mapping(address => address[2]) storage sudoswapPairs,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteAuctionParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    AuctionLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\n\n    //Initiator can not bid for same onBehalfOf address, as the new auction would be the same as the currently existing auction\n    //created by them previously. Nevertheless, it is possible for the initiator to bid for a different `onBehalfOf` address,\n    //as the new bidderAddress will be different.\n    require(params.onBehalfOf != loanData.bidderAddress, Errors.LP_CONSECUTIVE_BIDS_NOT_ALLOWED);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n\n    ValidationLogic.validateAuction(reserveData, nftData, nftConfig, loanData, params.bidPrice);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.loanAddress,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    uint256 maxPrice = vars.borrowAmount;\n\n    // Check if collection is supported by NFTX market\n    if (isMarketSupported[loanData.nftAsset][0]) {\n      uint256 priceNFTX = NFTXSeller.getNFTXPrice(\n        addressesProvider,\n        loanData.nftAsset,\n        loanData.nftTokenId,\n        loanData.reserveAsset\n      );\n      if (priceNFTX > maxPrice) {\n        maxPrice = priceNFTX;\n      }\n    }\n\n    // Check if collection is supported by SudoSwap market\n    if (isMarketSupported[loanData.nftAsset][1]) {\n      address[2] memory pairs = sudoswapPairs[loanData.nftAsset];\n      for (uint256 i = 0; i < 2; ) {\n        (, uint256 newSpotPrice, , , ) = ILSSVMPair(pairs[i]).getBuyNFTQuote(1);\n        if (newSpotPrice > maxPrice) {\n          maxPrice = newSpotPrice;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n\n    // first time bid need to burn debt tokens and transfer reserve to uTokens\n    if (loanData.state == DataTypes.LoanState.Active) {\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\n\n      // bid price must greater than liquidate price\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\n\n      // bid price must greater than biggest between borrow and markets price, as well as a timestamp configuration fee\n      require(\n        params.bidPrice >= (maxPrice + params.auctionDurationConfigFee),\n        Errors.LPL_BID_PRICE_LESS_THAN_MIN_BID_REQUIRED\n      );\n    } else {\n      // bid price must greater than borrow debt\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\n\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\n      }\n      vars.auctionEndTimestamp =\n        loanData.bidStartTimestamp +\n        vars.extraAuctionDuration +\n        (nftConfig.getAuctionDuration() * 1 minutes);\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\n\n      // bid price must greater than highest bid + delta\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\n    }\n\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\n      vars.initiator,\n      vars.loanId,\n      params.onBehalfOf,\n      params.bidPrice,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // lock highest bidder bid price amount to lend pool\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\n\n    // transfer (return back) last bid price amount to previous bidder from lend pool\n    if (loanData.bidderAddress != address(0)) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n    }\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, 0, 0);\n\n    emit Auction(\n      vars.initiator,\n      loanData.reserveAsset,\n      params.bidPrice,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      loanData.borrower,\n      vars.loanId\n    );\n  }\n\n  struct RedeemLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n    uint256 minRepayAmount;\n    uint256 maxRepayAmount;\n    uint256 bidFine;\n    uint256 redeemEndTimestamp;\n    uint256 minBidFinePct;\n    uint256 minBidFine;\n    uint256 extraRedeemDuration;\n    uint256 liquidationThreshold;\n  }\n\n  /**\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\n   * @dev Emits the `Redeem()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the redeem function\n   */ \n  function executeRedeem(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteRedeemParams memory params\n  ) external returns (uint256) {\n    RedeemLocalVars memory vars; \n    vars.initiator = params.initiator;\n \n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateRedeem(reserveData, nftData, nftConfig, loanData, params.amount);\n\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\n    }\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\n      vars.extraRedeemDuration +\n      nftConfig.getRedeemDuration() *\n      1 minutes);\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId, \n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // check bid fine in min & max range\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      nftConfig,\n      loanData,\n      vars.poolLoan,\n      vars.reserveOracle \n    );\n\n    // check bid fine is enough\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\n \n    vars.repayAmount = params.amount;  \n\n    // check the minimum debt repay amount, use liquidation threshold in config\n    (, vars.liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    vars.minRepayAmount = GenericLogic.calculateOptimalMinRedeemValue(\n      vars.borrowAmount,\n      params.nftAsset, \n      params.nftTokenId,\n      vars.nftOracle,\n      vars.liquidationThreshold,\n      params.safeHealthFactor\n    );\n      \n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\n \n    // check the maxinmum debt repay amount\n    vars.maxRepayAmount = GenericLogic.calculateOptimalMaxRedeemValue(vars.borrowAmount, vars.minRepayAmount);\n    \n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\n    \n    ILendPoolLoan(vars.poolLoan).redeemLoan(\n      vars.initiator,\n      vars.loanId,\n      vars.repayAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.repayAmount, 0);\n\n    // transfer repay amount from borrower to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n      vars.initiator,\n      reserveData.uTokenAddress,\n      vars.repayAmount\n    );\n\n    if (loanData.bidderAddress != address(0)) {\n      // transfer (return back) last bid price amount from lend pool to bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\n\n      // transfer bid penalty fine amount from borrower to the first bidder\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\n        vars.initiator,\n        loanData.firstBidderAddress,\n        vars.bidFine\n      );\n    }\n\n    emit Redeem(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      vars.bidFine,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount + vars.bidFine);\n  }\n\n  struct LiquidateLocalVars {\n    address initiator;\n    address poolLoan;\n    address reserveOracle;\n    address nftOracle;\n    uint256 loanId;\n    uint256 borrowAmount;\n    uint256 extraDebtAmount;\n    uint256 remainAmount;\n    uint256 auctionEndTimestamp;\n    uint256 extraAuctionDuration;\n  }\n\n  /**\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\n   * @dev Emits the `Liquidate()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param nftsConfig The state of the nft by tokenId\n   * @param poolStates The state of the lend pool\n   * @param params The additional parameters needed to execute the liquidate function\n   */\n  function executeLiquidate(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteLendPoolStates memory poolStates,\n    DataTypes.ExecuteLiquidateParams memory params\n  ) external returns (uint256) {\n    LiquidateLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[loanData.nftAsset][loanData.nftTokenId];\n\n    ValidationLogic.validateLiquidate(reserveData, nftData, nftConfig, loanData);\n\n    // If pool paused after bidding start, add pool pausing time as extra auction duration\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\n    }\n    vars.auctionEndTimestamp =\n      loanData.bidStartTimestamp +\n      vars.extraAuctionDuration +\n      (nftConfig.getAuctionDuration() * 1 minutes);\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    // Last bid price can not cover borrow amount\n    if (loanData.bidPrice < vars.borrowAmount) {\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\n    }\n\n    if (loanData.bidPrice > vars.borrowAmount) {\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\n    }\n\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\n      loanData.bidderAddress,\n      vars.loanId,\n      nftData.uNftAddress,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    IDebtToken(reserveData.debtTokenAddress).burn(\n      loanData.borrower,\n      vars.borrowAmount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, reserveData.uTokenAddress, vars.borrowAmount, 0);\n\n    // transfer extra borrow amount from liquidator to lend pool\n    if (vars.extraDebtAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\n    }\n\n    // transfer borrow amount from lend pool to uToken, repay debt\n    IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.uTokenAddress, vars.borrowAmount);\n\n    // transfer remain amount to borrower\n    if (vars.remainAmount > 0) {\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\n    }\n\n    // transfer erc721 to bidder.\n    //avoid DoS by transferring NFT to a malicious contract that reverts on ERC721 receive\n    (bool success, ) = address(loanData.nftAsset).call(\n      abi.encodeWithSignature(\n        \"safeTransferFrom(address,address,uint256)\",\n        address(this),\n        loanData.bidderAddress,\n        params.nftTokenId\n      )\n    );\n    //If transfer was made to a malicious contract, send NFT to treasury\n    if (!success)\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n        address(this),\n        IUToken(reserveData.uTokenAddress).RESERVE_TREASURY_ADDRESS(),\n        params.nftTokenId\n      );\n\n    emit Liquidate(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.borrowAmount,\n      vars.remainAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.extraDebtAmount);\n  }\n}\n","line":461,"range":[17747,17813]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,50,48,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033230320000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)



