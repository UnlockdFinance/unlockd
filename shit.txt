
> @unlockddao/unlockd-protocol@1.0.2 test
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/*.spec.ts


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/home/fvenancio/Documents/projects/unlockd/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  main
  - Provider URL: eth-mainnet.g.alchemy.com
  - Network : hardhat
Deployer: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 10000.0 ETH
PoolAdmin: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 10000.0 ETH
EmergencyAdmin: 0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d Balance: 10000.0 ETH
LendPool Liquidator: 0xA296478f65BCDA4153343c8D1f24D768110D6e16 Balance: 10000.0 ETH


Migration started


Deploy UNFT Registry


Deploy Lockey Holders
Deploying new Lockey Holders implementation...
contracts-helpers:insertContractAddressInDb, id: LockeyHolderImpl address 0xc0F76A7803950584503681bcD5849473ecafbB2f
*** LockeyHolder ***

Network: hardhat
tx: 0x599bed68b5825b55702494c8428b288f97c0a5af02b2e0834d8f793d40939fac
contract address: 0xc0F76A7803950584503681bcD5849473ecafbB2f
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 60853630960
gas used: 239234

******

contracts-helpers:registerContractInJsonDb, contractId: LockeyHolder address: 0xc0F76A7803950584503681bcD5849473ecafbB2f deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lockey holders implementation with address: 0xc0F76A7803950584503681bcD5849473ecafbB2f
contracts-helpers:insertContractAddressInDb, id: LockeyHolder address 0xFcf344175C046459b0fAdf10722A093281F5D13E


Deploy lend pool
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x5db6f9ecce8893e1566ccce22f0e8aa81517e8cb79ab2c6e05cad73e170925d9
contract address: 0xC7553877733B9cAfc396A254906f4dBFdE24F0D9
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 41949904321
gas used: 84290

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0xC7553877733B9cAfc396A254906f4dBFdE24F0D9 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ReserveLogic ***

Network: hardhat
tx: 0x39798497b77fb1b2f85f775d2fc0a982192f971750440f4ec154acf924a4c15a
contract address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 36900476872
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** NftLogic ***

Network: hardhat
tx: 0xb242521eee5bd5b3e3a04f4f35b7abd16609e577fdb6c670517879d35757a891
contract address: 0xbD6e36bE378a76bB77d197457aB4Db7D10E40078
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 32536339931
gas used: 141022

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0xbD6e36bE378a76bB77d197457aB4Db7D10E40078 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ValidationLogic ***

Network: hardhat
tx: 0x201f63bff9cc33d283e03e0f4920573173ca7e85dde9ce7a6b1d850cf1d109f4
contract address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 28683601009
gas used: 1573518

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** SupplyLogic ***

Network: hardhat
tx: 0x6168145c45a3a884fb52eb96d1be87e5fd5166bf851bc08232f41db760846b38
contract address: 0x295b757C168f986E920944D893C31Fb3A6a213A3
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 26097862620
gas used: 1235281

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0x295b757C168f986E920944D893C31Fb3A6a213A3 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** BorrowLogic ***

Network: hardhat
tx: 0xdf27c98625d2a4f911fcf5a3a9585f3a4075598a2485687ad1bbb5e7855dce3c
contract address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 23583178244
gas used: 2060203

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LiquidateLogic ***

Network: hardhat
tx: 0xd207dd1f144deb196ae6697d481d61eba9f28bd20417ab69569f7cf21dec51f7
contract address: 0x27681c27312e9410736EE2B8e32d04c79C58c8bd
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 21694536618
gas used: 5017191

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x27681c27312e9410736EE2B8e32d04c79C58c8bd deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0x02be62f1bfac52475c6888d65aaf9be01d1134c838f392bd5120afb555c058ec
contract address: 0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 21192628033
gas used: 3025524

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LendingLogic ***

Network: hardhat
tx: 0x4c7ce553fbaa1711af7ae06f51ac16e825c356d397aa08a061cf908bf3173b30
contract address: 0xA5D14177dbf569CDb551348ed00ABA0F1cAA7754
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 19895322235
gas used: 72217

******

contracts-helpers:registerContractInJsonDb, contractId: LendingLogic address: 0xA5D14177dbf569CDb551348ed00ABA0F1cAA7754 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ConfiguratorLogic ***

Network: hardhat
tx: 0xa459e252903b6a3ba598126d1dfb27dd67d123c58ea3266579c3726b5e5717b7
contract address: 0xe7f4c711a37065d73dEa91ca8d5d117e312EcBCb
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 17560807829
gas used: 1970106

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0xe7f4c711a37065d73dEa91ca8d5d117e312EcBCb deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
*** LendPool ***

Network: hardhat
tx: 0x20d0ba6c0b1d52690a11369ed98f051f61334e46aed2e4e0553f715a6e993bd2
contract address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 16145858394
gas used: 5327003

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool implementation with address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
contracts-helpers:insertContractAddressInDb, id: LendPool address 0xFC7f036a8FB66D031675239413F9179A82932a53
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
*** LendPoolLoan ***

Network: hardhat
tx: 0x17d79fd809902c773fb07f3c4784f8eba0a152466dca0d644a938c5eff4c0417
contract address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 14026600594
gas used: 3445719

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool loan implementation with address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x00da789CEBF4A0da965FbcB9e4d72F1A15c67Eb6
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F
*** LendPoolConfigurator ***

Network: hardhat
tx: 0x39cb26fbd1e527f012894fd2c03d88acde713bfceea0973c94b3e17ea9322bdd
contract address: 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 11772868751
gas used: 5230541

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool configurator implementation with address: 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0x82CefdbdFe6c4A868962E7B78A3CE54f952FE209
Deploying new generic UToken implementation...
*** UToken ***

Network: hardhat
tx: 0xa25a2a0d85b5aa75df5a173537a7b1dd43439c16efdcaff864ad4eef5435e6d1
contract address: 0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 9106926301
gas used: 2710730

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Upgrading UTokens with implementation  0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e
{ WETH: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' }
[
  '0xE6cd031FB0D9A79FD8CD3035B9228F78ff459B07',
  '800000000000000000000000000',
  '200000000000000000000000000',
  '160000000000000000000000000',
  '2000000000000000000000000000'
]
*** InterestRate ***

Network: hardhat
tx: 0xff1a7bc3893905bd32b645d89dcdce8cf426d0b4efa81c36f4487828431eef09
contract address: 0x7489ffcbf0b09a171DBae5c7bedc594DE54A137F
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 6072658433
gas used: 613848

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x7489ffcbf0b09a171DBae5c7bedc594DE54A137F deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address undefined


Deploy reserve oracle
PROXY admin: 0xb7493E15Af772c14c7cE3180Ff388925e6593c6b
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d
*** ReserveOracle ***

Network: hardhat
tx: 0xc5a1d1e14cfc8b7c0965ca8d93a8a1983cf8b2d897dc4096ce3bad81f18fd053
contract address: 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 4944444778
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x42a426b0f2e1e068f9baf198dd6783261e8e532cf3dc39f10ca62e28592193ff
contract address: 0x0d5A790175C95fd1fC032bb066f1166fBDCa155f
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 4547356255
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x0d5A790175C95fd1fC032bb066f1166fBDCa155f deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Reserve Oracle: proxy 0x0d5A790175C95fd1fC032bb066f1166fBDCa155f, implementation 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0xea44f19c6c0581e368552bf0ccd6e3e8871db4acad9c97f4c80f842af564ca29
contract address: 0xf0931526d7914202cB559fe6d618777Ba71b0802
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 3421327436
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0xf0931526d7914202cB559fe6d618777Ba71b0802 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xd64baed9d61c8c7ab7768672f2f2902664b366a491f57ae56d2bf4b05384f835
contract address: 0xEa18252aDf22a410CA147433c59BC28Ed193d4C0
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2912294392
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0xEa18252aDf22a410CA147433c59BC28Ed193d4C0 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0


Deploy nft oracle
Reuse existed nft oracle: 0xed1a46EBE904dD6562f5F20A515009752Fb5bAdE
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0x972e8cb573ecfce8ea714e76a6b2a9bc8ee501b36a04ce43a5bac950b9983f24
contract address: 0x8c0a772Eb79b6d52678Fa82449eA4cd95bC93763
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2485874067
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x8c0a772Eb79b6d52678Fa82449eA4cd95bC93763 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0


Initialize lend pool
Setting YVaultWETH with address:  0xa258C4606Ca8206D8aA700cE2143D7db854D168c  in addressesProvider...


Deploy WETH Gateway


Deploy PUNK Gateway


Deploy data provider
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0x418f2129128f54d72ab3ff467ee1ae91cf566182ea70fc1ff7aa43eb25d5ca73
contract address: 0x012b3ddB46cFD5b122e6D551dDD07afd71596586
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2024772311
gas used: 2891625

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0x012b3ddB46cFD5b122e6D551dDD07afd71596586 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
UnlockdProtocolDataProvider deployed at: 0x012b3ddB46cFD5b122e6D551dDD07afd71596586


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 44
UnlockdProxyAdminPool: 0xb7493E15Af772c14c7cE3180Ff388925e6593c6b
NFTOracleImpl: 0x07AfB905B34EF28505283a09a94603e9B40C3f31
NFTOracle: 0xed1a46EBE904dD6562f5F20A515009752Fb5bAdE
CryptoPunksMarket: 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
WrappedPunk: 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6
UnlockdProxyAdminFund: 0x38a97DE7216b54FCc83A918CF5dB1Bb0447913a4
LendPoolAddressesProvider: 0xE6cd031FB0D9A79FD8CD3035B9228F78ff459B07
LendPoolAddressesProviderRegistry: 0xe5BF48BC5Fd3FCD1c7Fc76795C7b08ccc139a949
ReserveLogic: 0x102Ca0665b83f1B01497E4afD0088FA7d645C5C1
NftLogic: 0x6dF83F6ba030C420d602E9a4302DB8f1DeEDd712
GenericLogic: 0x5520945C3261a51D8e014De4389acC51Fc926b9e
ValidationLogic: 0x8749e3e58A437ecA1B7dfA7046c99a51Cd784Def
SupplyLogic: 0xBA92072f11bbd7492f3419D1dfc85d6FFf730685
BorrowLogic: 0x25d2B642B2a485958a6A00c19f37082AbFF276Cd
LiquidateLogic: 0x91212942a1cda9342ffEF653Dc73e0130688f9F3
ConfiguratorLogic: 0x0919A0c32D7578F507760986a693D2E3D0E598a0
LendPoolImpl: 0x4216Ac4Ad3C6838889Cc80aa5E34e6F57e7839B6
LendPool: 0xFC7f036a8FB66D031675239413F9179A82932a53
LendPoolLoanImpl: 0x6FfD77E502b561E08CdE65C311bf920d9FE1dB88
LendPoolLoan: 0x00da789CEBF4A0da965FbcB9e4d72F1A15c67Eb6
LendPoolConfiguratorImpl: 0xC4576F34dfeFd15011947E787e818ad490F7df37
LendPoolConfigurator: 0x82CefdbdFe6c4A868962E7B78A3CE54f952FE209
UToken: 0x13D3f5C8FC7c05e7cc2d60690381aaB016137300
DebtToken: 0xE4Bc9E74428b5E8C4fAdB53D5eF39C9A9902909c
ReserveOracleImpl: 0x71a22E1b4D1113CF82898caf709F8F0190FBAaC2
ReserveOracle: 0x2954B6ce3E9788e2A6dE603358918f2eb067AABa
InterestRate: 0x2c8C82fBEA936860BD7b20a756E098360cBAF05B
rateStrategyWETH: 0x2c8C82fBEA936860BD7b20a756E098360cBAF05B
WETHGatewayImpl: 0xFbD2Bcee595C6dd9897d09F8aac4dE4d25Da2406
WETHGateway: 0x66CD472E4404D0C62d7068b4D69e28D5Ed6C32c2
PunkGatewayImpl: 0xf49c6c3A753643eF9a31A1cfBD1d38e364A1637c
PunkGateway: 0x2540b104310EFa795DE0a9247Ba3942b71385251
WalletBalanceProvider: 0x95F9b68e4F8dC809127B1A3437b3531197E273Ea
UnlockdProtocolDataProvider: 0x4ABde724f8d7CB5ec7b22A9b86824591bE9fDc86
UIPoolDataProvider: 0x2CF74101dF653E166Cbf699EeED6FaB599293BcD
WPUNKS: 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6
BAYC: 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
DOODLE: 0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e
AZUKI: 0xED5AF388653567Af2F388E6224dC7C4b3241C544
MockIncentivesController: 0xf40a2617170af5d8079D7a476F6475b2106328D4
UNFT: 0x1014BBC1ED63CC49e6118769D412E715A1cEbCD8
UNFTRegistryImpl: 0xC048366Bd89c48Abb763bB5d4c436b6990c241E9
UNFTRegistry: 0x255f25335662c88Fcc7deC402cADf2f4f0E08300
LiquidateMarketsLogic: 0xB7BBE03f2E0F384DA800aD3c4E29e0C3b70Da7D9 

Deployer: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 9999.346776737066926943
PoolAdmin: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 9999.346776737066926943
EmergencyAdmin: 0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d Balance: 9999.998649141438865794
LendPoolLiquidator: 0xA296478f65BCDA4153343c8D1f24D768110D6e16 Balance: 10000.0
-> Initialize make suite...
uDai undefined
uUSDC undefined
uWETH 0x302Ceac15678E3238D19a0C4714533701169C217
daiAdd undefined
usdcAdd undefined
wethAdd 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

***************
Setup and snapshot finished
***************

  LendPoolAddressesProvider
    âœ“ Test the accessibility of the LendPoolAddressesProvider
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x84b09F1B0F78E5d60FF7219052BD730F4acE8666
*** LendPool ***

Network: hardhat
tx: 0x447105f442ed29989153ea01740ae4d4a6f8abc4e6e90b58286468b5e2149555
contract address: 0x84b09F1B0F78E5d60FF7219052BD730F4acE8666
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1563628100
gas used: 5327003

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x84b09F1B0F78E5d60FF7219052BD730F4acE8666 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
    âœ“ Tests adding a proxied address with `setAddressAsProxy()`
    âœ“ Tests adding a non proxied address with `setAddress()`
    âœ“ Tests specific non-proxied addresses set via `setAddress()`

  LendPool: Borrow/repay test cases
    âœ“ Delegatee try to Borrow WETH to different onBehalf

  LendPool: Borrow negative test cases
    âœ“ Users 0 Deposits 100 WETH and user 1 tries to borrow 0 WETH (revert expected)
    âœ“ User 1 tries to use underpriced NFT as collateral to borrow 100 WETH (revert expected)
    âœ“ User 2 tries to uses user 1 owned NFT as collateral to borrow 10 WETH (revert expected)
    âœ“ Users 0 Deposits 100 WETH and user 1 tries to borrow but the timestamp exceeds

  LendPool: Borrow/repay test cases
    âœ“ User 2 deposits 1 WETH and 1000 DAI to account for rounding errors
    âœ“ User 0 deposits 100 WETH, user 1 uses NFT as collateral and borrows 1 WETH
    âœ“ User 1 uses existed collateral and borrows more 100 DAI (revert expected)
    âœ“ User 1 uses existed collateral and borrows more 2 WETH
    âœ“ User 1 tries to borrow more than the rest of the WETH liquidity (revert expected)
    âœ“ User 1 tries to repay 0 WETH (revert expected)
    âœ“ User 1 repays 0.5 WETH, enough to cover a small part of the interest
    âœ“ User 1 repays all WETH borrow after one year
    âœ“ User 0 withdraws the deposited WETH plus interest
    âœ“ User 1 deposits 1 USDC to account for rounding errors
    âœ“ User 1 deposits 1000 USDC, user 3 uses not owned NFT as collateral and borrows 10 USDC
    âœ“ user 2 uses owned NFT as collateral on behalf of user 3 and borrows 10 USDC
    âœ“ user 2 uses existed collateral on behalf of user 3 and borrows more 20 USDC
    âœ“ user 3 repay 10 USDC, a fraction of borrow amount
    âœ“ user 3 repay all USDC, full of borrow amount

  LendPool: buyout test cases
    âœ“ Borrower - Borrows WETH
    âœ“ Buyer tries to buy with HF above 1
    âœ“ Health Factor goes below 1
    âœ“ Buyer - tries to buy the NFT with a wrong tokenId
    âœ“ Buyer - tries to buy the NFT with a smaller amount than debt
    âœ“ Buyer - tries to buy the NFT with an amount higher than debt lower then valuation

  LendPool: buyout test cases
    âœ“ Borrower - Borrows WETH
    âœ“ Health Factor goes below 1
    âœ“ Buyer - buys out the NFT in auction
    âœ“ Lockey Holder: Borrower - Borrows WETH
    âœ“ Lockey Holder: Health Factor goes below 1
Balance before:  1771428571428571428570

    1) Lockey Holder: Buyer - buys out the NFT in auction and deducts because his a lockey holder.

  Configurator-NFT
    âœ“ Deactivates the BAYC NFT
    âœ“ Deactivates the BAYC NFT Token
    âœ“ Rectivates the BAYC NFT
    âœ“ Rectivates the BAYC NFT Token
    âœ“ Check the onlyAdmin on deactivateRNft 
    âœ“ Check the onlyAdmin on activateNft 
    âœ“ Freezes the BAYC NFT
    âœ“ Freezes the BAYC NFT Token
    âœ“ Unfreezes the BAYC NFT
    âœ“ Unfreezes the BAYC NFT Token
    âœ“ Check the onlyAdmin on freezeNft 
    âœ“ Check the onlyAdmin on unfreezeNft 
    âœ“ Deactivates the BAYC NFT as collateral
    âœ“ Activates the BAYC NFT as collateral
    âœ“ Check the onlyLtvManager on configureNftAsCollateral 
    âœ“ Deactivates the BAYC NFT as auction
    âœ“ Activates the BAYC NFT as auction
    âœ“ Check the onlyLtvManager on configureNftAsAuction 
    âœ“ Batch Deactivates the BAYC NFT as collateral
    âœ“ Batch Activates the BAYC NFT as collateral
    âœ“ Check the onlyAdmin on batchConfigNft 
    âœ“ Batch Deactivates the BAYC NFT as auction
    âœ“ Batch Activates the BAYC NFT as auction
    âœ“ Reverts when trying to disable the BAYC nft with liquidity on it
    âœ“ Config setMaxNumberOfNfts invalid value
    âœ“ Config setMaxNumberOfNfts invalid value overflowing
    âœ“ Check the onlyAdmin on setMaxNumberOfNfts 
    âœ“ Config the timeFrame for an X amount of time
    âœ“ Check if the config timestamp is correct
    âœ“ Check if general configurations are correct
    âœ“ Check the zero check on set rescuer
    âœ“ (LendPool): Check the only pool admin in safe health factor 
    âœ“ (LendPool): Check invalid 0 value in safe health factor 
    âœ“ (LendPool): Check correct value in safe health factor 

  Configurator-Reserve
    âœ“ Reverts trying to set an invalid reserve factor
    âœ“ Rectivates the ETH reserve
    âœ“ Check the onlyAdmin on deactivateReserve 
    âœ“ Check the onlyAdmin on activateReserve 
    âœ“ Freezes the ETH reserve
    âœ“ Unfreezes the ETH reserve
    âœ“ Check the onlyAdmin on freezeReserve 
    âœ“ Check the onlyAdmin on unfreezeReserve 
    âœ“ Deactivates the ETH reserve for borrowing
    âœ“ Activates the ETH reserve for borrowing
    âœ“ Check the onlyAdmin on disableBorrowingOnReserve 
    âœ“ Check the onlyAdmin on enableBorrowingOnReserve 
    âœ“ Changes the reserve factor of WETH
    âœ“ Check the onlyLendPoolManager on setReserveFactor
    âœ“ Batch Changes the reserve factor of WETH & DAI
    âœ“ Check the onlyPoolAdmin on batchConfigReserve
    âœ“ Reverts when trying to disable the DAI reserve with liquidity on it
    âœ“ Config setMaxNumberOfReserves valid value
    âœ“ Config setMaxNumberOfReserves invalid value
    âœ“ Config setMaxNumberOfReserves invalid value overflow
    âœ“ Check the onlyAdmin on setMaxNumberOfReserves 

  DataProvider
    âœ“ Borrows WETH using 1 BAYC
    âœ“ Query UI Reserve Data
    âœ“ Query UI NFT Data
    âœ“ Query UI Loan Data
    âœ“ Query Wallet Reserve Data
    âœ“ Query Wallet NFT Data

  LendPool: Deposit
    âœ“ User 0 Deposits 1000 DAI in an empty reserve
    âœ“ User 1 deposits 1000 DAI after user 0
    âœ“ User 0 deposits 1000 USDC in an empty reserve
    âœ“ User 1 deposits 1000 USDC after user 0
    âœ“ User 0 deposits 1 WETH in an empty reserve
    âœ“ User 1 deposits 1 WETH after user 0
    âœ“ User 1 deposits 0 WETH (revert expected)
    âœ“ User 1 deposits 0 DAI (revert expected)
    âœ“ User 1 deposits 100 DAI on behalf of user 2, user 2 tries to borrow 0.01 WETH

  Interest rate tests
*** InterestRate ***

Network: hardhat
tx: 0x0d12e102d3b0d4617359ead86d541c4411b7060086ec2110e208ec2298b86f93
contract address: 0x71787a4bcdBfB86D63e332b1aAdA0727DFbf491F
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1643723234
gas used: 613860

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x71787a4bcdBfB86D63e332b1aAdA0727DFbf491F deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
    âœ“ Checks rates at 0% utilization rate, empty reserve
    âœ“ Checks rates at 80% utilization rate
    âœ“ Checks rates at 100% utilization rate

  LendPool: Malicious Hacker Rentrant
hacker do reentrant action: ACTION_DEPOSIT
hacker do reentrant action: ACTION_WITHDRAW
hacker do reentrant action: ACTION_BORROW
hacker do reentrant action: ACTION_REPAY
hacker do reentrant action: ACTION_AUCTION
hacker do reentrant action: ACTION_REDEEM
hacker do reentrant action: ACTION_LIQUIDATE_NFTX
    âœ“ Malicious hacker try to reentrant (should revert)

  LendPool: Liquidation negative test cases
    âœ“ User 0 deposit 100 WETH, user 1 mint NFT and borrow 10 WETH
    âœ“ User 1 liquidate on a non-existent NFT
    âœ“ User 2 auction on a loan health factor above 1
    âœ“ Drop loan health factor below 1
    âœ“ User 2 auction price is unable to cover borrow
    âœ“ User 2 auction price is less than liquidate price
    âœ“ User 2 auction price is enough to cover borrow and liqudiate price
    âœ“ User 3 auction price is lesser than user 2
    âœ“ User 2 liquidate before auction duration is end
    âœ“ User 1 redeem but bidFine is not fullfil to borrow amount of user 2 auction
    âœ“ User 1 redeem but amount is not fullfil to mininum repay amount
    âœ“ User 1 redeem but amount is not fullfil to maximum repay amount
    âœ“ Ends redeem duration
    âœ“ User 1 redeem after duration is end
    âœ“ Ends auction duration
    âœ“ User 3 auction after duration is end
    âœ“ User 2 auction consecutively

  LendPool: Liquidation
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Auctions the borrow
    âœ“ WETH - Can't liquidate on NFTX due to invalid loan state
    âœ“ USDC - Borrows USDC
    âœ“ USDC - Drop the health factor below 1
    âœ“ USDC - Auctions the borrow at first time
    âœ“ USDC - Auctions the borrow at second time with higher price
    âœ“ USDC - Can't liquidate on NFTX

  LendPool: Liquidation
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ USDC - Borrows USDC
    âœ“ USDC - Drop the health factor below 1

  LendPool: Redeem
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Auctions the borrow
    âœ“ WETH - Redeems the borrow
    âœ“ WETH - Repays the borrow
    âœ“ DAI - Borrows DAI
    âœ“ DAI - Drop the health factor below 1
    âœ“ DAI - Auctions the borrow
    âœ“ DAI - Redeems the borrow
    âœ“ DAI - Repays the borrow

  LendPool: Liquidation
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Auctions the borrow
    âœ“ WETH - Liquidates the borrow
    âœ“ USDC - Borrows USDC
    âœ“ USDC - Drop the health factor below 1
    âœ“ USDC - Auctions the borrow at first time
    âœ“ USDC - Auctions the borrow at second time with higher price
    âœ“ USDC - Liquidates the borrow

  LendPool: Liquidation on SudoSwap
    âœ“ WETH - Borrows WETH
    âœ“ WETH - Drop the health factor below 1
    âœ“ WETH - Liquidates the borrow on SudoSwap
    âœ“ DAI - Borrows DAI
    âœ“ DAI - Drop the health factor below 1
    âœ“ DAI - Liquidates the borrow on SudoSwap

  LendPoolLoan: Modifiers
    âœ“ Tries to invoke initNft not being the Pool
    âœ“ Tries to invoke createLoan not being the Pool
    âœ“ Tries to invoke updateLoan not being the Pool
    âœ“ Tries to invoke repayLoan not being the Pool
    âœ“ Tries to invoke auctionLoan not being the Pool
    âœ“ Tries to invoke redeemLoan not being the Pool
    âœ“ Tries to invoke liquidateLoan not being the Pool
    âœ“ Tries to invoke liquidateLoanNFTX not being the Pool

  NFTOracle: General functioning
    âœ“ Set Admin correctly
    âœ“ Set and get Mocknft price at 1000
    âœ“ Add 2 Multi Assets
    âœ“ Add 3 Multi Assets
    âœ“ Add 3 Multi Assets - BigNumbers
    âœ“ Single asset price updates
    âœ“ Multiple asset price updates

  NFTOracle: Reverting Errors
    âœ“ Should be reverted as NFTOracle is already initialized
    âœ“ Should be reverted as it is a non-existing collection
    âœ“ Should be reverted as price is 0
    âœ“ Should be reverted as the collection has been deleted
    âœ“ Should be reverted as contract is paused
    âœ“ Should be reverted as array lengths aren't matching (2 vs 3)
    âœ“ Testing overflows

  NFTOracle: Test Pause
    âœ“ Should revert as collection is paused
    âœ“ Should revert on multi-paused collections

  LendPool: Pause
    âœ“ Transfer
    âœ“ Deposit
    âœ“ Withdraw
    âœ“ Borrow
    âœ“ Repay
    âœ“ Liquidate
    âœ“ LiquidateNFTX

  PunkGateway: Delegate
    âœ“ Hacker try to borrow and delegate different onBehalf (should revert)
    âœ“ Hacker try to auction and delegate different onBehalf (should revert)

  PunkGateway
USER: 0x0756cCC18E390dbdD0F9855A3B38458bb6157E31
    âœ“ Owner can do emergency CryptoPunks recovery
    âœ“ Should fail: not supported collection
    âœ“ Should fail: not holder
    âœ“ Check approve valuation on cryptopunks
    âœ“ Borrow some USDC and repay it
AVAILABLE LIQUIDITY AFTER FIRST BORROW: 177770826290145056847
AVAILABLE LIQUIDITY AFTER SECOND BORROW: 175770826290145056847
    âœ“ Borrow some ETH and repay it
    âœ“ Borrow all ETH and repay it

  PunkGateway-Liquidate
    âœ“ Borrow USDC and liquidate it
    âœ“ Borrow ETH and liquidate it
    âœ“ Borrow ETH and redeem it

  Repay and transfer helper tests
    âœ“ borrow-repay-transfer

  LendPool: Rescue locked funds
BigNumber { value: "1000000000000000000000" }
    âœ“ User 1 transfers 100 WETH directly to pool, and rescuer returns funds
BigNumber { value: "1000000000000000000000" }
    âœ“ Prevents a random user from rescuing tokens 

  ReserveOracle
    âœ“ ReserveOracle: Add Aggregator
    âœ“ ReserveOracle: Remove Aggregator
    âœ“ ReserveOracle: get latest price
    âœ“ ReserveOracle: get eth price
    âœ“ ReserveOracle: get latest timestamp
    ReserveOracle-TWAP
      âœ“ twap price
      âœ“ asking interval more than asset has
      âœ“ asking interval less than asset has
      âœ“ given variant price period
      âœ“ latest price update time is earlier than the request, return the latest price
      âœ“ get 0 while interval is zero

  Upgradeability
    âœ“ Tries to update the WETH UToken implementation with a different address than the configuator
    âœ“ Upgrades the WETH UToken implementation 
    âœ“ Tries to update the weth DebtToken implementation with a different address than the configuator
    âœ“ Upgrades the weth DebtToken implementation 
    âœ“ Tries to update the LendPoolLoan implementation with a different address than the address provider
    âœ“ Upgrades the LendPoolLoan implementation 

  UToken: Modifiers
    âœ“ Tries to invoke mint not being the Pool
    âœ“ Tries to invoke burn not being the Pool
    âœ“ Tries to invoke mintToTreasury not being the Pool
    âœ“ Tries to invoke transferUnderlyingTo not being the Pool
    âœ“ Tries to invoke depositReserves not being the Pool
    âœ“ Tries to invoke withdrawReserves not being the Pool
    âœ“ Tries to invoke sweepUToken not being the PoolAdmin

  UToken
    âœ“ Check WETH basic parameters
    âœ“ Check the onlyAdmin on set treasury to new utoken
    âœ“ Check the zero check on set treasury to new utoken
    âœ“ Check the address is properly updated in WETH uToken
    âœ“ 10 WETH are sent to UToken, sweep deposits them into Yearn Vault
    âœ“ User 8 deposits 1000 WETH, transfers uweth to user 6

  WETHGateway - Delegate
    âœ“ Hacker try to delegate different onBehalf (should revert)
    âœ“ Borrower try to Borrow more ETH to different onBehalf (should revert)
Hacker try Borrow more ETH with others NFT
    âœ“ Hacker try to Borrow more ETH (should revert)

  WETHGateway
    âœ“ Deposit WETH via WethGateway 
    âœ“ Withdraw WETH - Partial
    âœ“ Withdraw WETH - Full
    âœ“ Borrow WETH and Full Repay with ETH
Partial Repay ETH loan with native ETH
Full Repay ETH loan with native ETH
    âœ“ Borrow ETH and Full Repay with ETH
    âœ“ Should revert if receiver function receives Ether if not WETH
    âœ“ Should revert if fallback functions is called with Ether
    âœ“ Should revert if fallback functions is called
    âœ“ Owner can do emergency ERC20 recovery
    âœ“ Owner can do emergency ERC721 recovery
*** SelfdestructTransferMock ***

Network: hardhat
tx: 0x02550a870938b20a22e5ea94be17e0377d59cab268a9d0cf4ebcf3938bb0290d
contract address: 0x6be10f061Db0B5f3bB44e9748DB40885Bf756993
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1000071674
gas used: 88001

******

contracts-helpers:registerContractInJsonDb, contractId: SelfdestructTransferMock address: 0x6be10f061Db0B5f3bB44e9748DB40885Bf756993 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
    âœ“ Owner can do emergency native ETH recovery

  WETHGateway - Liquidate
    âœ“ Borrow ETH and Liquidate it
    âœ“ Borrow ETH and Redeem it

  LendPool: Withdraw negative test cases
    âœ“ Users 0 Deposits 1000 DAI and tries to withdraw 0 DAI (revert expected)
    âœ“ Users 0 tries to withdraw 1100 DAI from the 1000 DAI deposited (revert expected)
    âœ“ Users 1 borrows 100 DAI, users 0 tries to withdraw the 1000 DAI deposited (revert expected)
    âœ“ Users 1 deposits 1 WETH, users 0 borrows 0.01 WETH, users 1 tries to withdraw the 1 WETH deposited (revert expected)

  LendPool: Withdraw
    âœ“ User 0 Deposits 1000 DAI in an empty reserve
    âœ“ User 0 withdraws half of the deposited DAI
    âœ“ User 0 withdraws remaining half of the deposited DAI
    âœ“ User 0 Deposits 1 WETH in an empty reserve

    2) User 0 withdraws half of the deposited WETH
    âœ“ User 0 tries to withdraw remaining half of the deposited WETH (expect revert due to not enough liquidity)

    3) User 0 tries to withdraw remaining half of the deposited WETH 
    âœ“ Users 0 and 1 Deposit 1000 DAI, both withdraw
    âœ“ Users 0 deposits 1000 DAI, user 1 Deposit 1000 USDC and 1 WETH, borrows 100 DAI. User 1 tries to withdraw all the USDC

  UToken: Yearn integration
    âœ“ User 0 deposits 10 WETH in an empty reserve, WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    âœ“ User 1 deposits 10 WETH in the reserve, WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    âœ“ User 0 withdraws 10 WETH, WETH is withdrawn from the Yearn Vault and WETH is given back to user
    âœ“ User 2 deposits 1000 WETH in the reserve. WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    âœ“ User 2 withdraws 500 WETH from the reserve, then 500 more. WETH is withdrawn from Yearn Vault and WETH is given back to user

Â·---------------------------------------------------------------|---------------------------|-------------|-----------------------------Â·
|                      [90mSolc version: 0.8.4[39m                      Â·  [90mOptimizer enabled: true[39m  Â·  [90mRuns: 200[39m  Â·  [90mBlock limit: 12450000 gas[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mMethods[22m[39m                                                                                                                              â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [1mContract[22m                   Â·  [1mMethod[22m                         Â·  [32mMin[39m        Â·  [32mMax[39m        Â·  [32mAvg[39m        Â·  [1m# calls[22m      Â·  [1meur (avg)[22m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m          Â·  offerPunkForSaleToAddress      Â·          -  Â·          -  Â·     119766  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mCryptoPunksMarket[39m          Â·  transferPunk                   Â·      [36m43479[39m  Â·      [31m65379[39m  Â·      57099  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m           Â·  approve                        Â·      [36m26200[39m  Â·      [31m53948[39m  Â·      42522  Â·          [90m101[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m           Â·  transfer                       Â·      [36m34494[39m  Â·     [31m155203[39m  Â·      50263  Â·          [90m105[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC20Upgradeable[39m           Â·  transferFrom                   Â·      [36m67168[39m  Â·     [31m124787[39m  Â·     109375  Â·           [90m53[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC721Upgradeable[39m          Â·  safeTransferFrom               Â·          -  Â·          -  Â·     123319  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC721Upgradeable[39m          Â·  setApprovalForAll              Â·      [36m26173[39m  Â·      [31m46280[39m  Â·      40985  Â·           [90m68[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setAddress                     Â·      [36m29481[39m  Â·      [31m49381[39m  Â·      42423  Â·           [90m27[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setAddressAsProxy              Â·     [36m633514[39m  Â·     [31m699899[39m  Â·     666707  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setLendPoolConfiguratorImpl    Â·          -  Â·          -  Â·      43350  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setLendPoolImpl                Â·          -  Â·          -  Â·      43351  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setLendPoolLiquidator          Â·          -  Â·          -  Â·      30343  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setLendPoolLoanImpl            Â·          -  Â·          -  Â·      43396  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setNFTOracle                   Â·          -  Â·          -  Â·      27521  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setReserveOracle               Â·          -  Â·          -  Â·      30254  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolAddressesProvider[39m  Â·  setUnlockdDataProvider         Â·          -  Â·          -  Â·      30321  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  batchConfigNft                 Â·      [36m88027[39m  Â·      [31m90911[39m  Â·      90128  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  configureNftAsAuction          Â·      [36m68252[39m  Â·      [31m68288[39m  Â·      68270  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  configureNftsAsCollateral      Â·      [36m96973[39m  Â·     [31m133973[39m  Â·     110641  Â·           [90m42[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setActiveFlagOnNft             Â·      [36m78168[39m  Â·      [31m83773[39m  Â·      80971  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setActiveFlagOnNftByTokenId    Â·      [36m69707[39m  Â·      [31m69719[39m  Â·      69713  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setActiveFlagOnReserve         Â·          -  Â·          -  Â·      63834  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setBorrowingFlagOnReserve      Â·      [36m66580[39m  Â·      [31m66604[39m  Â·      66592  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setFreezeFlagOnNft             Â·      [36m66643[39m  Â·      [31m66656[39m  Â·      66650  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setFreezeFlagOnNftByTokenId    Â·      [36m69637[39m  Â·      [31m69649[39m  Â·      69643  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setFreezeFlagOnReserve         Â·      [36m66583[39m  Â·      [31m66595[39m  Â·      66589  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setLtvManagerStatus            Â·      [36m39630[39m  Â·      [31m59530[39m  Â·      47093  Â·           [90m56[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setNftMinBidFine               Â·      [36m68059[39m  Â·      [31m68083[39m  Â·      68071  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setNftRedeemThreshold          Â·      [36m68102[39m  Â·      [31m68126[39m  Â·      68114  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setPoolPause                   Â·      [36m64331[39m  Â·      [31m84074[39m  Â·      74203  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setPoolRescuer                 Â·      [36m63903[39m  Â·      [31m81003[39m  Â·      72453  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setReserveFactor               Â·          -  Â·          -  Â·      66877  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  setReserveInterestRateAddress  Â·          -  Â·          -  Â·      66158  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  updateDebtToken                Â·          -  Â·          -  Â·      89468  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLendPoolConfigurator[39m       Â·  updateUToken                   Â·          -  Â·          -  Â·      89358  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mLockeyHolder[39m               Â·  setLockeyDiscountPercentage    Â·          -  Â·          -  Â·      58741  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMaliciousHackerERC721[39m      Â·  approveDelegate                Â·          -  Â·          -  Â·      87473  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMaliciousHackerERC721[39m      Â·  simulateAction                 Â·      [36m26483[39m  Â·      [31m43583[39m  Â·      28926  Â·            [90m7[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockChainlinkOracle[39m        Â·  mockAddAnswer                  Â·     [36m125897[39m  Â·     [31m245509[39m  Â·     149398  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockDebtTokenVersionN[39m      Â·  approveDelegation              Â·      [36m39048[39m  Â·      [31m56148[39m  Â·      50893  Â·           [90m20[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockIncentivesController[39m   Â·  resetHandleActionIsCalled      Â·      [36m26786[39m  Â·      [31m29026[39m  Â·      27672  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  approveValuation               Â·      [36m64013[39m  Â·      [31m71522[39m  Â·      66516  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  auction                        Â·     [36m474408[39m  Â·     [31m474432[39m  Â·     474422  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  borrow                         Â·     [36m427097[39m  Â·     [31m927504[39m  Â·     885701  Â·           [90m24[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  buyOut                         Â·          -  Â·          -  Â·     760970  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  deposit                        Â·     [36m288114[39m  Â·     [31m341342[39m  Â·     313612  Â·           [90m45[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  liquidate                      Â·          -  Â·          -  Â·     664937  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  liquidateSudoSwap              Â·          -  Â·          -  Â·     683948  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  redeem                         Â·          -  Â·          -  Â·     434262  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  repay                          Â·     [36m359949[39m  Â·     [31m669972[39m  Â·     531242  Â·            [90m7[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  rescue                         Â·          -  Â·          -  Â·      57154  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  setIsMarketSupported           Â·      [36m58528[39m  Â·      [31m78452[39m  Â·      60194  Â·           [90m48[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  setMaxNumberOfReserves         Â·          -  Â·          -  Â·      62719  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  setTimeframe                   Â·      [36m58143[39m  Â·      [31m60955[39m  Â·      59497  Â·           [90m25[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  updateSafeHealthFactor         Â·      [36m40218[39m  Â·      [31m43018[39m  Â·      42543  Â·            [90m6[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockLendPoolVersionN[39m       Â·  withdraw                       Â·     [36m317345[39m  Â·     [31m321852[39m  Â·     318472  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  addCollection                  Â·          -  Â·          -  Â·      47505  Â·           [90m13[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  initialize                     Â·          -  Â·          -  Â·     113794  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  removeCollection               Â·          -  Â·          -  Â·      25685  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  setMultipleNFTPrices           Â·      [36m62686[39m  Â·      [31m84325[39m  Â·      73684  Â·            [90m3[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  setNFTPrice                    Â·      [36m33049[39m  Â·      [31m60368[39m  Â·      43561  Â·           [90m79[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  setPause                       Â·      [36m27850[39m  Â·      [31m49762[39m  Â·      38806  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockNFTOracle[39m              Â·  setPriceManagerStatus          Â·      [36m33894[39m  Â·      [31m53794[39m  Â·      38956  Â·           [90m60[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m          Â·  addAggregator                  Â·      [36m75602[39m  Â·      [31m92702[39m  Â·      89282  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m          Â·  initialize                     Â·          -  Â·          -  Â·      90917  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m          Â·  mock_setBlockTimestamp         Â·          -  Â·          -  Â·      26541  Â·            [90m7[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m          Â·  removeAggregator               Â·      [36m33119[39m  Â·      [31m37640[39m  Â·      34023  Â·            [90m5[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockReserveOracle[39m          Â·  setAggregators                 Â·          -  Â·          -  Â·     101406  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockUTokenVersionN[39m         Â·  setTreasuryAddress             Â·      [36m43287[39m  Â·      [31m43299[39m  Â·      43293  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mMockUTokenVersionN[39m         Â·  sweepUToken                    Â·     [36m121166[39m  Â·     [31m134846[39m  Â·     128006  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mProxyAdmin[39m                 Â·  transferOwnership              Â·          -  Â·          -  Â·      28645  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  auctionETH                     Â·          -  Â·          -  Â·     530404  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  authorizeCallerWhitelist       Â·      [36m62136[39m  Â·     [31m103532[39m  Â·      81742  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  borrowETH                      Â·     [36m498838[39m  Â·    [31m1238988[39m  Â·    1082776  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  emergencyERC20Transfer         Â·          -  Â·          -  Â·      60263  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  emergencyERC721Transfer        Â·          -  Â·          -  Â·     125960  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  emergencyPunksTransfer         Â·          -  Â·          -  Â·      73830  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  liquidateETH                   Â·          -  Â·          -  Â·     926476  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  redeemETH                      Â·          -  Â·          -  Â·     549756  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mPunkGateway[39m                Â·  repayETH                       Â·     [36m463587[39m  Â·     [31m879037[39m  Â·     771642  Â·            [90m8[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mRepayAndTransferHelper[39m     Â·  emergencyEtherTransfer         Â·          -  Â·          -  Â·      42635  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mSelfdestructTransfer[39m       Â·  destroyAndTransfer             Â·          -  Â·          -  Â·      29265  Â·          [90m158[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  auctionETH                     Â·          -  Â·          -  Â·     504563  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  borrowETH                      Â·     [36m469100[39m  Â·    [31m1024642[39m  Â·     912273  Â·           [90m12[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  depositETH                     Â·     [36m322982[39m  Â·     [31m391424[39m  Â·     348760  Â·           [90m17[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  liquidateETH                   Â·          -  Â·          -  Â·     716337  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  redeemETH                      Â·          -  Â·          -  Â·     504050  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  repayETH                       Â·     [36m400465[39m  Â·     [31m681296[39m  Â·     568919  Â·           [90m10[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mWETHGateway[39m                Â·  withdrawETH                    Â·     [36m388364[39m  Â·     [31m415470[39m  Â·     401917  Â·            [90m4[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mDeployments[22m[39m                                                  Â·                                         Â·  [1m% of limit[22m   Â·             â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  BorrowLogic                                                  Â·          -  Â·          -  Â·    2060203  Â·       [90m16.5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ConfiguratorLogic                                            Â·          -  Â·          -  Â·    1970106  Â·       [90m15.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  DebtToken                                                    Â·          -  Â·          -  Â·    1366344  Â·         [90m11 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  GenericLogic                                                 Â·          -  Â·          -  Â·      84290  Â·        [90m0.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  InterestRate                                                 Â·     [36m613848[39m  Â·     [31m613860[39m  Â·     613855  Â·        [90m4.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendingLogic                                                 Â·          -  Â·          -  Â·      72217  Â·        [90m0.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPool                                                     Â·          -  Â·          -  Â·    5327003  Â·       [90m42.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolConfigurator                                         Â·          -  Â·          -  Â·    5230541  Â·         [90m42 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LendPoolLoan                                                 Â·          -  Â·          -  Â·    3445719  Â·       [90m27.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LiquidateLogic                                               Â·          -  Â·          -  Â·    5017191  Â·       [90m40.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LiquidateMarketsLogic                                        Â·          -  Â·          -  Â·    3025524  Â·       [90m24.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  LockeyHolder                                                 Â·          -  Â·          -  Â·     239234  Â·        [90m1.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MaliciousHackerERC721                                        Â·          -  Â·          -  Â·     801955  Â·        [90m6.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockChainlinkOracle                                          Â·          -  Â·          -  Â·     620122  Â·          [90m5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockNFTOracle                                                Â·          -  Â·          -  Â·    1117453  Â·          [90m9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  MockReserveOracle                                            Â·          -  Â·          -  Â·    1280668  Â·       [90m10.3 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  NftLogic                                                     Â·          -  Â·          -  Â·     141022  Â·        [90m1.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  RepayAndTransferHelper                                       Â·          -  Â·          -  Â·     883669  Â·        [90m7.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ReserveLogic                                                 Â·          -  Â·          -  Â·     171208  Â·        [90m1.4 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ReserveOracle                                                Â·          -  Â·          -  Â·    1211618  Â·        [90m9.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  SelfdestructTransfer                                         Â·          -  Â·          -  Â·      88001  Â·        [90m0.7 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  SupplyLogic                                                  Â·          -  Â·          -  Â·    1235281  Â·        [90m9.9 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdProtocolDataProvider                                  Â·          -  Â·          -  Â·    2891625  Â·       [90m23.2 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UnlockdUpgradeableProxy                                      Â·          -  Â·          -  Â·     689038  Â·        [90m5.5 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UToken                                                       Â·          -  Â·          -  Â·    2710730  Â·       [90m21.8 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ValidationLogic                                              Â·          -  Â·          -  Â·    1573518  Â·       [90m12.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·---------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------Â·

  272 passing (9m)
  3 failing

  1) LendPool: buyout test cases
       Lockey Holder: Buyer - buys out the NFT in auction and deducts because his a lockey holder.:
     Error: invalid contract address or ENS name (argument="addressOrName", value=undefined, code=INVALID_ARGUMENT, version=contracts/5.7.0)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at Logger.throwArgumentError (node_modules/@ethersproject/logger/src.ts/index.ts:285:21)
      at Contract.BaseContract (node_modules/@ethersproject/contracts/src.ts/index.ts:712:20)
      at new Contract (node_modules/@ethersproject/contracts/lib/index.js:1053:42)
      at fundWithERC721 (helpers/misc-utils.ts:235:17)
      at Context.<anonymous> (test/buyout.spec.ts:255:25)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at runNextTicks (node:internal/process/task_queues:65:3)

  2) LendPool: Withdraw
       User 0 withdraws half of the deposited WETH:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'SafeERC20: low-level call failed'", method="estimateGas", transaction={"from":"0x0756cCC18E390dbdD0F9855A3B38458bb6157E31","to":"0xFC7f036a8FB66D031675239413F9179A82932a53","data":"0x69328dec000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000756ccc18e390dbdd0f9855a3b38458bb6157e31","accessList":null}, error={"stackTrace":[{"type":2,"address":{"type":"Buffer","data":[252,127,3,106,143,182,109,3,22,117,35,148,19,249,23,154,130,147,42,83]}},{"type":0,"sourceReference":{"function":"withdraw","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":211,"range":[8733,9057]},"functionType":1},{"type":0,"sourceReference":{"function":"liquidate","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":395,"range":[14954,15284]},"functionType":1},{"type":0,"sourceReference":{"function":"executeWithdraw","contract":"SupplyLogic","sourceName":"contracts/libraries/logic/SupplyLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title SupplyLogic library\n * @author Unlockd\n * @notice Implements the logic to supply feature\n */\nlibrary SupplyLogic {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on deposit()\n   * @param user The address initiating the deposit\n   * @param amount The amount deposited\n   * @param reserve The address of the underlying asset of the reserve\n   * @param onBehalfOf The beneficiary of the deposit, receiving the uTokens\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed onBehalfOf,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param user The address initiating the withdrawal, owner of uTokens\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param amount The amount to be withdrawn\n   * @param to Address that will receive the underlying\n   **/\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to);\n\n  /**\n   * @notice Implements the supply feature. Through `deposit()`, users deposit assets to the protocol.\n   * @dev Emits the `Deposit()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the deposit function\n   */\n  function executeDeposit(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteDepositParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    ValidationLogic.validateDeposit(reserve, params.amount);\n\n    reserve.updateState();\n    reserve.updateInterestRates(params.asset, uToken, params.amount, 0);\n\n    IERC20Upgradeable(params.asset).safeTransferFrom(params.initiator, uToken, params.amount);\n\n    IUToken(uToken).mint(params.onBehalfOf, params.amount, reserve.liquidityIndex);\n\n    // Deposit amount to external lending protocol\n    IUToken(uToken).depositReserves(params.amount);\n\n    emit Deposit(params.initiator, params.asset, params.amount, params.onBehalfOf, params.referralCode);\n  }\n\n  /**\n   * @notice Implements the withdraw feature. Through `withdraw()`, users withdraw assets from the protocol.\n   * @dev Emits the `Withdraw()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the withdraw function\n   */\n  function executeWithdraw(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) external returns (uint256) {\n    require(params.to != address(0), Errors.VL_INVALID_TARGET_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    uint256 userBalance = IUToken(uToken).balanceOf(params.initiator);\n\n    uint256 amountToWithdraw = params.amount;\n\n    if (params.amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(reserve, amountToWithdraw, userBalance, uToken);\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(params.asset, uToken, 0, amountToWithdraw);\n\n    // Withdraw amount from external lending protocol\n    IUToken(uToken).withdrawReserves(amountToWithdraw);\n\n    IUToken(uToken).burn(params.initiator, params.to, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(params.initiator, params.asset, amountToWithdraw, params.to);\n\n    return amountToWithdraw;\n  }\n}\n","line":114,"range":[4182,4273]},"functionType":1},{"type":2,"address":{"type":"Buffer","data":[48,44,234,193,86,120,227,35,141,25,160,196,113,69,51,112,17,105,194,23]}},{"type":0,"sourceReference":{"function":"burn","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":92,"range":[3400,3478]},"functionType":1},{"type":0,"sourceReference":{"function":"safeTransfer","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":26,"range":[868,954]},"functionType":1},{"type":0,"sourceReference":{"function":"_callOptionalReturn","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":93,"range":[3762,3831]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCall","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":95,"range":[3689,3741]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCallWithValue","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":133,"range":[5053,5104]},"functionType":1},{"type":0,"sourceReference":{"function":"verifyCallResult","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":169,"range":[6275,6967]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyLendPool","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":35,"range":[1527,1611]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,83,97,102,101,69,82,67,50,48,58,32,108,111,119,45,108,101,118,101,108,32,99,97,108,108,32,102,97,105,108,101,100]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000205361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at runNextTicks (node:internal/process/task_queues:65:3)

  3) LendPool: Withdraw
       User 0 tries to withdraw remaining half of the deposited WETH :
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'SafeERC20: low-level call failed'", method="estimateGas", transaction={"from":"0x0756cCC18E390dbdD0F9855A3B38458bb6157E31","to":"0xFC7f036a8FB66D031675239413F9179A82932a53","data":"0x69328dec000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000756ccc18e390dbdd0f9855a3b38458bb6157e31","accessList":null}, error={"stackTrace":[{"type":2,"address":{"type":"Buffer","data":[252,127,3,106,143,182,109,3,22,117,35,148,19,249,23,154,130,147,42,83]}},{"type":0,"sourceReference":{"function":"withdraw","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":211,"range":[8733,9057]},"functionType":1},{"type":0,"sourceReference":{"function":"liquidate","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":395,"range":[14954,15284]},"functionType":1},{"type":0,"sourceReference":{"function":"executeWithdraw","contract":"SupplyLogic","sourceName":"contracts/libraries/logic/SupplyLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title SupplyLogic library\n * @author Unlockd\n * @notice Implements the logic to supply feature\n */\nlibrary SupplyLogic {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on deposit()\n   * @param user The address initiating the deposit\n   * @param amount The amount deposited\n   * @param reserve The address of the underlying asset of the reserve\n   * @param onBehalfOf The beneficiary of the deposit, receiving the uTokens\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed onBehalfOf,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param user The address initiating the withdrawal, owner of uTokens\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param amount The amount to be withdrawn\n   * @param to Address that will receive the underlying\n   **/\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to);\n\n  /**\n   * @notice Implements the supply feature. Through `deposit()`, users deposit assets to the protocol.\n   * @dev Emits the `Deposit()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the deposit function\n   */\n  function executeDeposit(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteDepositParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    ValidationLogic.validateDeposit(reserve, params.amount);\n\n    reserve.updateState();\n    reserve.updateInterestRates(params.asset, uToken, params.amount, 0);\n\n    IERC20Upgradeable(params.asset).safeTransferFrom(params.initiator, uToken, params.amount);\n\n    IUToken(uToken).mint(params.onBehalfOf, params.amount, reserve.liquidityIndex);\n\n    // Deposit amount to external lending protocol\n    IUToken(uToken).depositReserves(params.amount);\n\n    emit Deposit(params.initiator, params.asset, params.amount, params.onBehalfOf, params.referralCode);\n  }\n\n  /**\n   * @notice Implements the withdraw feature. Through `withdraw()`, users withdraw assets from the protocol.\n   * @dev Emits the `Withdraw()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the withdraw function\n   */\n  function executeWithdraw(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) external returns (uint256) {\n    require(params.to != address(0), Errors.VL_INVALID_TARGET_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    uint256 userBalance = IUToken(uToken).balanceOf(params.initiator);\n\n    uint256 amountToWithdraw = params.amount;\n\n    if (params.amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(reserve, amountToWithdraw, userBalance, uToken);\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(params.asset, uToken, 0, amountToWithdraw);\n\n    // Withdraw amount from external lending protocol\n    IUToken(uToken).withdrawReserves(amountToWithdraw);\n\n    IUToken(uToken).burn(params.initiator, params.to, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(params.initiator, params.asset, amountToWithdraw, params.to);\n\n    return amountToWithdraw;\n  }\n}\n","line":114,"range":[4182,4273]},"functionType":1},{"type":2,"address":{"type":"Buffer","data":[48,44,234,193,86,120,227,35,141,25,160,196,113,69,51,112,17,105,194,23]}},{"type":0,"sourceReference":{"function":"burn","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":92,"range":[3400,3478]},"functionType":1},{"type":0,"sourceReference":{"function":"safeTransfer","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":26,"range":[868,954]},"functionType":1},{"type":0,"sourceReference":{"function":"_callOptionalReturn","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":93,"range":[3762,3831]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCall","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":95,"range":[3689,3741]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCallWithValue","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":133,"range":[5053,5104]},"functionType":1},{"type":0,"sourceReference":{"function":"verifyCallResult","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":169,"range":[6275,6967]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyLendPool","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":35,"range":[1527,1611]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,83,97,102,101,69,82,67,50,48,58,32,108,111,119,45,108,101,118,101,108,32,99,97,108,108,32,102,97,105,108,101,100]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000205361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at runNextTicks (node:internal/process/task_queues:65:3)



