
> @unlockddao/unlockd-protocol@1.0.2 test
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/*.spec.ts


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/home/fvenancio/Documents/projects/unlockd/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  main
  - Provider URL: eth-mainnet.g.alchemy.com
  - Network : hardhat
Deployer: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 10000.0 ETH
PoolAdmin: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 10000.0 ETH
EmergencyAdmin: 0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d Balance: 10000.0 ETH
LendPool Liquidator: 0xA296478f65BCDA4153343c8D1f24D768110D6e16 Balance: 10000.0 ETH


Migration started


Deploy UNFT Registry


Deploy Lockey Holders
Deploying new Lockey Holders implementation...
contracts-helpers:insertContractAddressInDb, id: LockeyHolderImpl address 0xc0F76A7803950584503681bcD5849473ecafbB2f
*** LockeyHolder ***

Network: hardhat
tx: 0x599bed68b5825b55702494c8428b288f97c0a5af02b2e0834d8f793d40939fac
contract address: 0xc0F76A7803950584503681bcD5849473ecafbB2f
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 60853630960
gas used: 239234

******

contracts-helpers:registerContractInJsonDb, contractId: LockeyHolder address: 0xc0F76A7803950584503681bcD5849473ecafbB2f deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lockey holders implementation with address: 0xc0F76A7803950584503681bcD5849473ecafbB2f
contracts-helpers:insertContractAddressInDb, id: LockeyHolder address 0xFcf344175C046459b0fAdf10722A093281F5D13E


Deploy lend pool
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x5db6f9ecce8893e1566ccce22f0e8aa81517e8cb79ab2c6e05cad73e170925d9
contract address: 0xC7553877733B9cAfc396A254906f4dBFdE24F0D9
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 41949904321
gas used: 84290

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0xC7553877733B9cAfc396A254906f4dBFdE24F0D9 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ReserveLogic ***

Network: hardhat
tx: 0x39798497b77fb1b2f85f775d2fc0a982192f971750440f4ec154acf924a4c15a
contract address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 36900476872
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** NftLogic ***

Network: hardhat
tx: 0xb242521eee5bd5b3e3a04f4f35b7abd16609e577fdb6c670517879d35757a891
contract address: 0xbD6e36bE378a76bB77d197457aB4Db7D10E40078
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 32536339931
gas used: 141022

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0xbD6e36bE378a76bB77d197457aB4Db7D10E40078 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ValidationLogic ***

Network: hardhat
tx: 0x201f63bff9cc33d283e03e0f4920573173ca7e85dde9ce7a6b1d850cf1d109f4
contract address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 28683601009
gas used: 1573518

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** SupplyLogic ***

Network: hardhat
tx: 0x6168145c45a3a884fb52eb96d1be87e5fd5166bf851bc08232f41db760846b38
contract address: 0x295b757C168f986E920944D893C31Fb3A6a213A3
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 26097862620
gas used: 1235281

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0x295b757C168f986E920944D893C31Fb3A6a213A3 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** BorrowLogic ***

Network: hardhat
tx: 0xdf27c98625d2a4f911fcf5a3a9585f3a4075598a2485687ad1bbb5e7855dce3c
contract address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 23583178244
gas used: 2060203

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LiquidateLogic ***

Network: hardhat
tx: 0xd207dd1f144deb196ae6697d481d61eba9f28bd20417ab69569f7cf21dec51f7
contract address: 0x27681c27312e9410736EE2B8e32d04c79C58c8bd
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 21694536618
gas used: 5017191

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x27681c27312e9410736EE2B8e32d04c79C58c8bd deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0x02be62f1bfac52475c6888d65aaf9be01d1134c838f392bd5120afb555c058ec
contract address: 0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 21192628033
gas used: 3025524

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LendingLogic ***

Network: hardhat
tx: 0x4c7ce553fbaa1711af7ae06f51ac16e825c356d397aa08a061cf908bf3173b30
contract address: 0xA5D14177dbf569CDb551348ed00ABA0F1cAA7754
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 19895322235
gas used: 72217

******

contracts-helpers:registerContractInJsonDb, contractId: LendingLogic address: 0xA5D14177dbf569CDb551348ed00ABA0F1cAA7754 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ConfiguratorLogic ***

Network: hardhat
tx: 0xa459e252903b6a3ba598126d1dfb27dd67d123c58ea3266579c3726b5e5717b7
contract address: 0xe7f4c711a37065d73dEa91ca8d5d117e312EcBCb
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 17560807829
gas used: 1970106

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0xe7f4c711a37065d73dEa91ca8d5d117e312EcBCb deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
*** LendPool ***

Network: hardhat
tx: 0x20d0ba6c0b1d52690a11369ed98f051f61334e46aed2e4e0553f715a6e993bd2
contract address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 16145858394
gas used: 5327003

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool implementation with address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
contracts-helpers:insertContractAddressInDb, id: LendPool address 0xFC7f036a8FB66D031675239413F9179A82932a53
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
*** LendPoolLoan ***

Network: hardhat
tx: 0x17d79fd809902c773fb07f3c4784f8eba0a152466dca0d644a938c5eff4c0417
contract address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 14026600594
gas used: 3445719

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool loan implementation with address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x00da789CEBF4A0da965FbcB9e4d72F1A15c67Eb6
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F
*** LendPoolConfigurator ***

Network: hardhat
tx: 0x39cb26fbd1e527f012894fd2c03d88acde713bfceea0973c94b3e17ea9322bdd
contract address: 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 11772868751
gas used: 5230541

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool configurator implementation with address: 0x170bB0C8Ddc9018368A47437E57b1Cf605e8470F
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0x82CefdbdFe6c4A868962E7B78A3CE54f952FE209
Deploying new generic UToken implementation...
*** UToken ***

Network: hardhat
tx: 0xa25a2a0d85b5aa75df5a173537a7b1dd43439c16efdcaff864ad4eef5435e6d1
contract address: 0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 9106926301
gas used: 2710730

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Upgrading UTokens with implementation  0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e
{ WETH: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' }
[
  '0xE6cd031FB0D9A79FD8CD3035B9228F78ff459B07',
  '800000000000000000000000000',
  '200000000000000000000000000',
  '160000000000000000000000000',
  '2000000000000000000000000000'
]
*** InterestRate ***

Network: hardhat
tx: 0xff1a7bc3893905bd32b645d89dcdce8cf426d0b4efa81c36f4487828431eef09
contract address: 0x7489ffcbf0b09a171DBae5c7bedc594DE54A137F
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 6072658433
gas used: 613848

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x7489ffcbf0b09a171DBae5c7bedc594DE54A137F deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address undefined


Deploy reserve oracle
PROXY admin: 0xb7493E15Af772c14c7cE3180Ff388925e6593c6b
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d
*** ReserveOracle ***

Network: hardhat
tx: 0xc5a1d1e14cfc8b7c0965ca8d93a8a1983cf8b2d897dc4096ce3bad81f18fd053
contract address: 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 4944444778
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x42a426b0f2e1e068f9baf198dd6783261e8e532cf3dc39f10ca62e28592193ff
contract address: 0x0d5A790175C95fd1fC032bb066f1166fBDCa155f
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 4547356255
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x0d5A790175C95fd1fC032bb066f1166fBDCa155f deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Reserve Oracle: proxy 0x0d5A790175C95fd1fC032bb066f1166fBDCa155f, implementation 0x795A9e0a33A77697cA47110Fe4755ebae8cc493d
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0xea44f19c6c0581e368552bf0ccd6e3e8871db4acad9c97f4c80f842af564ca29
contract address: 0xf0931526d7914202cB559fe6d618777Ba71b0802
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 3421327436
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0xf0931526d7914202cB559fe6d618777Ba71b0802 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xd64baed9d61c8c7ab7768672f2f2902664b366a491f57ae56d2bf4b05384f835
contract address: 0xEa18252aDf22a410CA147433c59BC28Ed193d4C0
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2912294392
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0xEa18252aDf22a410CA147433c59BC28Ed193d4C0 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0


Deploy nft oracle
Reuse existed nft oracle: 0xed1a46EBE904dD6562f5F20A515009752Fb5bAdE
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0x972e8cb573ecfce8ea714e76a6b2a9bc8ee501b36a04ce43a5bac950b9983f24
contract address: 0x8c0a772Eb79b6d52678Fa82449eA4cd95bC93763
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2485874067
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x8c0a772Eb79b6d52678Fa82449eA4cd95bC93763 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0


Initialize lend pool
Setting YVaultWETH with address:  0xa258C4606Ca8206D8aA700cE2143D7db854D168c  in addressesProvider...


Deploy WETH Gateway


Deploy PUNK Gateway


Deploy data provider
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0x418f2129128f54d72ab3ff467ee1ae91cf566182ea70fc1ff7aa43eb25d5ca73
contract address: 0x012b3ddB46cFD5b122e6D551dDD07afd71596586
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2024772311
gas used: 2891625

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0x012b3ddB46cFD5b122e6D551dDD07afd71596586 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
UnlockdProtocolDataProvider deployed at: 0x012b3ddB46cFD5b122e6D551dDD07afd71596586


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 44
UnlockdProxyAdminPool: 0xb7493E15Af772c14c7cE3180Ff388925e6593c6b
NFTOracleImpl: 0x07AfB905B34EF28505283a09a94603e9B40C3f31
NFTOracle: 0xed1a46EBE904dD6562f5F20A515009752Fb5bAdE
CryptoPunksMarket: 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
WrappedPunk: 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6
UnlockdProxyAdminFund: 0x38a97DE7216b54FCc83A918CF5dB1Bb0447913a4
LendPoolAddressesProvider: 0xE6cd031FB0D9A79FD8CD3035B9228F78ff459B07
LendPoolAddressesProviderRegistry: 0xe5BF48BC5Fd3FCD1c7Fc76795C7b08ccc139a949
ReserveLogic: 0x102Ca0665b83f1B01497E4afD0088FA7d645C5C1
NftLogic: 0x6dF83F6ba030C420d602E9a4302DB8f1DeEDd712
GenericLogic: 0x5520945C3261a51D8e014De4389acC51Fc926b9e
ValidationLogic: 0x8749e3e58A437ecA1B7dfA7046c99a51Cd784Def
SupplyLogic: 0xBA92072f11bbd7492f3419D1dfc85d6FFf730685
BorrowLogic: 0x25d2B642B2a485958a6A00c19f37082AbFF276Cd
LiquidateLogic: 0x91212942a1cda9342ffEF653Dc73e0130688f9F3
ConfiguratorLogic: 0x0919A0c32D7578F507760986a693D2E3D0E598a0
LendPoolImpl: 0x4216Ac4Ad3C6838889Cc80aa5E34e6F57e7839B6
LendPool: 0xFC7f036a8FB66D031675239413F9179A82932a53
LendPoolLoanImpl: 0x6FfD77E502b561E08CdE65C311bf920d9FE1dB88
LendPoolLoan: 0x00da789CEBF4A0da965FbcB9e4d72F1A15c67Eb6
LendPoolConfiguratorImpl: 0xC4576F34dfeFd15011947E787e818ad490F7df37
LendPoolConfigurator: 0x82CefdbdFe6c4A868962E7B78A3CE54f952FE209
UToken: 0x13D3f5C8FC7c05e7cc2d60690381aaB016137300
DebtToken: 0xE4Bc9E74428b5E8C4fAdB53D5eF39C9A9902909c
ReserveOracleImpl: 0x71a22E1b4D1113CF82898caf709F8F0190FBAaC2
ReserveOracle: 0x2954B6ce3E9788e2A6dE603358918f2eb067AABa
InterestRate: 0x2c8C82fBEA936860BD7b20a756E098360cBAF05B
rateStrategyWETH: 0x2c8C82fBEA936860BD7b20a756E098360cBAF05B
WETHGatewayImpl: 0xFbD2Bcee595C6dd9897d09F8aac4dE4d25Da2406
WETHGateway: 0x66CD472E4404D0C62d7068b4D69e28D5Ed6C32c2
PunkGatewayImpl: 0xf49c6c3A753643eF9a31A1cfBD1d38e364A1637c
PunkGateway: 0x2540b104310EFa795DE0a9247Ba3942b71385251
WalletBalanceProvider: 0x95F9b68e4F8dC809127B1A3437b3531197E273Ea
UnlockdProtocolDataProvider: 0x4ABde724f8d7CB5ec7b22A9b86824591bE9fDc86
UIPoolDataProvider: 0x2CF74101dF653E166Cbf699EeED6FaB599293BcD
WPUNKS: 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6
BAYC: 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
DOODLE: 0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e
AZUKI: 0xED5AF388653567Af2F388E6224dC7C4b3241C544
MockIncentivesController: 0xf40a2617170af5d8079D7a476F6475b2106328D4
UNFT: 0x1014BBC1ED63CC49e6118769D412E715A1cEbCD8
UNFTRegistryImpl: 0xC048366Bd89c48Abb763bB5d4c436b6990c241E9
UNFTRegistry: 0x255f25335662c88Fcc7deC402cADf2f4f0E08300
LiquidateMarketsLogic: 0xB7BBE03f2E0F384DA800aD3c4E29e0C3b70Da7D9 

Deployer: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 9999.346776737066926943
PoolAdmin: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 9999.346776737066926943
EmergencyAdmin: 0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d Balance: 9999.998649141438865794
LendPoolLiquidator: 0xA296478f65BCDA4153343c8D1f24D768110D6e16 Balance: 10000.0
-> Initialize make suite...
uDai undefined
uUSDC undefined
uWETH 0x302Ceac15678E3238D19a0C4714533701169C217
daiAdd undefined
usdcAdd undefined
wethAdd 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

***************
Setup and snapshot finished
***************

  LendPoolAddressesProvider
    ✓ Test the accessibility of the LendPoolAddressesProvider
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x84b09F1B0F78E5d60FF7219052BD730F4acE8666
*** LendPool ***

Network: hardhat
tx: 0x447105f442ed29989153ea01740ae4d4a6f8abc4e6e90b58286468b5e2149555
contract address: 0x84b09F1B0F78E5d60FF7219052BD730F4acE8666
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1563628100
gas used: 5327003

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x84b09F1B0F78E5d60FF7219052BD730F4acE8666 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
    ✓ Tests adding a proxied address with `setAddressAsProxy()`
    ✓ Tests adding a non proxied address with `setAddress()`
    ✓ Tests specific non-proxied addresses set via `setAddress()`

  LendPool: Borrow/repay test cases
    ✓ Delegatee try to Borrow WETH to different onBehalf

  LendPool: Borrow negative test cases
    ✓ Users 0 Deposits 100 WETH and user 1 tries to borrow 0 WETH (revert expected)
    ✓ User 1 tries to use underpriced NFT as collateral to borrow 100 WETH (revert expected)
    ✓ User 2 tries to uses user 1 owned NFT as collateral to borrow 10 WETH (revert expected)
    ✓ Users 0 Deposits 100 WETH and user 1 tries to borrow but the timestamp exceeds

  LendPool: Borrow/repay test cases
    ✓ User 2 deposits 1 WETH and 1000 DAI to account for rounding errors
    ✓ User 0 deposits 100 WETH, user 1 uses NFT as collateral and borrows 1 WETH
    ✓ User 1 uses existed collateral and borrows more 100 DAI (revert expected)
    ✓ User 1 uses existed collateral and borrows more 2 WETH
    ✓ User 1 tries to borrow more than the rest of the WETH liquidity (revert expected)
    ✓ User 1 tries to repay 0 WETH (revert expected)
    ✓ User 1 repays 0.5 WETH, enough to cover a small part of the interest
    ✓ User 1 repays all WETH borrow after one year
    ✓ User 0 withdraws the deposited WETH plus interest
    ✓ User 1 deposits 1 USDC to account for rounding errors
    ✓ User 1 deposits 1000 USDC, user 3 uses not owned NFT as collateral and borrows 10 USDC
    ✓ user 2 uses owned NFT as collateral on behalf of user 3 and borrows 10 USDC
    ✓ user 2 uses existed collateral on behalf of user 3 and borrows more 20 USDC
    ✓ user 3 repay 10 USDC, a fraction of borrow amount
    ✓ user 3 repay all USDC, full of borrow amount

  LendPool: buyout test cases
    ✓ Borrower - Borrows WETH
    ✓ Buyer tries to buy with HF above 1
    ✓ Health Factor goes below 1
    ✓ Buyer - tries to buy the NFT with a wrong tokenId
    ✓ Buyer - tries to buy the NFT with a smaller amount than debt
    ✓ Buyer - tries to buy the NFT with an amount higher than debt lower then valuation

  LendPool: buyout test cases
    ✓ Borrower - Borrows WETH
    ✓ Health Factor goes below 1
    ✓ Buyer - buys out the NFT in auction
    ✓ Lockey Holder: Borrower - Borrows WETH
    ✓ Lockey Holder: Health Factor goes below 1
Balance before:  1771428571428571428570

    1) Lockey Holder: Buyer - buys out the NFT in auction and deducts because his a lockey holder.

  Configurator-NFT
    ✓ Deactivates the BAYC NFT
    ✓ Deactivates the BAYC NFT Token
    ✓ Rectivates the BAYC NFT
    ✓ Rectivates the BAYC NFT Token
    ✓ Check the onlyAdmin on deactivateRNft 
    ✓ Check the onlyAdmin on activateNft 
    ✓ Freezes the BAYC NFT
    ✓ Freezes the BAYC NFT Token
    ✓ Unfreezes the BAYC NFT
    ✓ Unfreezes the BAYC NFT Token
    ✓ Check the onlyAdmin on freezeNft 
    ✓ Check the onlyAdmin on unfreezeNft 
    ✓ Deactivates the BAYC NFT as collateral
    ✓ Activates the BAYC NFT as collateral
    ✓ Check the onlyLtvManager on configureNftAsCollateral 
    ✓ Deactivates the BAYC NFT as auction
    ✓ Activates the BAYC NFT as auction
    ✓ Check the onlyLtvManager on configureNftAsAuction 
    ✓ Batch Deactivates the BAYC NFT as collateral
    ✓ Batch Activates the BAYC NFT as collateral
    ✓ Check the onlyAdmin on batchConfigNft 
    ✓ Batch Deactivates the BAYC NFT as auction
    ✓ Batch Activates the BAYC NFT as auction
    ✓ Reverts when trying to disable the BAYC nft with liquidity on it
    ✓ Config setMaxNumberOfNfts invalid value
    ✓ Config setMaxNumberOfNfts invalid value overflowing
    ✓ Check the onlyAdmin on setMaxNumberOfNfts 
    ✓ Config the timeFrame for an X amount of time
    ✓ Check if the config timestamp is correct
    ✓ Check if general configurations are correct
    ✓ Check the zero check on set rescuer
    ✓ (LendPool): Check the only pool admin in safe health factor 
    ✓ (LendPool): Check invalid 0 value in safe health factor 
    ✓ (LendPool): Check correct value in safe health factor 

  Configurator-Reserve
    ✓ Reverts trying to set an invalid reserve factor
    ✓ Rectivates the ETH reserve
    ✓ Check the onlyAdmin on deactivateReserve 
    ✓ Check the onlyAdmin on activateReserve 
    ✓ Freezes the ETH reserve
    ✓ Unfreezes the ETH reserve
    ✓ Check the onlyAdmin on freezeReserve 
    ✓ Check the onlyAdmin on unfreezeReserve 
    ✓ Deactivates the ETH reserve for borrowing
    ✓ Activates the ETH reserve for borrowing
    ✓ Check the onlyAdmin on disableBorrowingOnReserve 
    ✓ Check the onlyAdmin on enableBorrowingOnReserve 
    ✓ Changes the reserve factor of WETH
    ✓ Check the onlyLendPoolManager on setReserveFactor
    ✓ Batch Changes the reserve factor of WETH & DAI
    ✓ Check the onlyPoolAdmin on batchConfigReserve
    ✓ Reverts when trying to disable the DAI reserve with liquidity on it
    ✓ Config setMaxNumberOfReserves valid value
    ✓ Config setMaxNumberOfReserves invalid value
    ✓ Config setMaxNumberOfReserves invalid value overflow
    ✓ Check the onlyAdmin on setMaxNumberOfReserves 

  DataProvider
    ✓ Borrows WETH using 1 BAYC
    ✓ Query UI Reserve Data
    ✓ Query UI NFT Data
    ✓ Query UI Loan Data
    ✓ Query Wallet Reserve Data
    ✓ Query Wallet NFT Data

  LendPool: Deposit
    ✓ User 0 Deposits 1000 DAI in an empty reserve
    ✓ User 1 deposits 1000 DAI after user 0
    ✓ User 0 deposits 1000 USDC in an empty reserve
    ✓ User 1 deposits 1000 USDC after user 0
    ✓ User 0 deposits 1 WETH in an empty reserve
    ✓ User 1 deposits 1 WETH after user 0
    ✓ User 1 deposits 0 WETH (revert expected)
    ✓ User 1 deposits 0 DAI (revert expected)
    ✓ User 1 deposits 100 DAI on behalf of user 2, user 2 tries to borrow 0.01 WETH

  Interest rate tests
*** InterestRate ***

Network: hardhat
tx: 0x0d12e102d3b0d4617359ead86d541c4411b7060086ec2110e208ec2298b86f93
contract address: 0x71787a4bcdBfB86D63e332b1aAdA0727DFbf491F
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1643723234
gas used: 613860

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x71787a4bcdBfB86D63e332b1aAdA0727DFbf491F deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
    ✓ Checks rates at 0% utilization rate, empty reserve
    ✓ Checks rates at 80% utilization rate
    ✓ Checks rates at 100% utilization rate

  LendPool: Malicious Hacker Rentrant
hacker do reentrant action: ACTION_DEPOSIT
hacker do reentrant action: ACTION_WITHDRAW
hacker do reentrant action: ACTION_BORROW
hacker do reentrant action: ACTION_REPAY
hacker do reentrant action: ACTION_AUCTION
hacker do reentrant action: ACTION_REDEEM
hacker do reentrant action: ACTION_LIQUIDATE_NFTX
    ✓ Malicious hacker try to reentrant (should revert)

  LendPool: Liquidation negative test cases
    ✓ User 0 deposit 100 WETH, user 1 mint NFT and borrow 10 WETH
    ✓ User 1 liquidate on a non-existent NFT
    ✓ User 2 auction on a loan health factor above 1
    ✓ Drop loan health factor below 1
    ✓ User 2 auction price is unable to cover borrow
    ✓ User 2 auction price is less than liquidate price
    ✓ User 2 auction price is enough to cover borrow and liqudiate price
    ✓ User 3 auction price is lesser than user 2
    ✓ User 2 liquidate before auction duration is end
    ✓ User 1 redeem but bidFine is not fullfil to borrow amount of user 2 auction
    ✓ User 1 redeem but amount is not fullfil to mininum repay amount
    ✓ User 1 redeem but amount is not fullfil to maximum repay amount
    ✓ Ends redeem duration
    ✓ User 1 redeem after duration is end
    ✓ Ends auction duration
    ✓ User 3 auction after duration is end
    ✓ User 2 auction consecutively

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Auctions the borrow
    ✓ WETH - Can't liquidate on NFTX due to invalid loan state
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1
    ✓ USDC - Auctions the borrow at first time
    ✓ USDC - Auctions the borrow at second time with higher price
    ✓ USDC - Can't liquidate on NFTX

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1

  LendPool: Redeem
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Auctions the borrow
    ✓ WETH - Redeems the borrow
    ✓ WETH - Repays the borrow
    ✓ DAI - Borrows DAI
    ✓ DAI - Drop the health factor below 1
    ✓ DAI - Auctions the borrow
    ✓ DAI - Redeems the borrow
    ✓ DAI - Repays the borrow

  LendPool: Liquidation
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Auctions the borrow
    ✓ WETH - Liquidates the borrow
    ✓ USDC - Borrows USDC
    ✓ USDC - Drop the health factor below 1
    ✓ USDC - Auctions the borrow at first time
    ✓ USDC - Auctions the borrow at second time with higher price
    ✓ USDC - Liquidates the borrow

  LendPool: Liquidation on SudoSwap
    ✓ WETH - Borrows WETH
    ✓ WETH - Drop the health factor below 1
    ✓ WETH - Liquidates the borrow on SudoSwap
    ✓ DAI - Borrows DAI
    ✓ DAI - Drop the health factor below 1
    ✓ DAI - Liquidates the borrow on SudoSwap

  LendPoolLoan: Modifiers
    ✓ Tries to invoke initNft not being the Pool
    ✓ Tries to invoke createLoan not being the Pool
    ✓ Tries to invoke updateLoan not being the Pool
    ✓ Tries to invoke repayLoan not being the Pool
    ✓ Tries to invoke auctionLoan not being the Pool
    ✓ Tries to invoke redeemLoan not being the Pool
    ✓ Tries to invoke liquidateLoan not being the Pool
    ✓ Tries to invoke liquidateLoanNFTX not being the Pool

  NFTOracle: General functioning
    ✓ Set Admin correctly
    ✓ Set and get Mocknft price at 1000
    ✓ Add 2 Multi Assets
    ✓ Add 3 Multi Assets
    ✓ Add 3 Multi Assets - BigNumbers
    ✓ Single asset price updates
    ✓ Multiple asset price updates

  NFTOracle: Reverting Errors
    ✓ Should be reverted as NFTOracle is already initialized
    ✓ Should be reverted as it is a non-existing collection
    ✓ Should be reverted as price is 0
    ✓ Should be reverted as the collection has been deleted
    ✓ Should be reverted as contract is paused
    ✓ Should be reverted as array lengths aren't matching (2 vs 3)
    ✓ Testing overflows

  NFTOracle: Test Pause
    ✓ Should revert as collection is paused
    ✓ Should revert on multi-paused collections

  LendPool: Pause
    ✓ Transfer
    ✓ Deposit
    ✓ Withdraw
    ✓ Borrow
    ✓ Repay
    ✓ Liquidate
    ✓ LiquidateNFTX

  PunkGateway: Delegate
    ✓ Hacker try to borrow and delegate different onBehalf (should revert)
    ✓ Hacker try to auction and delegate different onBehalf (should revert)

  PunkGateway
USER: 0x0756cCC18E390dbdD0F9855A3B38458bb6157E31
    ✓ Owner can do emergency CryptoPunks recovery
    ✓ Should fail: not supported collection
    ✓ Should fail: not holder
    ✓ Check approve valuation on cryptopunks
    ✓ Borrow some USDC and repay it
AVAILABLE LIQUIDITY AFTER FIRST BORROW: 177770826290145056847
AVAILABLE LIQUIDITY AFTER SECOND BORROW: 175770826290145056847
    ✓ Borrow some ETH and repay it
    ✓ Borrow all ETH and repay it

  PunkGateway-Liquidate
    ✓ Borrow USDC and liquidate it
    ✓ Borrow ETH and liquidate it
    ✓ Borrow ETH and redeem it

  Repay and transfer helper tests
    ✓ borrow-repay-transfer

  LendPool: Rescue locked funds
BigNumber { value: "1000000000000000000000" }
    ✓ User 1 transfers 100 WETH directly to pool, and rescuer returns funds
BigNumber { value: "1000000000000000000000" }
    ✓ Prevents a random user from rescuing tokens 

  ReserveOracle
    ✓ ReserveOracle: Add Aggregator
    ✓ ReserveOracle: Remove Aggregator
    ✓ ReserveOracle: get latest price
    ✓ ReserveOracle: get eth price
    ✓ ReserveOracle: get latest timestamp
    ReserveOracle-TWAP
      ✓ twap price
      ✓ asking interval more than asset has
      ✓ asking interval less than asset has
      ✓ given variant price period
      ✓ latest price update time is earlier than the request, return the latest price
      ✓ get 0 while interval is zero

  Upgradeability
    ✓ Tries to update the WETH UToken implementation with a different address than the configuator
    ✓ Upgrades the WETH UToken implementation 
    ✓ Tries to update the weth DebtToken implementation with a different address than the configuator
    ✓ Upgrades the weth DebtToken implementation 
    ✓ Tries to update the LendPoolLoan implementation with a different address than the address provider
    ✓ Upgrades the LendPoolLoan implementation 

  UToken: Modifiers
    ✓ Tries to invoke mint not being the Pool
    ✓ Tries to invoke burn not being the Pool
    ✓ Tries to invoke mintToTreasury not being the Pool
    ✓ Tries to invoke transferUnderlyingTo not being the Pool
    ✓ Tries to invoke depositReserves not being the Pool
    ✓ Tries to invoke withdrawReserves not being the Pool
    ✓ Tries to invoke sweepUToken not being the PoolAdmin

  UToken
    ✓ Check WETH basic parameters
    ✓ Check the onlyAdmin on set treasury to new utoken
    ✓ Check the zero check on set treasury to new utoken
    ✓ Check the address is properly updated in WETH uToken
    ✓ 10 WETH are sent to UToken, sweep deposits them into Yearn Vault
    ✓ User 8 deposits 1000 WETH, transfers uweth to user 6

  WETHGateway - Delegate
    ✓ Hacker try to delegate different onBehalf (should revert)
    ✓ Borrower try to Borrow more ETH to different onBehalf (should revert)
Hacker try Borrow more ETH with others NFT
    ✓ Hacker try to Borrow more ETH (should revert)

  WETHGateway
    ✓ Deposit WETH via WethGateway 
    ✓ Withdraw WETH - Partial
    ✓ Withdraw WETH - Full
    ✓ Borrow WETH and Full Repay with ETH
Partial Repay ETH loan with native ETH
Full Repay ETH loan with native ETH
    ✓ Borrow ETH and Full Repay with ETH
    ✓ Should revert if receiver function receives Ether if not WETH
    ✓ Should revert if fallback functions is called with Ether
    ✓ Should revert if fallback functions is called
    ✓ Owner can do emergency ERC20 recovery
    ✓ Owner can do emergency ERC721 recovery
*** SelfdestructTransferMock ***

Network: hardhat
tx: 0x02550a870938b20a22e5ea94be17e0377d59cab268a9d0cf4ebcf3938bb0290d
contract address: 0x6be10f061Db0B5f3bB44e9748DB40885Bf756993
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1000071674
gas used: 88001

******

contracts-helpers:registerContractInJsonDb, contractId: SelfdestructTransferMock address: 0x6be10f061Db0B5f3bB44e9748DB40885Bf756993 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
    ✓ Owner can do emergency native ETH recovery

  WETHGateway - Liquidate
    ✓ Borrow ETH and Liquidate it
    ✓ Borrow ETH and Redeem it

  LendPool: Withdraw negative test cases
    ✓ Users 0 Deposits 1000 DAI and tries to withdraw 0 DAI (revert expected)
    ✓ Users 0 tries to withdraw 1100 DAI from the 1000 DAI deposited (revert expected)
    ✓ Users 1 borrows 100 DAI, users 0 tries to withdraw the 1000 DAI deposited (revert expected)
    ✓ Users 1 deposits 1 WETH, users 0 borrows 0.01 WETH, users 1 tries to withdraw the 1 WETH deposited (revert expected)

  LendPool: Withdraw
    ✓ User 0 Deposits 1000 DAI in an empty reserve
    ✓ User 0 withdraws half of the deposited DAI
    ✓ User 0 withdraws remaining half of the deposited DAI
    ✓ User 0 Deposits 1 WETH in an empty reserve

    2) User 0 withdraws half of the deposited WETH
    ✓ User 0 tries to withdraw remaining half of the deposited WETH (expect revert due to not enough liquidity)

    3) User 0 tries to withdraw remaining half of the deposited WETH 
    ✓ Users 0 and 1 Deposit 1000 DAI, both withdraw
    ✓ Users 0 deposits 1000 DAI, user 1 Deposit 1000 USDC and 1 WETH, borrows 100 DAI. User 1 tries to withdraw all the USDC

  UToken: Yearn integration
    ✓ User 0 deposits 10 WETH in an empty reserve, WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    ✓ User 1 deposits 10 WETH in the reserve, WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    ✓ User 0 withdraws 10 WETH, WETH is withdrawn from the Yearn Vault and WETH is given back to user
    ✓ User 2 deposits 1000 WETH in the reserve. WETH is deposited into Yearn Vault and yvWETH wrapped tokens are given back to UToken
    ✓ User 2 withdraws 500 WETH from the reserve, then 500 more. WETH is withdrawn from Yearn Vault and WETH is given back to user

·---------------------------------------------------------------|---------------------------|-------------|-----------------------------·
|                      [90mSolc version: 0.8.4[39m                      ·  [90mOptimizer enabled: true[39m  ·  [90mRuns: 200[39m  ·  [90mBlock limit: 12450000 gas[39m  │
································································|···························|·············|······························
|  [32m[1mMethods[22m[39m                                                                                                                              │
······························|·································|·············|·············|·············|···············|··············
|  [1mContract[22m                   ·  [1mMethod[22m                         ·  [32mMin[39m        ·  [32mMax[39m        ·  [32mAvg[39m        ·  [1m# calls[22m      ·  [1meur (avg)[22m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m          ·  offerPunkForSaleToAddress      ·          -  ·          -  ·     119766  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m          ·  transferPunk                   ·      [36m43479[39m  ·      [31m65379[39m  ·      57099  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m           ·  approve                        ·      [36m26200[39m  ·      [31m53948[39m  ·      42522  ·          [90m101[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m           ·  transfer                       ·      [36m34494[39m  ·     [31m155203[39m  ·      50263  ·          [90m105[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m           ·  transferFrom                   ·      [36m67168[39m  ·     [31m124787[39m  ·     109375  ·           [90m53[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mERC721Upgradeable[39m          ·  safeTransferFrom               ·          -  ·          -  ·     123319  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mERC721Upgradeable[39m          ·  setApprovalForAll              ·      [36m26173[39m  ·      [31m46280[39m  ·      40985  ·           [90m68[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setAddress                     ·      [36m29481[39m  ·      [31m49381[39m  ·      42423  ·           [90m27[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setAddressAsProxy              ·     [36m633514[39m  ·     [31m699899[39m  ·     666707  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolConfiguratorImpl    ·          -  ·          -  ·      43350  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolImpl                ·          -  ·          -  ·      43351  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolLiquidator          ·          -  ·          -  ·      30343  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolLoanImpl            ·          -  ·          -  ·      43396  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setNFTOracle                   ·          -  ·          -  ·      27521  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setReserveOracle               ·          -  ·          -  ·      30254  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setUnlockdDataProvider         ·          -  ·          -  ·      30321  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  batchConfigNft                 ·      [36m88027[39m  ·      [31m90911[39m  ·      90128  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  configureNftAsAuction          ·      [36m68252[39m  ·      [31m68288[39m  ·      68270  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  configureNftsAsCollateral      ·      [36m96973[39m  ·     [31m133973[39m  ·     110641  ·           [90m42[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setActiveFlagOnNft             ·      [36m78168[39m  ·      [31m83773[39m  ·      80971  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setActiveFlagOnNftByTokenId    ·      [36m69707[39m  ·      [31m69719[39m  ·      69713  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setActiveFlagOnReserve         ·          -  ·          -  ·      63834  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setBorrowingFlagOnReserve      ·      [36m66580[39m  ·      [31m66604[39m  ·      66592  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setFreezeFlagOnNft             ·      [36m66643[39m  ·      [31m66656[39m  ·      66650  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setFreezeFlagOnNftByTokenId    ·      [36m69637[39m  ·      [31m69649[39m  ·      69643  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setFreezeFlagOnReserve         ·      [36m66583[39m  ·      [31m66595[39m  ·      66589  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setLtvManagerStatus            ·      [36m39630[39m  ·      [31m59530[39m  ·      47093  ·           [90m56[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setNftMinBidFine               ·      [36m68059[39m  ·      [31m68083[39m  ·      68071  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setNftRedeemThreshold          ·      [36m68102[39m  ·      [31m68126[39m  ·      68114  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setPoolPause                   ·      [36m64331[39m  ·      [31m84074[39m  ·      74203  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setPoolRescuer                 ·      [36m63903[39m  ·      [31m81003[39m  ·      72453  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setReserveFactor               ·          -  ·          -  ·      66877  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setReserveInterestRateAddress  ·          -  ·          -  ·      66158  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  updateDebtToken                ·          -  ·          -  ·      89468  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  updateUToken                   ·          -  ·          -  ·      89358  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLockeyHolder[39m               ·  setLockeyDiscountPercentage    ·          -  ·          -  ·      58741  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMaliciousHackerERC721[39m      ·  approveDelegate                ·          -  ·          -  ·      87473  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMaliciousHackerERC721[39m      ·  simulateAction                 ·      [36m26483[39m  ·      [31m43583[39m  ·      28926  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockChainlinkOracle[39m        ·  mockAddAnswer                  ·     [36m125897[39m  ·     [31m245509[39m  ·     149398  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockDebtTokenVersionN[39m      ·  approveDelegation              ·      [36m39048[39m  ·      [31m56148[39m  ·      50893  ·           [90m20[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockIncentivesController[39m   ·  resetHandleActionIsCalled      ·      [36m26786[39m  ·      [31m29026[39m  ·      27672  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  approveValuation               ·      [36m64013[39m  ·      [31m71522[39m  ·      66516  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  auction                        ·     [36m474408[39m  ·     [31m474432[39m  ·     474422  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  borrow                         ·     [36m427097[39m  ·     [31m927504[39m  ·     885701  ·           [90m24[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  buyOut                         ·          -  ·          -  ·     760970  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  deposit                        ·     [36m288114[39m  ·     [31m341342[39m  ·     313612  ·           [90m45[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  liquidate                      ·          -  ·          -  ·     664937  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  liquidateSudoSwap              ·          -  ·          -  ·     683948  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  redeem                         ·          -  ·          -  ·     434262  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  repay                          ·     [36m359949[39m  ·     [31m669972[39m  ·     531242  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  rescue                         ·          -  ·          -  ·      57154  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  setIsMarketSupported           ·      [36m58528[39m  ·      [31m78452[39m  ·      60194  ·           [90m48[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  setMaxNumberOfReserves         ·          -  ·          -  ·      62719  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  setTimeframe                   ·      [36m58143[39m  ·      [31m60955[39m  ·      59497  ·           [90m25[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  updateSafeHealthFactor         ·      [36m40218[39m  ·      [31m43018[39m  ·      42543  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  withdraw                       ·     [36m317345[39m  ·     [31m321852[39m  ·     318472  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  addCollection                  ·          -  ·          -  ·      47505  ·           [90m13[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  initialize                     ·          -  ·          -  ·     113794  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  removeCollection               ·          -  ·          -  ·      25685  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  setMultipleNFTPrices           ·      [36m62686[39m  ·      [31m84325[39m  ·      73684  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  setNFTPrice                    ·      [36m33049[39m  ·      [31m60368[39m  ·      43561  ·           [90m79[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  setPause                       ·      [36m27850[39m  ·      [31m49762[39m  ·      38806  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  setPriceManagerStatus          ·      [36m33894[39m  ·      [31m53794[39m  ·      38956  ·           [90m60[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  addAggregator                  ·      [36m75602[39m  ·      [31m92702[39m  ·      89282  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  initialize                     ·          -  ·          -  ·      90917  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  mock_setBlockTimestamp         ·          -  ·          -  ·      26541  ·            [90m7[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  removeAggregator               ·      [36m33119[39m  ·      [31m37640[39m  ·      34023  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  setAggregators                 ·          -  ·          -  ·     101406  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockUTokenVersionN[39m         ·  setTreasuryAddress             ·      [36m43287[39m  ·      [31m43299[39m  ·      43293  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockUTokenVersionN[39m         ·  sweepUToken                    ·     [36m121166[39m  ·     [31m134846[39m  ·     128006  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mProxyAdmin[39m                 ·  transferOwnership              ·          -  ·          -  ·      28645  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  auctionETH                     ·          -  ·          -  ·     530404  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  authorizeCallerWhitelist       ·      [36m62136[39m  ·     [31m103532[39m  ·      81742  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  borrowETH                      ·     [36m498838[39m  ·    [31m1238988[39m  ·    1082776  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  emergencyERC20Transfer         ·          -  ·          -  ·      60263  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  emergencyERC721Transfer        ·          -  ·          -  ·     125960  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  emergencyPunksTransfer         ·          -  ·          -  ·      73830  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  liquidateETH                   ·          -  ·          -  ·     926476  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  redeemETH                      ·          -  ·          -  ·     549756  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  repayETH                       ·     [36m463587[39m  ·     [31m879037[39m  ·     771642  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mRepayAndTransferHelper[39m     ·  emergencyEtherTransfer         ·          -  ·          -  ·      42635  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mSelfdestructTransfer[39m       ·  destroyAndTransfer             ·          -  ·          -  ·      29265  ·          [90m158[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  auctionETH                     ·          -  ·          -  ·     504563  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  borrowETH                      ·     [36m469100[39m  ·    [31m1024642[39m  ·     912273  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  depositETH                     ·     [36m322982[39m  ·     [31m391424[39m  ·     348760  ·           [90m17[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  liquidateETH                   ·          -  ·          -  ·     716337  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  redeemETH                      ·          -  ·          -  ·     504050  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  repayETH                       ·     [36m400465[39m  ·     [31m681296[39m  ·     568919  ·           [90m10[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  withdrawETH                    ·     [36m388364[39m  ·     [31m415470[39m  ·     401917  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [32m[1mDeployments[22m[39m                                                  ·                                         ·  [1m% of limit[22m   ·             │
································································|·············|·············|·············|···············|··············
|  BorrowLogic                                                  ·          -  ·          -  ·    2060203  ·       [90m16.5 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ConfiguratorLogic                                            ·          -  ·          -  ·    1970106  ·       [90m15.8 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  DebtToken                                                    ·          -  ·          -  ·    1366344  ·         [90m11 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  GenericLogic                                                 ·          -  ·          -  ·      84290  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  InterestRate                                                 ·     [36m613848[39m  ·     [31m613860[39m  ·     613855  ·        [90m4.9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendingLogic                                                 ·          -  ·          -  ·      72217  ·        [90m0.6 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendPool                                                     ·          -  ·          -  ·    5327003  ·       [90m42.8 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendPoolConfigurator                                         ·          -  ·          -  ·    5230541  ·         [90m42 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendPoolLoan                                                 ·          -  ·          -  ·    3445719  ·       [90m27.7 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LiquidateLogic                                               ·          -  ·          -  ·    5017191  ·       [90m40.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LiquidateMarketsLogic                                        ·          -  ·          -  ·    3025524  ·       [90m24.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LockeyHolder                                                 ·          -  ·          -  ·     239234  ·        [90m1.9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MaliciousHackerERC721                                        ·          -  ·          -  ·     801955  ·        [90m6.4 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MockChainlinkOracle                                          ·          -  ·          -  ·     620122  ·          [90m5 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MockNFTOracle                                                ·          -  ·          -  ·    1117453  ·          [90m9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MockReserveOracle                                            ·          -  ·          -  ·    1280668  ·       [90m10.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  NftLogic                                                     ·          -  ·          -  ·     141022  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  RepayAndTransferHelper                                       ·          -  ·          -  ·     883669  ·        [90m7.1 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ReserveLogic                                                 ·          -  ·          -  ·     171208  ·        [90m1.4 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ReserveOracle                                                ·          -  ·          -  ·    1211618  ·        [90m9.7 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  SelfdestructTransfer                                         ·          -  ·          -  ·      88001  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  SupplyLogic                                                  ·          -  ·          -  ·    1235281  ·        [90m9.9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  UnlockdProtocolDataProvider                                  ·          -  ·          -  ·    2891625  ·       [90m23.2 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  UnlockdUpgradeableProxy                                      ·          -  ·          -  ·     689038  ·        [90m5.5 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  UToken                                                       ·          -  ·          -  ·    2710730  ·       [90m21.8 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ValidationLogic                                              ·          -  ·          -  ·    1573518  ·       [90m12.6 %[39m  ·          [32m[90m-[32m[39m  │
·---------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------·

  272 passing (9m)
  3 failing

  1) LendPool: buyout test cases
       Lockey Holder: Buyer - buys out the NFT in auction and deducts because his a lockey holder.:
     Error: invalid contract address or ENS name (argument="addressOrName", value=undefined, code=INVALID_ARGUMENT, version=contracts/5.7.0)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at Logger.throwArgumentError (node_modules/@ethersproject/logger/src.ts/index.ts:285:21)
      at Contract.BaseContract (node_modules/@ethersproject/contracts/src.ts/index.ts:712:20)
      at new Contract (node_modules/@ethersproject/contracts/lib/index.js:1053:42)
      at fundWithERC721 (helpers/misc-utils.ts:235:17)
      at Context.<anonymous> (test/buyout.spec.ts:255:25)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at runNextTicks (node:internal/process/task_queues:65:3)

  2) LendPool: Withdraw
       User 0 withdraws half of the deposited WETH:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'SafeERC20: low-level call failed'", method="estimateGas", transaction={"from":"0x0756cCC18E390dbdD0F9855A3B38458bb6157E31","to":"0xFC7f036a8FB66D031675239413F9179A82932a53","data":"0x69328dec000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000756ccc18e390dbdd0f9855a3b38458bb6157e31","accessList":null}, error={"stackTrace":[{"type":2,"address":{"type":"Buffer","data":[252,127,3,106,143,182,109,3,22,117,35,148,19,249,23,154,130,147,42,83]}},{"type":0,"sourceReference":{"function":"withdraw","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":211,"range":[8733,9057]},"functionType":1},{"type":0,"sourceReference":{"function":"liquidate","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":395,"range":[14954,15284]},"functionType":1},{"type":0,"sourceReference":{"function":"executeWithdraw","contract":"SupplyLogic","sourceName":"contracts/libraries/logic/SupplyLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title SupplyLogic library\n * @author Unlockd\n * @notice Implements the logic to supply feature\n */\nlibrary SupplyLogic {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on deposit()\n   * @param user The address initiating the deposit\n   * @param amount The amount deposited\n   * @param reserve The address of the underlying asset of the reserve\n   * @param onBehalfOf The beneficiary of the deposit, receiving the uTokens\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed onBehalfOf,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param user The address initiating the withdrawal, owner of uTokens\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param amount The amount to be withdrawn\n   * @param to Address that will receive the underlying\n   **/\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to);\n\n  /**\n   * @notice Implements the supply feature. Through `deposit()`, users deposit assets to the protocol.\n   * @dev Emits the `Deposit()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the deposit function\n   */\n  function executeDeposit(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteDepositParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    ValidationLogic.validateDeposit(reserve, params.amount);\n\n    reserve.updateState();\n    reserve.updateInterestRates(params.asset, uToken, params.amount, 0);\n\n    IERC20Upgradeable(params.asset).safeTransferFrom(params.initiator, uToken, params.amount);\n\n    IUToken(uToken).mint(params.onBehalfOf, params.amount, reserve.liquidityIndex);\n\n    // Deposit amount to external lending protocol\n    IUToken(uToken).depositReserves(params.amount);\n\n    emit Deposit(params.initiator, params.asset, params.amount, params.onBehalfOf, params.referralCode);\n  }\n\n  /**\n   * @notice Implements the withdraw feature. Through `withdraw()`, users withdraw assets from the protocol.\n   * @dev Emits the `Withdraw()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the withdraw function\n   */\n  function executeWithdraw(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) external returns (uint256) {\n    require(params.to != address(0), Errors.VL_INVALID_TARGET_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    uint256 userBalance = IUToken(uToken).balanceOf(params.initiator);\n\n    uint256 amountToWithdraw = params.amount;\n\n    if (params.amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(reserve, amountToWithdraw, userBalance, uToken);\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(params.asset, uToken, 0, amountToWithdraw);\n\n    // Withdraw amount from external lending protocol\n    IUToken(uToken).withdrawReserves(amountToWithdraw);\n\n    IUToken(uToken).burn(params.initiator, params.to, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(params.initiator, params.asset, amountToWithdraw, params.to);\n\n    return amountToWithdraw;\n  }\n}\n","line":114,"range":[4182,4273]},"functionType":1},{"type":2,"address":{"type":"Buffer","data":[48,44,234,193,86,120,227,35,141,25,160,196,113,69,51,112,17,105,194,23]}},{"type":0,"sourceReference":{"function":"burn","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":92,"range":[3400,3478]},"functionType":1},{"type":0,"sourceReference":{"function":"safeTransfer","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":26,"range":[868,954]},"functionType":1},{"type":0,"sourceReference":{"function":"_callOptionalReturn","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":93,"range":[3762,3831]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCall","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":95,"range":[3689,3741]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCallWithValue","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":133,"range":[5053,5104]},"functionType":1},{"type":0,"sourceReference":{"function":"verifyCallResult","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":169,"range":[6275,6967]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyLendPool","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":35,"range":[1527,1611]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,83,97,102,101,69,82,67,50,48,58,32,108,111,119,45,108,101,118,101,108,32,99,97,108,108,32,102,97,105,108,101,100]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000205361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at runNextTicks (node:internal/process/task_queues:65:3)

  3) LendPool: Withdraw
       User 0 tries to withdraw remaining half of the deposited WETH :
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'SafeERC20: low-level call failed'", method="estimateGas", transaction={"from":"0x0756cCC18E390dbdD0F9855A3B38458bb6157E31","to":"0xFC7f036a8FB66D031675239413F9179A82932a53","data":"0x69328dec000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000756ccc18e390dbdd0f9855a3b38458bb6157e31","accessList":null}, error={"stackTrace":[{"type":2,"address":{"type":"Buffer","data":[252,127,3,106,143,182,109,3,22,117,35,148,19,249,23,154,130,147,42,83]}},{"type":0,"sourceReference":{"function":"withdraw","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":211,"range":[8733,9057]},"functionType":1},{"type":0,"sourceReference":{"function":"liquidate","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @dev Function to buyout a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param buyoutAmount The buyout price of the underlying NFT\n   **/\n  function buyOut(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 buyoutAmount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeBuyout(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: buyoutAmount\n        })\n      );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":395,"range":[14954,15284]},"functionType":1},{"type":0,"sourceReference":{"function":"executeWithdraw","contract":"SupplyLogic","sourceName":"contracts/libraries/logic/SupplyLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title SupplyLogic library\n * @author Unlockd\n * @notice Implements the logic to supply feature\n */\nlibrary SupplyLogic {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on deposit()\n   * @param user The address initiating the deposit\n   * @param amount The amount deposited\n   * @param reserve The address of the underlying asset of the reserve\n   * @param onBehalfOf The beneficiary of the deposit, receiving the uTokens\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed onBehalfOf,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param user The address initiating the withdrawal, owner of uTokens\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param amount The amount to be withdrawn\n   * @param to Address that will receive the underlying\n   **/\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to);\n\n  /**\n   * @notice Implements the supply feature. Through `deposit()`, users deposit assets to the protocol.\n   * @dev Emits the `Deposit()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the deposit function\n   */\n  function executeDeposit(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteDepositParams memory params\n  ) external {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    ValidationLogic.validateDeposit(reserve, params.amount);\n\n    reserve.updateState();\n    reserve.updateInterestRates(params.asset, uToken, params.amount, 0);\n\n    IERC20Upgradeable(params.asset).safeTransferFrom(params.initiator, uToken, params.amount);\n\n    IUToken(uToken).mint(params.onBehalfOf, params.amount, reserve.liquidityIndex);\n\n    // Deposit amount to external lending protocol\n    IUToken(uToken).depositReserves(params.amount);\n\n    emit Deposit(params.initiator, params.asset, params.amount, params.onBehalfOf, params.referralCode);\n  }\n\n  /**\n   * @notice Implements the withdraw feature. Through `withdraw()`, users withdraw assets from the protocol.\n   * @dev Emits the `Withdraw()` event.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the withdraw function\n   */\n  function executeWithdraw(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) external returns (uint256) {\n    require(params.to != address(0), Errors.VL_INVALID_TARGET_ADDRESS);\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    address uToken = reserve.uTokenAddress;\n\n    require(uToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    uint256 userBalance = IUToken(uToken).balanceOf(params.initiator);\n\n    uint256 amountToWithdraw = params.amount;\n\n    if (params.amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(reserve, amountToWithdraw, userBalance, uToken);\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(params.asset, uToken, 0, amountToWithdraw);\n\n    // Withdraw amount from external lending protocol\n    IUToken(uToken).withdrawReserves(amountToWithdraw);\n\n    IUToken(uToken).burn(params.initiator, params.to, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(params.initiator, params.asset, amountToWithdraw, params.to);\n\n    return amountToWithdraw;\n  }\n}\n","line":114,"range":[4182,4273]},"functionType":1},{"type":2,"address":{"type":"Buffer","data":[48,44,234,193,86,120,227,35,141,25,160,196,113,69,51,112,17,105,194,23]}},{"type":0,"sourceReference":{"function":"burn","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":92,"range":[3400,3478]},"functionType":1},{"type":0,"sourceReference":{"function":"safeTransfer","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":26,"range":[868,954]},"functionType":1},{"type":0,"sourceReference":{"function":"_callOptionalReturn","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","line":93,"range":[3762,3831]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCall","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":95,"range":[3689,3741]},"functionType":1},{"type":0,"sourceReference":{"function":"functionCallWithValue","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":133,"range":[5053,5104]},"functionType":1},{"type":0,"sourceReference":{"function":"verifyCallResult","contract":"UToken","sourceName":"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","line":169,"range":[6275,6967]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyLendPool","contract":"UToken","sourceName":"contracts/protocol/UToken.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IYVault} from \"../interfaces/yearn/IYVault.sol\";\nimport {IIncentivesController} from \"../interfaces/IIncentivesController.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\n\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {LendingLogic} from \"../libraries/logic/LendingLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 UToken\n * @dev Implementation of the interest bearing token for the Unlockd protocol\n * @author Unlockd\n */\ncontract UToken is Initializable, IUToken, IncentivizedERC20 {\n  using WadRayMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  modifier onlyLendPool() {\n    require(_msgSender() == address(_getLendPool()), Errors.CT_CALLER_MUST_BE_LEND_POOL);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_msgSender() == _addressProvider.getPoolAdmin(), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Initializes the uToken\n   * @param addressProvider The address of the address provider where this uToken will be used\n   * @param treasury The address of the Unlockd treasury, receiving the fees on this uToken\n   * @param underlyingAsset The address of the underlying asset of this uToken\n   */\n  function initialize(\n    ILendPoolAddressesProvider addressProvider,\n    address treasury,\n    address underlyingAsset,\n    uint8 uTokenDecimals,\n    string calldata uTokenName,\n    string calldata uTokenSymbol\n  ) external override initializer {\n    __IncentivizedERC20_init(uTokenName, uTokenSymbol, uTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n\n    _addressProvider = addressProvider;\n\n    emit Initialized(\n      underlyingAsset,\n      _addressProvider.getLendPool(),\n      treasury,\n      _addressProvider.getIncentivesController()\n    );\n  }\n\n  /**\n   * @dev Burns uTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The owner of the uTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendPool {\n    uint256 amountScaled = amount.rayDiv(index);\n\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` uTokens to `user`\n   * - Only callable by the LendPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(address user, uint256 amount, uint256 index) external override onlyLendPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    // index is expressed in Ray, so:\n    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Deposits `amount` to the lending protocol currently active\n   * @param amount The amount of tokens to deposit\n   */\n  function depositReserves(uint256 amount) public override onlyLendPool {\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n  }\n\n  /**\n   * @dev Withdraws `amount` from the lending protocol currently active\n   * @param amount The amount of tokens to withdraw\n   */\n  function withdrawReserves(uint256 amount) public override onlyLendPool returns (uint256) {\n    uint256 value = LendingLogic.executeWithdrawYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n    return value;\n  }\n\n  /**\n   * @dev Takes reserve liquidity from uToken and deposits it to external lening protocol\n   **/\n  function sweepUToken() external override onlyPoolAdmin {\n    IERC20Upgradeable underlyingAsset = IERC20Upgradeable(_underlyingAsset);\n\n    uint256 amount = underlyingAsset.balanceOf(address(this));\n\n    LendingLogic.executeDepositYearn(\n      _addressProvider,\n      DataTypes.ExecuteYearnParams({underlyingAsset: _underlyingAsset, amount: amount})\n    );\n\n    emit UTokenSwept(address(this), address(underlyingAsset), amount);\n  }\n\n  /**\n   * @dev Mints uTokens to the reserve treasury\n   * - Only callable by the LendPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user) public view override returns (uint256) {\n    ILendPool pool = _getLendPool();\n    return super.balanceOf(user).rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @return The available liquidity in reserve\n   **/\n  function getAvailableLiquidity() public view override returns (uint256) {\n    return LendingLogic.calculateYearnAvailableLiquidityInReserve(_addressProvider);\n  }\n\n  /**\n   * @dev calculates the total supply of the specific uToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    ILendPool pool = _getLendPool();\n    return currentSupplyScaled.rayMul(pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Sets new treasury to the specified UToken\n   * @param treasury the new treasury address\n   **/\n  function setTreasuryAddress(address treasury) external override onlyPoolAdmin {\n    require(treasury != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _treasury = treasury;\n    emit TreasuryAddressUpdated(treasury);\n  }\n\n  /**\n   * @dev Returns the address of the Unlockd treasury, receiving the fees on this uToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view override returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this uToken\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this uToken is used\n   **/\n  function POOL() public view returns (ILendPool) {\n    return _getLendPool();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IIncentivesController) {\n    return IIncentivesController(_addressProvider.getIncentivesController());\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\n   * assets in borrow() and withdraw()\n   * @param target The recipient of the uTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount) external override onlyLendPool returns (uint256) {\n    IERC20Upgradeable(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  function _getLendPoolConfigurator() internal view returns (ILendPoolConfigurator) {\n    return ILendPoolConfigurator(_addressProvider.getLendPoolConfigurator());\n  }\n\n  /**\n   * @dev Transfers the uTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(address from, address to, uint256 amount, bool validate) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendPool pool = _getLendPool();\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(address from, address to, uint256 amount) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n","line":35,"range":[1527,1611]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,83,97,102,101,69,82,67,50,48,58,32,108,111,119,45,108,101,118,101,108,32,99,97,108,108,32,102,97,105,108,101,100]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000205361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at runNextTicks (node:internal/process/task_queues:65:3)



