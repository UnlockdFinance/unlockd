
> @unlockddao/unlockd-protocol@1.0.2 test:file
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/__setup.spec.ts ./test/${TEST_FILE}


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/Users/adri/work/unlockd-protocol-v1/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  goerli
  - Provider URL: eth-goerli.g.alchemy.com
  - Network : hardhat
Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 1000000.0 ETH
LendPool Liquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 1000000.0 ETH


Migration started


Deploy Punks Market and Wrapped Punk
*** CryptoPunksMarket ***

Network: hardhat
tx: 0x67afc5b971d207e75f3498c82fc72d142659cf9e5d27e7ea60a251cc160db823
contract address: 0x1864c9342339c36588F7f31d1079690a7003c7a2
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000042103
gas used: 2378109

******

contracts-helpers:registerContractInJsonDb, contractId: CryptoPunksMarket address: 0x1864c9342339c36588F7f31d1079690a7003c7a2 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WrappedPunk ***

Network: hardhat
tx: 0xe728bedb02bee455dab430156f43961f57d5a9fe0ff3ae48a1aaf1095051e0c2
contract address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000038851
gas used: 1992593

******

contracts-helpers:registerContractInJsonDb, contractId: WrappedPunk address: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy proxy admin
*** UnlockdProxyAdminPool ***

Network: hardhat
tx: 0xd8fe84a47275e5c108cc974c34fe7dc1fced7b74c87287816c1b5f4cc057cacf
contract address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000031139
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminPool address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
ProxyAdminPool Address: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** UnlockdProxyAdminFund ***

Network: hardhat
tx: 0xf9687bddd351d5744b1d8accd8f7e7d49ccc45a61e6ff48c5df0902db09aeeeb
contract address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000027541
gas used: 470704

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProxyAdminFund address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProxyAdminFund Address: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy address provider
- Deploying new Address Provider:
*** LendPoolAddressesProvider ***

Network: hardhat
tx: 0x95ec82ad756e8b69365935e3afe679993fa59cd4945e510f9826e1b273560bab
contract address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000024359
gas used: 2978496

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProvider address: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
- Deploying a new Address Provider Registry:
*** LendPoolAddressesProviderRegistry ***

Network: hardhat
tx: 0x74bc06db09d3fe7b338e23b7aac662665f927306555d151d4b08f603824ff54b
contract address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000022772
gas used: 502283

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolAddressesProviderRegistry address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deployed Registry Address: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc Owner Address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Added LendPoolAddressesProvider with address "0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977" to registry located at 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
LSSVM ROUTER ADDRESS: 0x25b4EfC43c9dCAe134233CD577fFca7CfAd6748F
Pool Admin 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Emergency Admin 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3
LendPool Liquidator 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
SushiSwap Router 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506
NFTXVault Factory 0xe01Cf5099e700c282A56E815ABd0C4948298Afae


Deploy Incentives Controller
Deploying new Incentives Controller Implementation...
*** MockIncentivesController ***

Network: hardhat
tx: 0x13f2a4a181bd6e42bcfbed55b2948c24f6cbe8df18323014b8f9d5ef61219b07
contract address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000006991
gas used: 142669

******

contracts-helpers:registerContractInJsonDb, contractId: MockIncentivesController address: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy UNFT Registry
Deploying new UnftRegistry implementation...
*** UNFT ***

Network: hardhat
tx: 0xdb1c1b9d5a05012416ff674516c86b3a9992ab294ea4362b5480c3c091d4c529
contract address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000005377
gas used: 1503057

******

contracts-helpers:registerContractInJsonDb, contractId: UNFT address: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:insertContractAddressInDb, id: UNFTRegistryImpl address 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
*** UNFTRegistry ***

Network: hardhat
tx: 0x6538e206c72d4582502561e69be0633c125630beb0c077735834f3dc46f1d292
contract address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004868
gas used: 2441516

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Invalid Proxy Admin address in pool config. Trying to fetch from deployed contracts...
*** UNFTRegistry ***

Network: hardhat
tx: 0x8ce3f7e1d37f8d4b20cda5f3c5e9e8431dde1655ba18687d5a6f95a52278694b
contract address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000004499
gas used: 740488

******

contracts-helpers:registerContractInJsonDb, contractId: UNFTRegistry address: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UNFT created successfully for token WPUNKS with address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UNFT Token: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796 0xfC856EeEaE446258cc8f17C5421c507115dc912d
UNFT created successfully for token BAYC with address 0x9278420Bf7548970799c56ef9A0B081862515330
UNFT Token: 0x9278420Bf7548970799c56ef9A0B081862515330 0x06cF13D8aD87307d50540223D3A08f63CDF8A211


Deploy lend pool
Setting UNFTRegistry to address provider...
Setting IncentivesController to address provider...
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x38423594a581dece179ba4fa765fae61c3ba8cf96973b8e83d5b046ae5d0866c
contract address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000002131
gas used: 84278

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ReserveLogic ***

Network: hardhat
tx: 0x600484e35a44f4a615ffa58f3fcee7b8049f9f3cdf15dd65315ccbd9376dbd4e
contract address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001869
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** NftLogic ***

Network: hardhat
tx: 0xc17f90485ee1499cfbe95745defe40c7607d73c11588adfa41efb6a517ff36c7
contract address: 0x5c769753F192449c3c6AeC7BF2145928eb261699
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001642
gas used: 141022

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0x5c769753F192449c3c6AeC7BF2145928eb261699 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ValidationLogic ***

Network: hardhat
tx: 0x54d09ed96409fcef791c02c18994ce20c1ad991457f0b42135f9ea299445b9fc
contract address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001442
gas used: 1528605

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** SupplyLogic ***

Network: hardhat
tx: 0x061e122abff21426642167a8d08ac8c7434e0a1d02f540fe410cd07cb86c66d3
contract address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001307
gas used: 1184808

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0xDB8c2AE619685b26C26a9ff48698049C363784f3 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** BorrowLogic ***

Network: hardhat
tx: 0xaf6bcaf880077ac8454be12eb41a588ace70e4ea55545c58dfab5266df762a33
contract address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001175
gas used: 2066318

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateLogic ***

Network: hardhat
tx: 0x4f2359412aaee5554478bf8bd30fc709cb05cce3e125cf537544809e656ea1d9
contract address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001077
gas used: 3804663

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0xcb87ba62ac8e24c3bbbb0060054bf7086c0129e82909e1940a178455de3f66da
contract address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000001025
gas used: 2912395

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** ConfiguratorLogic ***

Network: hardhat
tx: 0x0bc40510c4f7e488917b449ee06a7220c811f4a6e161158009b57015d7c72284
contract address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000957
gas used: 1970094

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
*** LendPool ***

Network: hardhat
tx: 0xa24ae86b348da36db114bd052e1706e8c5ef58f34430c13e568f64ceac959574
contract address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000876
gas used: 4943082

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool implementation with address: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
contracts-helpers:insertContractAddressInDb, id: LendPool address 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
*** LendPoolLoan ***

Network: hardhat
tx: 0xdf5c741fc3efd48874e4421a195476ac03dc205313b7c77c05a291e47bf9ad08
contract address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000760
gas used: 3232544

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool loan implementation with address: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0xa85e569EF873Cec2a82012C08057397F93aed686
*** LendPoolConfigurator ***

Network: hardhat
tx: 0x4af2d4056a4c31a7bf4973e4277eb426bb4d9e2f51f8b29f9bcd0ac1eab6eb39
contract address: 0xa85e569EF873Cec2a82012C08057397F93aed686
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000636
gas used: 5196741

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0xa85e569EF873Cec2a82012C08057397F93aed686 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Setting lend pool configurator implementation with address: 0xa85e569EF873Cec2a82012C08057397F93aed686
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
Deploying UToken implementation UToken
*** UToken ***

Network: hardhat
tx: 0xda067e27819460bf4530ca97357480c334cfd963e3391b2e7788353e9ea9965f
contract address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000485
gas used: 1927519

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** DebtToken ***

Network: hardhat
tx: 0xb6215056f685b9ff3fabb9d956d7ed0037988720030b5006bc3d031e813abd32
contract address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000444
gas used: 1366344

******

contracts-helpers:registerContractInJsonDb, contractId: DebtToken address: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy reserve oracle
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0xd81cfDb25C4a27795c17A893F7813590614f2A90
*** ReserveOracle ***

Network: hardhat
tx: 0xc31ca987afd8de64f62fa188f4583970a3dfd7ca066e61acfbe91ff498c00985
contract address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000309
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0xd81cfDb25C4a27795c17A893F7813590614f2A90 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x244b1a29ed9cbfe146bab6c3bf2bf7686c8a2b4279d6c2b51b9470644c2e7e59
contract address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000278
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Reserve Oracle: proxy 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD, implementation 0xd81cfDb25C4a27795c17A893F7813590614f2A90
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0xb63ad0ca591eba688df2f64f2c48acc633d6d927b67a88876bcc7193f56a7f77
contract address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000191
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0x9718F7A661C0137d13EB4f0659dA5E8697075492 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xb32ecc23bc6325ad7578cee1ec42ab59f7ad7c59b8c91100a18f00b9f322f8e2
contract address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000152
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy nft oracle
contracts-helpers:insertContractAddressInDb, id: NFTOracleImpl address 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
*** NFTOracle ***

Network: hardhat
tx: 0x5fc3822aa20b47287c2e2b7abc95f3245085c0a802c0f86618f2be3ed085eb5e
contract address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000135
gas used: 1047527

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new nft oracle proxy & implementation...
*** NFTOracle ***

Network: hardhat
tx: 0x911173a3e4b074d1349b73126755e2a85e73c31d65ad51208fea3ae84e6ec85c
contract address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000121
gas used: 712030

******

contracts-helpers:registerContractInJsonDb, contractId: NFTOracle address: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
NFT Oracle: proxy 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482, implementation 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0x4d11889fb4391938c1fc86bcf977bdf808b86b4b13cd8fc4e45ddd44b3a8b9ce
contract address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000065
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize lend pool
Init & Config Reserve assets
RESERVES: WETH,[object Object],DAI,[object Object],USDC,[object Object]
*** InterestRate ***

Network: hardhat
tx: 0x8022d3dfe2408dba196c66a666ae40b78d4047e338ade8a9179d19eb3453c89c
contract address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000052
gas used: 616243

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
*** InterestRate ***

Network: hardhat
tx: 0xc05aae48956baed2eaf66171d8647fc16e974ca0b4e9c4551cd4b9294e9426dd
contract address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000047
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableTwo address 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
*** InterestRate ***

Network: hardhat
tx: 0x1da49dba71ac0be209d4cd71e0a97737bd2e0b9b2f23e2d4dd20909e2e234086
contract address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000042
gas used: 616255

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyStableThree address 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
- Reserves initialization in 3 txs
  - Reserve ready for: WETH 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
    * gasUsed 1631513
  - Reserve ready for: DAI 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
    * gasUsed 1616353
  - Reserve ready for: USDC 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
    * gasUsed 1616413
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure Reserves
  - Params for WETH: 3000 true
  - Params for DAI: 3000 true
  - Params for USDC: 3000 true
- Configure reserves in 1 txs
  - batchConfigReserve for: WETH, DAI, USDC
Init & Config NFT assets
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- NFTs initialization in 2 txs
  - NFT ready for: WPUNKS 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
    * gasUsed 256961
  - NFT ready for: BAYC 0x9278420Bf7548970799c56ef9A0B081862515330
    * gasUsed 241669
addressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
configuator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
- Configure NFTs
  - Params for WPUNKS: 4000 9000 500 24 24 500 5000 2000 10000 9999
  - Params for BAYC: 4000 9000 500 24 24 500 5000 2000 10000 9999
- Skipping init of DOODLE due nft address is not set at markets config
- Skipping init of AZUKI due nft address is not set at markets config
- Configure NFTs in 4 txs
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS, WPUNKS
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC
  - batchConfigNft for: BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC, BAYC


Deploy WETH Gateway
contracts-helpers:insertContractAddressInDb, id: WETHGatewayImpl address 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
*** WETHGateway ***

Network: hardhat
tx: 0x8cf2757cda767afc83e34a00191f09959ee411836c6109719bf0865cae5d2cf5
contract address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 2587824

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
*** WETHGateway ***

Network: hardhat
tx: 0xbcbd6a88cd7c774e27435a3e64e2576c32228e3ebe40cd0fc67340e0013ea837
contract address: 0x51bda59320165617F7209a38D08b11ccefF58F1a
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000012
gas used: 745688

******

contracts-helpers:registerContractInJsonDb, contractId: WETHGateway address: 0x51bda59320165617F7209a38D08b11ccefF58F1a deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Deploy PUNK Gateway
wethGateWay.address 0x51bda59320165617F7209a38D08b11ccefF58F1a
CryptoPunksMarket.address 0x1864c9342339c36588F7f31d1079690a7003c7a2
WPUNKS.address 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
contracts-helpers:insertContractAddressInDb, id: PunkGatewayImpl address 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
*** PunkGateway ***

Network: hardhat
tx: 0xadda1fd531c22582b1bfee378c90018ec21615902a82e769dd9e5d2182c10554
contract address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 3290566

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
Deploying new PunkGateway proxy & implementation...
*** PunkGateway ***

Network: hardhat
tx: 0x02a7165960142c887f825c0e37f39e3a337bd523ff638a14f2d7549ec0bb06e8
contract address: 0xb16101f4b859580B810b683264102c49e12d0732
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000009
gas used: 998847

******

contracts-helpers:registerContractInJsonDb, contractId: PunkGateway address: 0xb16101f4b859580B810b683264102c49e12d0732 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15


Initialize gateway
WETHGateway: authorizeLendPoolNFT: [
  '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
  '0x9278420Bf7548970799c56ef9A0B081862515330'
]
PunkGateway: authorizeLendPoolERC20: [
  '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6',
  '0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36',
  '0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557'
]


Deploy data provider
*** WalletBalanceProvider ***

Network: hardhat
tx: 0x9c48f63a209185fef70dfd98b8e9e7e0beda06150534e5ccfc00b50ddc087a88
contract address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 1251342

******

contracts-helpers:registerContractInJsonDb, contractId: WalletBalanceProvider address: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
WalletBalancerProvider deployed at: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0xbea41fab6df21451f0c41b3348df9d8b06bd90481ab0aedda6567a89adf5c362
contract address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 2888605

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UnlockdProtocolDataProvider deployed at: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
*** UIPoolDataProvider ***

Network: hardhat
tx: 0x6aa6a6554f4f39d634bd8ea55027e80f5109f15e52a21a5a49bd5eaa2729d3c4
contract address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
deployer address: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
gas price: 1000000008
gas used: 3116123

******

contracts-helpers:registerContractInJsonDb, contractId: UIPoolDataProvider address: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256 deployer 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15
UiPoolDataProvider deployed at: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 47
CryptoPunksMarket: 0x1864c9342339c36588F7f31d1079690a7003c7a2
WrappedPunk: 0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796
UnlockdProxyAdminPool: 0xF9107B537482fE7cE75a6646BEad2A97BFA4eB0E
UnlockdProxyAdminFund: 0x2cC3790f7CF280fA898E4913CA980410cF38e53b
LendPoolAddressesProvider: 0x294E11ac81ED4018d5dC0cc9618Ff2890acC8977
LendPoolAddressesProviderRegistry: 0x6B8dcBD1bb131ED184221902df1Fe21019ccD7dc
MockIncentivesController: 0x44e12d4D37f6DDAA00c086442998B1A61365BCa9
UnlockdProxyAdminTest: 0x8b89F971cA1A5dE1B7df7f554a3024eE84FeeB05
UNFT: 0x0A66e11653e32D082F3330Dc99687ce42Eb53121
UNFTRegistryImpl: 0xD5A42dEB39C8EfbCE0f81cEb4c51500501809e89
UNFTRegistry: 0x4E76d6429C6f9dD22F87f10BcA800664B8Cc118b
GenericLogic: 0x58B6e24b2a462Ef81e154515Ab7adc804512325c
ReserveLogic: 0xAAF09660FafD2138fC9e5dA036D2a101A623b52F
NftLogic: 0x5c769753F192449c3c6AeC7BF2145928eb261699
ValidationLogic: 0x6be4a054629ff10Af2680696A5a5Dc8C525D977F
SupplyLogic: 0xDB8c2AE619685b26C26a9ff48698049C363784f3
BorrowLogic: 0x1Dc8C005cdd4a52136eDf5e7c4FC6C662E0f7E73
LiquidateLogic: 0x32727fA2ad74483C8DC1F899C5c06AcCd5eDAED8
LiquidateMarketsLogic: 0xBb94c69258B09B351E31972aDd0951f30E7f5ed6
ConfiguratorLogic: 0x76F965B99e9E216a648A8dB9F8aB459e880181Ff
LendPoolImpl: 0x8286b7d42cB141E1871a3475bB8E0C3F84db0352
LendPool: 0x69F6E45A08dA63146C35DBde9AaFc7B649e84Cea
LendPoolLoanImpl: 0xE2Ab82DeCBA9918885010Dd1A11a687339783116
LendPoolLoan: 0x4F930F53C8cE6D441AE1bf2bb1050BCE2ef8b5F9
LendPoolConfiguratorImpl: 0xa85e569EF873Cec2a82012C08057397F93aed686
LendPoolConfigurator: 0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A
UToken: 0x3Bd92b2536c4F1537c7c95eA4a203c182AC57973
DebtToken: 0xf3D4979e1d7b8a8b9750e79ceF466Efc46298403
ReserveOracleImpl: 0xd81cfDb25C4a27795c17A893F7813590614f2A90
ReserveOracle: 0x58dA2779DC5E99C46Ef9bCfCc6ac5cEC3b69bCcD
MockReserveOracle: 0x9718F7A661C0137d13EB4f0659dA5E8697075492
MockChainlinkOracle: 0xc5b75fA87Bc8F55bD989642DFE0Bbdd44748cD3b
NFTOracleImpl: 0x5F25714195e6Ba02cD01dB804f6222F924B9CC27
NFTOracle: 0x3d6471F2d560B3eC02F2Ed93b28BEAA7D6fCD482
MockNFTOracle: 0x2bf48F91bCDEf86aF5628EA3F4560873DD4249bD
InterestRate: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
rateStrategyWETH: 0xc70a92eA831e7AcBB2a40AE0ecd003DF75b5C015
rateStrategyStableTwo: 0xA5EAbe0237F780Dc4334FfaC7339BDd3608A3263
rateStrategyStableThree: 0x3c61970C2feB8087b23f54b57Cbab8786e71399d
WETHGatewayImpl: 0x7326573C3689831ADBf8050F1e5a2fB31C8441d8
WETHGateway: 0x51bda59320165617F7209a38D08b11ccefF58F1a
PunkGatewayImpl: 0xD024caf0B8667D0D50e87C35Da1AF295ccd96CeC
PunkGateway: 0xb16101f4b859580B810b683264102c49e12d0732
WalletBalanceProvider: 0x0b1c63041dd4a8049c61FAD207598c7Fd52D2D20
UnlockdProtocolDataProvider: 0xf002B72CdE6F0401840C7323c91c1fAfB495E5F5
UIPoolDataProvider: 0xA9f3bc8329C2Bba825D49937b25054c0FFFb7256
SelfdestructTransferMock: 0x3C2AeD703EF55ABE3C9D1080418406Fae704bae0 

Deployer: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.917146815373146597
PoolAdmin: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.917146815373146597
EmergencyAdmin: 0x51d25BEeef0193C96CFDA7fff9BD7411C2BdbDd3 Balance: 999999.999817306911354971
LendPoolLiquidator: 0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15 Balance: 999999.917146815373146597
-> Initialize make suite...
uDai 0xa6388056eCA8e9546E68E58A17EF2D00c30B300E
uUSDC 0x1e217a095DbF898A732d8419aBBedf8b7df3AD8b
uWETH 0xf1b719001AccaC7666C8c987F4e3acBAeF6E1C45
daiAdd 0x9D233A907E065855D2A9c7d4B552ea27fB2E5a36
usdcAdd 0x2f3A40A3db8a7e3D09B0adfEfbCe4f6F81927557
wethAdd 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6
allUNftTokens [
  [
    'WPUNKS',
    '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    'UBoundWPUNKS',
    '0xfC856EeEaE446258cc8f17C5421c507115dc912d',
    nftSymbol: 'WPUNKS',
    nftAddress: '0xd062F368df81E0A7f4fB6e8F5ce5AC7deD388796',
    uNftSymbol: 'UBoundWPUNKS',
    uNftAddress: '0xfC856EeEaE446258cc8f17C5421c507115dc912d'
  ],
  [
    'BAYC',
    '0x9278420Bf7548970799c56ef9A0B081862515330',
    'UBoundBAYC',
    '0x06cF13D8aD87307d50540223D3A08f63CDF8A211',
    nftSymbol: 'BAYC',
    nftAddress: '0x9278420Bf7548970799c56ef9A0B081862515330',
    uNftSymbol: 'UBoundBAYC',
    uNftAddress: '0x06cF13D8aD87307d50540223D3A08f63CDF8A211'
  ]
]
0x9278420Bf7548970799c56ef9A0B081862515330

***************
Setup and snapshot finished
***************

  Configurator-NFT
    ✓ Deactivates the BAYC NFT
    ✓ Deactivates the BAYC NFT Token
    ✓ Rectivates the BAYC NFT
    ✓ Rectivates the BAYC NFT Token
    ✓ Check the onlyAdmin on deactivateRNft 
    ✓ Check the onlyAdmin on activateNft 
    ✓ Freezes the BAYC NFT
    ✓ Freezes the BAYC NFT Token
    ✓ Unfreezes the BAYC NFT
    ✓ Unfreezes the BAYC NFT Token
    ✓ Check the onlyAdmin on freezeNft 
    ✓ Check the onlyAdmin on unfreezeNft 
    ✓ Deactivates the BAYC NFT as collateral
    ✓ Activates the BAYC NFT as collateral
    ✓ Check the onlyLtvManager on configureNftAsCollateral 

    1) Deactivates the BAYC NFT as auction

    2) Activates the BAYC NFT as auction
    ✓ Check the onlyLtvManager on configureNftAsAuction 
    ✓ Batch Deactivates the BAYC NFT as collateral
    ✓ Batch Activates the BAYC NFT as collateral
    ✓ Check the onlyAdmin on batchConfigNft 
    ✓ Batch Deactivates the BAYC NFT as auction
    ✓ Batch Activates the BAYC NFT as auction
    ✓ Reverts when trying to disable the BAYC nft with liquidity on it
    ✓ Config setMaxNumberOfNfts invalid value
    ✓ Config setMaxNumberOfNfts invalid value overflowing
    ✓ Check the onlyAdmin on setMaxNumberOfNfts 
    ✓ Config the timeFrame for an X amount of time
    ✓ Check if the config timestamp is correct
    ✓ Check if general configurations are correct

·---------------------------------------------------------------------|---------------------------|-------------|-----------------------------·
|                         [90mSolc version: 0.8.4[39m                         ·  [90mOptimizer enabled: true[39m  ·  [90mRuns: 200[39m  ·  [90mBlock limit: 12450000 gas[39m  │
······································································|···························|·············|······························
|  [32m[1mMethods[22m[39m                                                                                                                                    │
······································|·······························|·············|·············|·············|···············|··············
|  [1mContract[22m                           ·  [1mMethod[22m                       ·  [32mMin[39m        ·  [32mMax[39m        ·  [32mAvg[39m        ·  [1m# calls[22m      ·  [1meur (avg)[22m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m                  ·  allInitialOwnersAssigned     ·          -  ·          -  ·      45518  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCustomERC721[39m                       ·  setApprovalForAll            ·          -  ·          -  ·      46224  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mCustomERC721[39m                       ·  transferFrom                 ·          -  ·          -  ·      96740  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  approve                      ·          -  ·          -  ·      46135  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mERC20Upgradeable[39m                   ·  transfer                     ·          -  ·          -  ·      34659  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setAddress                   ·          -  ·          -  ·      49033  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setEmergencyAdmin            ·          -  ·          -  ·      47355  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setIncentivesController      ·      [36m30275[39m  ·      [31m47363[39m  ·      38819  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolConfiguratorImpl  ·          -  ·          -  ·     610449  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolImpl              ·          -  ·          -  ·     698786  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolLiquidator        ·          -  ·          -  ·      47443  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLendPoolLoanImpl          ·          -  ·          -  ·     659480  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setLSSVMRouter               ·          -  ·          -  ·      47442  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setNFTOracle                 ·          -  ·          -  ·      47421  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setNFTXVaultFactory          ·          -  ·          -  ·      47377  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setPoolAdmin                 ·          -  ·          -  ·      47444  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setReserveOracle             ·          -  ·          -  ·      47354  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setSushiSwapRouter           ·          -  ·          -  ·      47399  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUIDataProvider            ·          -  ·          -  ·      47295  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUNFTRegistry              ·      [36m27476[39m  ·      [31m47376[39m  ·      37426  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setUnlockdDataProvider       ·          -  ·          -  ·      47421  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m          ·  setWalletBalanceProvider     ·          -  ·          -  ·      47463  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProviderRegistry[39m  ·  registerAddressesProvider    ·          -  ·          -  ·      92000  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchConfigNft               ·      [36m88006[39m  ·    [31m1104812[39m  ·     753310  ·           [90m12[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchConfigReserve           ·          -  ·          -  ·      97648  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchInitNft                 ·     [36m241669[39m  ·     [31m256961[39m  ·     249315  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  batchInitReserve             ·    [36m1616353[39m  ·    [31m1631513[39m  ·    1621426  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  configureNftsAsCollateral    ·      [36m96929[39m  ·     [31m133929[39m  ·     112291  ·            [90m5[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnNft           ·      [36m78169[39m  ·      [31m83774[39m  ·      80972  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setActiveFlagOnNftByTokenId  ·      [36m69663[39m  ·      [31m69675[39m  ·      69669  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setBorrowingFlagOnReserve    ·          -  ·          -  ·      66646  ·            [90m6[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnNft           ·      [36m66644[39m  ·      [31m66657[39m  ·      66651  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setFreezeFlagOnNftByTokenId  ·      [36m69593[39m  ·      [31m69605[39m  ·      69599  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setLtvManagerStatus          ·      [36m39630[39m  ·      [31m59530[39m  ·      49580  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m               ·  setPoolPause                 ·      [36m81475[39m  ·     [31m101218[39m  ·      91347  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  borrow                       ·          -  ·          -  ·     763086  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  deposit                      ·          -  ·          -  ·     228063  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m               ·  setTimeframe                 ·      [36m60988[39m  ·      [31m78100[39m  ·      69547  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  addCollection                ·          -  ·          -  ·      54843  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  initialize                   ·          -  ·          -  ·     113794  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m                      ·  setPriceManagerStatus        ·          -  ·          -  ·      33894  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  initialize                   ·          -  ·          -  ·      90917  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m                  ·  setAggregators               ·          -  ·          -  ·     196520  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                        ·  authorizeLendPoolERC20       ·          -  ·          -  ·     157809  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mSelfdestructTransfer[39m               ·  destroyAndTransfer           ·          -  ·          -  ·      29265  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mUNFTRegistry[39m                       ·  createUNFT                   ·     [36m725406[39m  ·     [31m742551[39m  ·     733979  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                        ·  authorizeLendPoolNFT         ·          -  ·          -  ·      99328  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······································|·······························|·············|·············|·············|···············|··············
|  [32m[1mDeployments[22m[39m                                                        ·                                         ·  [1m% of limit[22m   ·             │
······································································|·············|·············|·············|···············|··············
|  BorrowLogic                                                        ·          -  ·          -  ·    2066318  ·       [90m16.6 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ConfiguratorLogic                                                  ·          -  ·          -  ·    1970094  ·       [90m15.8 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  CryptoPunksMarket                                                  ·          -  ·          -  ·    2378109  ·       [90m19.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  DebtToken                                                          ·          -  ·          -  ·    1366344  ·         [90m11 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  GenericLogic                                                       ·          -  ·          -  ·      84278  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  InterestRate                                                       ·     [36m616243[39m  ·     [31m616255[39m  ·     616251  ·        [90m4.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPool                                                           ·          -  ·          -  ·    4943082  ·       [90m39.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolAddressesProvider                                          ·          -  ·          -  ·    2978496  ·       [90m23.9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolAddressesProviderRegistry                                  ·          -  ·          -  ·     502283  ·          [90m4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolConfigurator                                               ·          -  ·          -  ·    5196741  ·       [90m41.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LendPoolLoan                                                       ·          -  ·          -  ·    3232544  ·         [90m26 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LiquidateLogic                                                     ·          -  ·          -  ·    3804663  ·       [90m30.6 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  LiquidateMarketsLogic                                              ·          -  ·          -  ·    2912395  ·       [90m23.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockChainlinkOracle                                                ·          -  ·          -  ·     620122  ·          [90m5 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockIncentivesController                                           ·          -  ·          -  ·     142669  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockNFTOracle                                                      ·          -  ·          -  ·    1117453  ·          [90m9 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  MockReserveOracle                                                  ·          -  ·          -  ·    1280668  ·       [90m10.3 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  NftLogic                                                           ·          -  ·          -  ·     141022  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  NFTOracle                                                          ·          -  ·          -  ·    1047527  ·        [90m8.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  PunkGateway                                                        ·          -  ·          -  ·    3290566  ·       [90m26.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ReserveLogic                                                       ·          -  ·          -  ·     171208  ·        [90m1.4 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ReserveOracle                                                      ·          -  ·          -  ·    1211618  ·        [90m9.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  SelfdestructTransfer                                               ·          -  ·          -  ·      88001  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  SupplyLogic                                                        ·          -  ·          -  ·    1184808  ·        [90m9.5 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UiPoolDataProvider                                                 ·          -  ·          -  ·    3116123  ·         [90m25 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UNFT                                                               ·          -  ·          -  ·    1503057  ·       [90m12.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UNFTRegistry                                                       ·          -  ·          -  ·    2441516  ·       [90m19.6 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UnlockdProtocolDataProvider                                        ·          -  ·          -  ·    2888605  ·       [90m23.2 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UnlockdProxyAdmin                                                  ·          -  ·          -  ·     470704  ·        [90m3.8 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UnlockdUpgradeableProxy                                            ·     [36m689038[39m  ·     [31m998847[39m  ·     777218  ·        [90m6.2 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  UToken                                                             ·          -  ·          -  ·    1927519  ·       [90m15.5 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  ValidationLogic                                                    ·          -  ·          -  ·    1528605  ·       [90m12.3 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  WalletBalanceProvider                                              ·          -  ·          -  ·    1251342  ·       [90m10.1 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  WETHGateway                                                        ·          -  ·          -  ·    2587824  ·       [90m20.8 %[39m  ·          [32m[90m-[32m[39m  │
······································································|·············|·············|·············|···············|··············
|  WrappedPunk                                                        ·          -  ·          -  ·    1992593  ·         [90m16 %[39m  ·          [32m[90m-[32m[39m  │
·---------------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------·

  28 passing (23s)
  2 failing

  1) Configurator-NFT
       Deactivates the BAYC NFT as auction:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '107'", method="estimateGas", transaction={"from":"0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15","to":"0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A","data":"0x095213a30000000000000000000000009278420bf7548970799c56ef9a0b0818625153300000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"configureNftAsAuction","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":424,"range":[14802,15666]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyPoolAdmin","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":40,"range":[1795,1881]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,49,48,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130370000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)

  2) Configurator-NFT
       Activates the BAYC NFT as auction:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '107'", method="estimateGas", transaction={"from":"0x5b69E6884C70f42819Fb35Bf3C25578ee11AAA15","to":"0xc56367dd8b7a94a9E5dDE9467c570c6bEd16924A","data":"0x095213a30000000000000000000000009278420bf7548970799c56ef9a0b0818625153300000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"configureNftAsAuction","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":424,"range":[14802,15666]},"functionType":1},{"type":4,"sourceReference":{"function":"onlyPoolAdmin","contract":"LendPoolConfigurator","sourceName":"contracts/protocol/LendPoolConfigurator.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUNFTRegistry} from \"../interfaces/IUNFTRegistry.sol\";\nimport {ILendPoolConfigurator} from \"../interfaces/ILendPoolConfigurator.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {ConfiguratorLogic} from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../libraries/types/ConfigTypes.sol\";\nimport {INFTOracle} from \"../interfaces/INFTOracle.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title LendPoolConfigurator contract\n * @author Unlockd\n * @dev Implements the configuration methods for the Unlockd protocol\n **/\n\ncontract LendPoolConfigurator is Initializable, ILendPoolConfigurator {\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n  ILendPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => bool) public isLtvManager;\n\n  modifier onlyLtvManager() {\n    require(isLtvManager[msg.sender], Errors.CALLER_NOT_LTV_MANAGER);\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin() {\n    require(_addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPoolConfigurator contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   * @param input the input array with data to initialize each reserve\n   **/\n  function batchInitReserve(ConfigTypes.InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitReserve(_addressesProvider, cachedPool, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes NFTs in batch\n   * @param input the input array with data to initialize each NFT\n   **/\n  function batchInitNft(ConfigTypes.InitNftInput[] calldata input) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    IUNFTRegistry cachedRegistry = _getUNFTRegistry();\n    uint256 inputLength = input.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeInitNft(cachedPool, cachedRegistry, input[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the uToken implementation for the reserve\n   * @param inputs the inputs array with data to update each UToken\n   **/\n  function updateUToken(ConfigTypes.UpdateUTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateUToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the debt token implementation for the asset\n   * @param inputs the inputs array with data to update each debt token\n   **/\n  function updateDebtToken(ConfigTypes.UpdateDebtTokenInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      ConfiguratorLogic.executeUpdateDebtToken(cachedPool, inputs[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Enables or disables borrowing on each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setBorrowingFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (flag) {\n      currentConfig.setBorrowingEnabled(true);\n    } else {\n      currentConfig.setBorrowingEnabled(false);\n    }\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit BorrowingEnabledOnReserve(asset);\n    } else {\n      emit BorrowingDisabledOnReserve(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setActiveFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    if (!flag) {\n      _checkReserveNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit ReserveActivated(asset);\n    } else {\n      emit ReserveDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each reserve\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each reserve\n   **/\n  function setFreezeFlagOnReserve(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setFrozen(flag);\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit ReserveFrozen(asset);\n    } else {\n      emit ReserveUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    cachedPool.setReserveConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param assets The addresses of the underlying asset of the reserve\n   * @param rateAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateAddress(address[] calldata assets, address rateAddress) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setReserveInterestRateAddress(assets[i], rateAddress);\n      emit ReserveInterestRateChanged(assets[i], rateAddress);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures reserves in batch\n   * @param inputs the input array with data to configure each reserve\n   **/\n  function batchConfigReserve(ConfigReserveInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputLength = inputs.length;\n    for (uint256 i = 0; i < inputLength; ) {\n      DataTypes.ReserveConfigurationMap memory currentConfig = cachedPool.getReserveConfiguration(inputs[i].asset);\n\n      currentConfig.setReserveFactor(inputs[i].reserveFactor);\n\n      cachedPool.setReserveConfiguration(inputs[i].asset, currentConfig.data);\n\n      emit ReserveFactorChanged(inputs[i].asset, inputs[i].reserveFactor);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT\n   * @param asset the NFTs to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n\n    if (!flag) {\n      _checkNftNoLiquidity(asset);\n    }\n    currentConfig.setActive(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n\n    if (flag) {\n      emit NftActivated(asset);\n    } else {\n      emit NftDeactivated(asset);\n    }\n  }\n\n  /**\n   * @dev Activates or deactivates each NFT asset\n   * @param assets the NFTs to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setActiveFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    uint256 assetsLength = assets.length;\n    require(assetsLength == tokenIds.length, Errors.LPC_PARAMS_MISMATCH);\n\n    ILendPool cachedPool = _getLendPool();\n\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setActive(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenActivated(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenDeactivated(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT\n   * @param asset the assets to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNft(address asset, bool flag) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfiguration(asset);\n    currentConfig.setFrozen(flag);\n    cachedPool.setNftConfiguration(asset, currentConfig.data);\n    if (flag) {\n      emit NftFrozen(asset);\n    } else {\n      emit NftUnfrozen(asset);\n    }\n  }\n\n  /**\n   * @dev Freezes or unfreezes each NFT token\n   * @param assets the assets to update the flag to\n   * @param tokenIds the NFT token ids to update the flag to\n   * @param flag the flag to set to the each NFT\n   **/\n  function setFreezeFlagOnNftByTokenId(\n    address[] calldata assets,\n    uint256[] calldata tokenIds,\n    bool flag\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(assets[i], tokenIds[i]);\n\n      currentConfig.setFrozen(flag);\n      cachedPool.setNftConfigByTokenId(assets[i], tokenIds[i], currentConfig.data);\n\n      if (flag) {\n        emit NftTokenFrozen(assets[i], tokenIds[i]);\n      } else {\n        emit NftTokenUnfrozen(assets[i], tokenIds[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function configureNftsAsCollateral(ConfigNftAsCollateralInput[] calldata collateralData) external onlyLtvManager {\n    uint256 cachedLength = collateralData.length;\n    for (uint8 i; i < cachedLength; ) {\n      _configureNftAsCollateral(collateralData[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures the NFT collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param collateralData The NFT collateral configuration data\n   **/\n  function _configureNftAsCollateral(ConfigNftAsCollateralInput calldata collateralData) internal {\n    {\n      ILendPool cachedPool = _getLendPool();\n\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        collateralData.asset,\n        collateralData.nftTokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(collateralData.ltv <= collateralData.liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (collateralData.liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(collateralData.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(collateralData.liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      currentConfig.setLtv(collateralData.ltv);\n      currentConfig.setLiquidationThreshold(collateralData.liquidationThreshold);\n      currentConfig.setRedeemThreshold(collateralData.redeemThreshold);\n      currentConfig.setLiquidationBonus(collateralData.liquidationBonus);\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      //validation of the parameters: the redeem duration can\n      //only be lower or equal than the auction duration\n      require(collateralData.redeemDuration <= collateralData.auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n      currentConfig.setRedeemDuration(collateralData.redeemDuration);\n      currentConfig.setAuctionDuration(collateralData.auctionDuration);\n      currentConfig.setRedeemFine(collateralData.redeemFine);\n      currentConfig.setMinBidFine(collateralData.minBidFine);\n      currentConfig.setConfigTimestamp(block.timestamp);\n\n      cachedPool.setNftConfigByTokenId(collateralData.asset, collateralData.nftTokenId, currentConfig.data);\n\n      INFTOracle(_addressesProvider.getNFTOracle()).setNFTPrice(\n        collateralData.asset,\n        collateralData.nftTokenId,\n        collateralData.newPrice\n      );\n    }\n    emit NftConfigurationChanged(\n      collateralData.asset,\n      collateralData.nftTokenId,\n      collateralData.ltv,\n      collateralData.liquidationThreshold,\n      collateralData.liquidationBonus\n    );\n  }\n\n  /**\n   * @dev Configures the NFT auction parameters\n   * @param asset The address of the underlying NFT asset\n   * @param redeemDuration The max duration for the redeem\n   * @param auctionDuration The auction duration\n   * @param redeemFine The fine for the redeem\n   **/\n  function configureNftAsAuction(\n    address asset,\n    uint256 nftTokenId,\n    uint256 redeemDuration,\n    uint256 auctionDuration,\n    uint256 redeemFine\n  ) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    //validation of the parameters: the redeem duration can\n    //only be lower or equal than the auction duration\n    require(redeemDuration <= auctionDuration, Errors.LPC_INVALID_CONFIGURATION);\n\n    currentConfig.setRedeemDuration(redeemDuration);\n    currentConfig.setAuctionDuration(auctionDuration);\n    currentConfig.setRedeemFine(redeemFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftAuctionChanged(asset, nftTokenId, redeemDuration, auctionDuration, redeemFine);\n  }\n\n  /**\n   * @dev Configures the redeem threshold\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param redeemThreshold The threshold for the redeem\n   **/\n  function setNftRedeemThreshold(address asset, uint256 nftTokenId, uint256 redeemThreshold) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setRedeemThreshold(redeemThreshold);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftRedeemThresholdChanged(asset, nftTokenId, redeemThreshold);\n  }\n\n  /**\n   * @dev Configures the minimum fine for the underlying asset\n   * @param asset The address of the underlying NFT asset\n   * @param nftTokenId the tokenId of the asset\n   * @param minBidFine The minimum bid fine value\n   **/\n  function setNftMinBidFine(address asset, uint256 nftTokenId, uint256 minBidFine) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(asset, nftTokenId);\n\n    currentConfig.setMinBidFine(minBidFine);\n\n    cachedPool.setNftConfigByTokenId(asset, nftTokenId, currentConfig.data);\n\n    emit NftMinBidFineChanged(asset, nftTokenId, minBidFine);\n  }\n\n  /**\n   * @dev Configures the maximum supply and token Id for the underlying NFT assets\n   * @param assets The address of the underlying NFT assets\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token Id value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address[] calldata assets,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 assetsLength = assets.length;\n    for (uint256 i = 0; i < assetsLength; ) {\n      cachedPool.setNftMaxSupplyAndTokenId(assets[i], maxSupply, maxTokenId);\n\n      emit NftMaxSupplyAndTokenIdChanged(assets[i], maxSupply, maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Configures NFTs in batch\n   * @param inputs the input array with data to configure each NFT asset\n   **/\n  //TODO: solve this to accept multi Ids\n  function batchConfigNft(ConfigNftInput[] calldata inputs) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    uint256 inputsLength = inputs.length;\n    for (uint256 i = 0; i < inputsLength; ) {\n      DataTypes.NftConfigurationMap memory currentConfig = cachedPool.getNftConfigByTokenId(\n        inputs[i].asset,\n        inputs[i].tokenId\n      );\n\n      //validation of the parameters: the LTV can\n      //only be lower or equal than the liquidation threshold\n      //(otherwise a loan against the asset would cause instantaneous liquidation)\n      require(inputs[i].baseLTV <= inputs[i].liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n      if (inputs[i].liquidationThreshold != 0) {\n        //liquidation bonus must be smaller than 100.00%\n        require(inputs[i].liquidationBonus < PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n      } else {\n        require(inputs[i].liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      }\n\n      // Active & Frozen Flag\n      currentConfig.setActive(true);\n      currentConfig.setFrozen(false);\n\n      // collateral parameters\n      currentConfig.setLtv(inputs[i].baseLTV);\n      currentConfig.setLiquidationThreshold(inputs[i].liquidationThreshold);\n      currentConfig.setLiquidationBonus(inputs[i].liquidationBonus);\n\n      // auction parameters\n      currentConfig.setRedeemDuration(inputs[i].redeemDuration);\n      currentConfig.setAuctionDuration(inputs[i].auctionDuration);\n      currentConfig.setRedeemFine(inputs[i].redeemFine);\n      currentConfig.setRedeemThreshold(inputs[i].redeemThreshold);\n      currentConfig.setMinBidFine(inputs[i].minBidFine);\n\n      cachedPool.setNftConfigByTokenId(inputs[i].asset, inputs[i].tokenId, currentConfig.data);\n\n      emit NftConfigurationChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].baseLTV,\n        inputs[i].liquidationThreshold,\n        inputs[i].liquidationBonus\n      );\n      emit NftAuctionChanged(\n        inputs[i].asset,\n        inputs[i].tokenId,\n        inputs[i].redeemDuration,\n        inputs[i].auctionDuration,\n        inputs[i].redeemFine\n      );\n      emit NftRedeemThresholdChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].redeemThreshold);\n      emit NftMinBidFineChanged(inputs[i].asset, inputs[i].tokenId, inputs[i].minBidFine);\n\n      // max limit\n      cachedPool.setNftMaxSupplyAndTokenId(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n      emit NftMaxSupplyAndTokenIdChanged(inputs[i].asset, inputs[i].maxSupply, inputs[i].maxTokenId);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev sets the max amount of reserves\n   * @param newVal the new value to set as the max reserves\n   **/\n  function setMaxNumberOfReserves(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 32\n    uint256 curVal = cachedPool.getMaxNumberOfReserves();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfReserves(newVal);\n  }\n\n  /**\n   * @dev sets the max amount of NFTs\n   * @param newVal the new value to set as the max NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 newVal) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    //default value is 256\n    uint256 curVal = cachedPool.getMaxNumberOfNfts();\n    require(newVal > curVal, Errors.LPC_INVALID_CONFIGURATION);\n    cachedPool.setMaxNumberOfNfts(newVal);\n  }\n\n  /**\n   * @dev sets the liquidation fee percentage\n   * @param newVal the new value to set as the max fee percentage\n   **/\n  function setLiquidationFeePercentage(uint256 newVal) external onlyPoolAdmin {\n    require(newVal < 1000, Errors.LPC_FEE_PERCENTAGE_TOO_HIGH); //prevent setting incorrect values and ensure fee is not too high (10% max)\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setLiquidateFeePercentage(newVal);\n  }\n\n  /**\n   * @dev sets the max timeframe between an NFT config trigger and a borrow\n   * @param newTimeframe the new value to set as the timeframe\n   **/\n  function setTimeframe(uint256 newTimeframe) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setTimeframe(newTimeframe);\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   * @param marketId the id of the market\n   * @param val `true` if it is supported, `false`otherwise\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 marketId, bool val) external onlyLtvManager {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setIsMarketSupported(nftAsset, marketId, val);\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the fee amount\n   **/\n  function setConfigFee(uint256 configFee) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setConfigFee(configFee);\n  }\n\n  /**\n   * @dev Sets auctionDurationConfigFee amount to be charged for first bids\n   * @param auctionDurationConfigFee the fee amount\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external onlyLtvManager {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setAuctionDurationConfigFee(auctionDurationConfigFee);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including uToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.setPause(val);\n  }\n\n  function setLtvManagerStatus(address newLtvManager, bool val) external onlyPoolAdmin {\n    require(newLtvManager != address(0), Errors.LPC_INVALID_LTVMANAGER_ADDRESS);\n    isLtvManager[newLtvManager] = val;\n  }\n\n  /**\n   * @dev Sets new pool rescuer\n   * @param rescuer the new rescuer address\n   **/\n  function setPoolRescuer(address rescuer) external onlyPoolAdmin {\n    ILendPool cachedPool = _getLendPool();\n    cachedPool.updateRescuer(rescuer);\n  }\n\n  /**\n   * @dev Returns the token implementation contract address\n   * @param proxyAddress  The address of the proxy contract\n   * @return The address of the token implementation contract\n   **/\n  function getTokenImplementation(address proxyAddress) external view onlyPoolAdmin returns (address) {\n    return ConfiguratorLogic.getTokenImplementation(proxyAddress);\n  }\n\n  /**\n   * @dev Checks the liquidity of reserves\n   * @param asset  The address of the underlying reserve asset\n   **/\n  function _checkReserveNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = _getLendPool().getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Upgradeable(asset).balanceOf(reserveData.uTokenAddress);\n\n    require(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Checks the liquidity of NFTs\n   * @param asset  The address of the underlying NFT asset\n   **/\n  function _checkNftNoLiquidity(address asset) internal view {\n    uint256 collateralAmount = _getLendPoolLoan().getNftCollateralAmount(asset);\n\n    require(collateralAmount == 0, Errors.LPC_NFT_LIQUIDITY_NOT_0);\n  }\n\n  /**\n   * @dev Returns the LendPool address stored in the addresses provider\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressesProvider.getLendPool());\n  }\n\n  /**\n   * @dev Returns the LendPoolLoan address stored in the addresses provider\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev Returns the UNFTRegistry address stored in the addresses provider\n   **/\n  function _getUNFTRegistry() internal view returns (IUNFTRegistry) {\n    return IUNFTRegistry(_addressesProvider.getUNFTRegistry());\n  }\n}\n","line":40,"range":[1795,1881]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,49,48,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130370000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:533:9)



