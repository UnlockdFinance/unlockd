
> @unlockddao/unlockd-protocol@1.0.2 test:file
> npm run compile && TS_NODE_TRANSPILE_ONLY=1 hardhat test ./test/__setup.spec.ts ./test/${TEST_FILE}


> @unlockddao/unlockd-protocol@1.0.2 compile
> cross-env SKIP_LOAD=true hardhat compile

Nothing to compile
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!
/Users/adri/work/unlockd-protocol-v1/unlockd-tasks/tasks
Creating Typechain artifacts in directory types for target ethers-v5
Successfully generated Typechain artifacts!

- Enviroment
  - Fork Mode activated at network:  main
  - Provider URL: eth-mainnet.g.alchemy.com
  - Network : hardhat
Deployer: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 10000.0 ETH
PoolAdmin: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 10000.0 ETH
EmergencyAdmin: 0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d Balance: 10000.0 ETH
LendPool Liquidator: 0xA296478f65BCDA4153343c8D1f24D768110D6e16 Balance: 10000.0 ETH


Migration started


Deploy UNFT Registry


Deploy lend pool
Deploying new libraries implementation...
*** GenericLogic ***

Network: hardhat
tx: 0x389d9c5aaca336f29cc3a30a18b4a833b436bc38d26e3fcaf1bf46c625766894
contract address: 0x26E2E24EBE33D34E88415fa6aE14C87C33FBcC38
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 16091545875
gas used: 84290

******

contracts-helpers:registerContractInJsonDb, contractId: GenericLogic address: 0x26E2E24EBE33D34E88415fa6aE14C87C33FBcC38 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ReserveLogic ***

Network: hardhat
tx: 0x0626d0edb1bef9bdc033e2a9bd31044f159826914bc8c7d7d63e2ccd685beeed
contract address: 0x99F8004245fd740Eee907E14FbCA0B6679030b04
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 14230646143
gas used: 171208

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveLogic address: 0x99F8004245fd740Eee907E14FbCA0B6679030b04 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** NftLogic ***

Network: hardhat
tx: 0xf170b76c378ef8d6349108b752f4dc7db1f281d34e9d56c0d43951a9f7b1814b
contract address: 0x46343361Ef2b0a7917160B1762282970DE0F27eB
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 12622301168
gas used: 141022

******

contracts-helpers:registerContractInJsonDb, contractId: NftLogic address: 0x46343361Ef2b0a7917160B1762282970DE0F27eB deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ValidationLogic ***

Network: hardhat
tx: 0x2c1e3ab46aafcaf32288a4ee3d1a8a05de419325d05f4a53033a2c510bcdb9b2
contract address: 0xb93B673FcC340c81D93b4d482b8451Ca4CF12C68
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 11202425172
gas used: 1573518

******

contracts-helpers:registerContractInJsonDb, contractId: ValidationLogic address: 0xb93B673FcC340c81D93b4d482b8451Ca4CF12C68 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** SupplyLogic ***

Network: hardhat
tx: 0x5e93cfa69b91a7b97c0efb00069f55765728a231258034335d9dbcdab04ef3ea
contract address: 0xEAf162687EF016F189CEBA6d51A25571A96dEa96
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 10249485473
gas used: 1235281

******

contracts-helpers:registerContractInJsonDb, contractId: SupplyLogic address: 0xEAf162687EF016F189CEBA6d51A25571A96dEa96 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** BorrowLogic ***

Network: hardhat
tx: 0x4c7a19dabee79204374c4b8508ae2e0ac9d357a5c01891646f1ef0a6360d7c5e
contract address: 0xD4b33077B7fD153C086BA53d3dC015Ce4Bc72077
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 9322731791
gas used: 2117672

******

contracts-helpers:registerContractInJsonDb, contractId: BorrowLogic address: 0xD4b33077B7fD153C086BA53d3dC015Ce4Bc72077 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LiquidateLogic ***

Network: hardhat
tx: 0x1786d03fdf9f18ba7ec4b3fbc31cc942620e4062b785d3de503c27bc729d594e
contract address: 0xc0F76A7803950584503681bcD5849473ecafbB2f
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 8636302287
gas used: 3977175

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateLogic address: 0xc0F76A7803950584503681bcD5849473ecafbB2f deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LiquidateMarketsLogic ***

Network: hardhat
tx: 0xf47df2fc2cf5305a4169038eb11b27994ab5ab62b3df52b7206e54bb93a68ec2
contract address: 0x1585f2dCcCACc5eDe1bC7F34E3f47360f6C9fb15
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 8291622143
gas used: 3025524

******

contracts-helpers:registerContractInJsonDb, contractId: LiquidateMarketsLogic address: 0x1585f2dCcCACc5eDe1bC7F34E3f47360f6C9fb15 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** LendingLogic ***

Network: hardhat
tx: 0x407afe264045989dbdd9d938feed0ef13ccd18aa6e01104d746d58f01cbbf031
contract address: 0x48b86797F545b291c5aB86233fC14ff924819A7A
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 7823160898
gas used: 72217

******

contracts-helpers:registerContractInJsonDb, contractId: LendingLogic address: 0x48b86797F545b291c5aB86233fC14ff924819A7A deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
*** ConfiguratorLogic ***

Network: hardhat
tx: 0x0c36c691ac43369e93d341ab219194901d7841432af173ed50e977b4605e054f
contract address: 0xC7553877733B9cAfc396A254906f4dBFdE24F0D9
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 6980160329
gas used: 1970106

******

contracts-helpers:registerContractInJsonDb, contractId: ConfiguratorLogic address: 0xC7553877733B9cAfc396A254906f4dBFdE24F0D9 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Deploying new lend pool implementation ...
contracts-helpers:insertContractAddressInDb, id: LendPoolImpl address 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6
*** LendPool ***

Network: hardhat
tx: 0x1c1e0f9a272cda4305ba4233f3c8e90701efd9db83435cd938290a8fb278616b
contract address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 6469217592
gas used: 5269514

******

contracts-helpers:registerContractInJsonDb, contractId: LendPool address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool implementation with address: 0x7aD5757a964d8E73ae75607E023ac7C3EBF2AaA6
contracts-helpers:insertContractAddressInDb, id: LendPool address 0xFC7f036a8FB66D031675239413F9179A82932a53
Deploying new loan implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolLoanImpl address 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0
*** LendPoolLoan ***

Network: hardhat
tx: 0x789faad6dd7d399acf350e2b8c5e1ecd6188132cb10eb88c8df6af6b40c820a5
contract address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 5698416926
gas used: 3272699

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolLoan address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool loan implementation with address: 0xF30bEeAD1A45849d9edd58ead8fd8C493769c2e0
contracts-helpers:insertContractAddressInDb, id: LendPoolLoan address 0x00da789CEBF4A0da965FbcB9e4d72F1A15c67Eb6
Deploying new configurator implementation...
contracts-helpers:insertContractAddressInDb, id: LendPoolConfiguratorImpl address 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5
*** LendPoolConfigurator ***

Network: hardhat
tx: 0x40379c9fd1e0098d4471e0fa4e615b971e626a9de0141b5339ac02436647186d
contract address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 4871246473
gas used: 5230541

******

contracts-helpers:registerContractInJsonDb, contractId: LendPoolConfigurator address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Setting lend pool configurator implementation with address: 0xA38aF170a6030A4AA6A73F27e31913896D02d9E5
contracts-helpers:insertContractAddressInDb, id: LendPoolConfigurator address 0x82CefdbdFe6c4A868962E7B78A3CE54f952FE209
Deploying new generic UToken implementation...
*** UToken ***

Network: hardhat
tx: 0x985e0e271a8b6c02b304ebb2576868718ad6ab577e94b337c49822e6ab76f1cf
contract address: 0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 3913234605
gas used: 2710730

******

contracts-helpers:registerContractInJsonDb, contractId: UToken address: 0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Upgrading UTokens with implementation  0xeDfBc20906e2A6EEdF51CF9E0847EE12E8C24a38
{ WETH: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' }
[
  '0xE6cd031FB0D9A79FD8CD3035B9228F78ff459B07',
  '800000000000000000000000000',
  '200000000000000000000000000',
  '160000000000000000000000000',
  '2000000000000000000000000000'
]
*** InterestRate ***

Network: hardhat
tx: 0xc1a2f031ba03268270974270b366c6862f4eb362d9f9aee30508eb200c541ddd
contract address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2822867427
gas used: 613848

******

contracts-helpers:registerContractInJsonDb, contractId: InterestRate address: 0x46dBEC49711AB9b6231571c9BB8566a61c7F2403 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
contracts-helpers:rawInsertContractAddressInDb, id: rateStrategyWETH address undefined


Deploy reserve oracle
PROXY admin: 0xb7493E15Af772c14c7cE3180Ff388925e6593c6b
contracts-helpers:insertContractAddressInDb, id: ReserveOracleImpl address 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
*** ReserveOracle ***

Network: hardhat
tx: 0xb20650dbc2fa5364736013f0750429a22ef164bb5c8a22fa3f91c3823031ec91
contract address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2417444332
gas used: 1211618

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x619D601151F99eA38D058419B7f9c4dC21bE5f74 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Deploying new reserve oracle proxy & implementation...
*** ReserveOracle ***

Network: hardhat
tx: 0x969ce5933c3286be61865563092e36b8b18aa76704c9d0892de306d5eeadd570
contract address: 0x9af65377B22db90Bf8E244118D900cb5912C06A0
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 2274749756
gas used: 689038

******

contracts-helpers:registerContractInJsonDb, contractId: ReserveOracle address: 0x9af65377B22db90Bf8E244118D900cb5912C06A0 deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
Reserve Oracle: proxy 0x9af65377B22db90Bf8E244118D900cb5912C06A0, implementation 0x619D601151F99eA38D058419B7f9c4dC21bE5f74
-> Deploy mock reserve oracle...
*** MockReserveOracle ***

Network: hardhat
tx: 0x57ca203d5c15bddeba248eb880883cf7d699c1ec564955732970dd34ecbf61f4
contract address: 0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1870108989
gas used: 1280668

******

contracts-helpers:registerContractInJsonDb, contractId: MockReserveOracle address: 0x5e26B6dFe23592f0f66dd148DA0E38a602539F8e deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
-> Deploy mock ChainLink oracle...
*** MockChainlinkOracle ***

Network: hardhat
tx: 0xd84d466835237a10fca54a22dd769ac5ded5f19511ea919f3664ffc52f7687a6
contract address: 0x9bD271073c7BC8BDa93Be6f7b3B85Bd30fEAa7FE
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1687186919
gas used: 620122

******

contracts-helpers:registerContractInJsonDb, contractId: MockChainlinkOracle address: 0x9bD271073c7BC8BDa93Be6f7b3B85Bd30fEAa7FE deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0


Deploy nft oracle
Reuse existed nft oracle: 0xed1a46EBE904dD6562f5F20A515009752Fb5bAdE
-> Prepare mock nft oracle...
*** MockNFTOracle ***

Network: hardhat
tx: 0xc116ffea710cbe13335cdf8447487c0b2b1974f9a97517dfbdfdfd720bbe92b5
contract address: 0xE265605de1d4560F231f6c2739F1e7D2A631d84a
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1533951900
gas used: 1117453

******

contracts-helpers:registerContractInJsonDb, contractId: MockNFTOracle address: 0xE265605de1d4560F231f6c2739F1e7D2A631d84a deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0


Initialize lend pool
Setting YVaultWETH with address:  0xa258C4606Ca8206D8aA700cE2143D7db854D168c  in addressesProvider...


Deploy WETH Gateway


Deploy PUNK Gateway


Deploy data provider
*** UnlockdProtocolDataProvider ***

Network: hardhat
tx: 0xc5d1a998ef568f6cd023b2002c0bc47391446caf0dee9a68011f76b8f7342508
contract address: 0xDD6f141853933161aa9988Ca1A437a70feC0347b
deployer address: 0x67539d650922Af9D2c611251ac9749f167e51Ac0
gas price: 1368254037
gas used: 2891625

******

contracts-helpers:registerContractInJsonDb, contractId: UnlockdProtocolDataProvider address: 0xDD6f141853933161aa9988Ca1A437a70feC0347b deployer 0x67539d650922Af9D2c611251ac9749f167e51Ac0
UnlockdProtocolDataProvider deployed at: 0xDD6f141853933161aa9988Ca1A437a70feC0347b


Finished migrations
Contracts deployed at hardhat
---------------------------------
N# Contracts: 44
UnlockdProxyAdminPool: 0xb7493E15Af772c14c7cE3180Ff388925e6593c6b
NFTOracleImpl: 0x07AfB905B34EF28505283a09a94603e9B40C3f31
NFTOracle: 0xed1a46EBE904dD6562f5F20A515009752Fb5bAdE
CryptoPunksMarket: 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
WrappedPunk: 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6
UnlockdProxyAdminFund: 0x38a97DE7216b54FCc83A918CF5dB1Bb0447913a4
LendPoolAddressesProvider: 0xE6cd031FB0D9A79FD8CD3035B9228F78ff459B07
LendPoolAddressesProviderRegistry: 0xe5BF48BC5Fd3FCD1c7Fc76795C7b08ccc139a949
ReserveLogic: 0x102Ca0665b83f1B01497E4afD0088FA7d645C5C1
NftLogic: 0x6dF83F6ba030C420d602E9a4302DB8f1DeEDd712
GenericLogic: 0x5520945C3261a51D8e014De4389acC51Fc926b9e
ValidationLogic: 0x8749e3e58A437ecA1B7dfA7046c99a51Cd784Def
SupplyLogic: 0xBA92072f11bbd7492f3419D1dfc85d6FFf730685
BorrowLogic: 0x25d2B642B2a485958a6A00c19f37082AbFF276Cd
LiquidateLogic: 0x91212942a1cda9342ffEF653Dc73e0130688f9F3
ConfiguratorLogic: 0x0919A0c32D7578F507760986a693D2E3D0E598a0
LendPoolImpl: 0x4216Ac4Ad3C6838889Cc80aa5E34e6F57e7839B6
LendPool: 0xFC7f036a8FB66D031675239413F9179A82932a53
LendPoolLoanImpl: 0x6FfD77E502b561E08CdE65C311bf920d9FE1dB88
LendPoolLoan: 0x00da789CEBF4A0da965FbcB9e4d72F1A15c67Eb6
LendPoolConfiguratorImpl: 0xC4576F34dfeFd15011947E787e818ad490F7df37
LendPoolConfigurator: 0x82CefdbdFe6c4A868962E7B78A3CE54f952FE209
UToken: 0x13D3f5C8FC7c05e7cc2d60690381aaB016137300
DebtToken: 0xE4Bc9E74428b5E8C4fAdB53D5eF39C9A9902909c
ReserveOracleImpl: 0x71a22E1b4D1113CF82898caf709F8F0190FBAaC2
ReserveOracle: 0x2954B6ce3E9788e2A6dE603358918f2eb067AABa
InterestRate: 0x2c8C82fBEA936860BD7b20a756E098360cBAF05B
rateStrategyWETH: 0x2c8C82fBEA936860BD7b20a756E098360cBAF05B
WETHGatewayImpl: 0xFbD2Bcee595C6dd9897d09F8aac4dE4d25Da2406
WETHGateway: 0x66CD472E4404D0C62d7068b4D69e28D5Ed6C32c2
PunkGatewayImpl: 0xf49c6c3A753643eF9a31A1cfBD1d38e364A1637c
PunkGateway: 0x2540b104310EFa795DE0a9247Ba3942b71385251
WalletBalanceProvider: 0x95F9b68e4F8dC809127B1A3437b3531197E273Ea
UnlockdProtocolDataProvider: 0x4ABde724f8d7CB5ec7b22A9b86824591bE9fDc86
UIPoolDataProvider: 0x2CF74101dF653E166Cbf699EeED6FaB599293BcD
WPUNKS: 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6
BAYC: 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
DOODLE: 0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e
AZUKI: 0xED5AF388653567Af2F388E6224dC7C4b3241C544
MockIncentivesController: 0xf40a2617170af5d8079D7a476F6475b2106328D4
UNFT: 0x1014BBC1ED63CC49e6118769D412E715A1cEbCD8
UNFTRegistryImpl: 0xC048366Bd89c48Abb763bB5d4c436b6990c241E9
UNFTRegistry: 0x255f25335662c88Fcc7deC402cADf2f4f0E08300
LiquidateMarketsLogic: 0xB7BBE03f2E0F384DA800aD3c4E29e0C3b70Da7D9 

Deployer: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 9999.764304694758308497
PoolAdmin: 0x67539d650922Af9D2c611251ac9749f167e51Ac0 Balance: 9999.764304694758308497
EmergencyAdmin: 0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d Balance: 9999.9994196610061888
LendPoolLiquidator: 0xA296478f65BCDA4153343c8D1f24D768110D6e16 Balance: 10000.0
-> Initialize make suite...
uDai undefined
uUSDC undefined
uWETH 0x302Ceac15678E3238D19a0C4714533701169C217
daiAdd undefined
usdcAdd undefined
wethAdd 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

***************
Setup and snapshot finished
***************

  PunkGateway
PUNKGATEWAY*****
cryptoPunksMarket.ADDRESS 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
2
REACHED
REACHED 2
REACHE 4D
REACHED 5
REACHED 7
    ✓ Owner can do emergency CryptoPunks recovery
cryptoPunksMarket.ADDRESS 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
2
    ✓ Should fail: not supported collection
cryptoPunksMarket.ADDRESS 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
2
    ✓ Should fail: not holder
cryptoPunksMarket.ADDRESS 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
2
    ✓ Check approve valuation on cryptopunks
    ✓ Borrow some USDC and repay it
AVAILABLE LIQUIDITY BEFORE DEPOSIT: 0
AVAILABLE LIQUIDITY AFTER DEPOSIT: 0
cryptoPunksMarket.ADDRESS 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
2

    1) Borrow some ETH and repay it
cryptoPunksMarket.ADDRESS 0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
2

    2) Borrow all ETH and repay it

·---------------------------------------------------------------|---------------------------|-------------|-----------------------------·
|                      [90mSolc version: 0.8.4[39m                      ·  [90mOptimizer enabled: true[39m  ·  [90mRuns: 200[39m  ·  [90mBlock limit: 12450000 gas[39m  │
································································|···························|·············|······························
|  [32m[1mMethods[22m[39m                                                                                                                              │
······························|·································|·············|·············|·············|···············|··············
|  [1mContract[22m                   ·  [1mMethod[22m                         ·  [32mMin[39m        ·  [32mMax[39m        ·  [32mAvg[39m        ·  [1m# calls[22m      ·  [1meur (avg)[22m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m          ·  offerPunkForSaleToAddress      ·          -  ·          -  ·     119766  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mCryptoPunksMarket[39m          ·  transferPunk                   ·      [36m43479[39m  ·      [31m65379[39m  ·      55029  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setAddress                     ·      [36m29481[39m  ·      [31m49381[39m  ·      40128  ·            [90m8[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolConfiguratorImpl    ·          -  ·          -  ·      43350  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolImpl                ·          -  ·          -  ·      43351  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setLendPoolLoanImpl            ·          -  ·          -  ·      43396  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setNFTOracle                   ·          -  ·          -  ·      27521  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setReserveOracle               ·          -  ·          -  ·      30254  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolAddressesProvider[39m  ·  setUnlockdDataProvider         ·          -  ·          -  ·      30321  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  configureNftsAsCollateral      ·          -  ·          -  ·     116851  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setLtvManagerStatus            ·      [36m39630[39m  ·      [31m59530[39m  ·      49580  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setPoolPause                   ·      [36m64309[39m  ·      [31m84052[39m  ·      70890  ·            [90m3[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  setReserveInterestRateAddress  ·          -  ·          -  ·      66225  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mLendPoolConfigurator[39m       ·  updateUToken                   ·          -  ·          -  ·      89336  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockDebtTokenVersionN[39m      ·  approveDelegation              ·      [36m36248[39m  ·      [31m56148[39m  ·      46198  ·            [90m4[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  approveValuation               ·          -  ·          -  ·      71500  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockLendPoolVersionN[39m       ·  setTimeframe                   ·          -  ·          -  ·      61022  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  initialize                     ·          -  ·          -  ·     113794  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockNFTOracle[39m              ·  setPriceManagerStatus          ·          -  ·          -  ·      33894  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  initialize                     ·          -  ·          -  ·      90917  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockReserveOracle[39m          ·  setAggregators                 ·          -  ·          -  ·     101406  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mMockUTokenVersionN[39m         ·  sweepUToken                    ·          -  ·          -  ·      49687  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  authorizeCallerWhitelist       ·      [36m62136[39m  ·      [31m80661[39m  ·      71399  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mPunkGateway[39m                ·  emergencyPunksTransfer         ·          -  ·          -  ·      73830  ·            [90m1[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [90mWETHGateway[39m                ·  depositETH                     ·          -  ·          -  ·     277826  ·            [90m2[39m  ·          [32m[90m-[32m[39m  │
······························|·································|·············|·············|·············|···············|··············
|  [32m[1mDeployments[22m[39m                                                  ·                                         ·  [1m% of limit[22m   ·             │
································································|·············|·············|·············|···············|··············
|  BorrowLogic                                                  ·          -  ·          -  ·    2117672  ·         [90m17 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ConfiguratorLogic                                            ·          -  ·          -  ·    1970106  ·       [90m15.8 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  GenericLogic                                                 ·          -  ·          -  ·      84290  ·        [90m0.7 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  InterestRate                                                 ·          -  ·          -  ·     613848  ·        [90m4.9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendingLogic                                                 ·          -  ·          -  ·      72217  ·        [90m0.6 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendPool                                                     ·          -  ·          -  ·    5269514  ·       [90m42.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendPoolConfigurator                                         ·          -  ·          -  ·    5230541  ·         [90m42 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LendPoolLoan                                                 ·          -  ·          -  ·    3272699  ·       [90m26.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LiquidateLogic                                               ·          -  ·          -  ·    3977175  ·       [90m31.9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  LiquidateMarketsLogic                                        ·          -  ·          -  ·    3025524  ·       [90m24.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MockChainlinkOracle                                          ·          -  ·          -  ·     620122  ·          [90m5 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MockNFTOracle                                                ·          -  ·          -  ·    1117453  ·          [90m9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  MockReserveOracle                                            ·          -  ·          -  ·    1280668  ·       [90m10.3 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  NftLogic                                                     ·          -  ·          -  ·     141022  ·        [90m1.1 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ReserveLogic                                                 ·          -  ·          -  ·     171208  ·        [90m1.4 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ReserveOracle                                                ·          -  ·          -  ·    1211618  ·        [90m9.7 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  SupplyLogic                                                  ·          -  ·          -  ·    1235281  ·        [90m9.9 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  UnlockdProtocolDataProvider                                  ·          -  ·          -  ·    2891625  ·       [90m23.2 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  UnlockdUpgradeableProxy                                      ·          -  ·          -  ·     689038  ·        [90m5.5 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  UToken                                                       ·          -  ·          -  ·    2710730  ·       [90m21.8 %[39m  ·          [32m[90m-[32m[39m  │
································································|·············|·············|·············|···············|··············
|  ValidationLogic                                              ·          -  ·          -  ·    1573518  ·       [90m12.6 %[39m  ·          [32m[90m-[32m[39m  │
·---------------------------------------------------------------|-------------|-------------|-------------|---------------|-------------·

  5 passing (3m)
  2 failing

  1) PunkGateway
       Borrow some ETH and repay it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '424'", method="estimateGas", transaction={"from":"0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d","to":"0x2540b104310EFa795DE0a9247Ba3942b71385251","data":"0xd0554fc60000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000068000000000000000000000000653f5769e08fb9cd6c4fac48bad8a1b64b7cf85d0000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrowETH","contract":"PunkGateway","sourceName":"contracts/protocol/PunkGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IPunks} from \"../interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../interfaces/IWrappedPunks.sol\";\nimport {IPunkGateway} from \"../interfaces/IPunkGateway.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract PunkGateway is IPunkGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  IWETHGateway internal _wethGateway;\n\n  IPunks public punks;\n  IWrappedPunks public wrappedPunks;\n  address public proxy;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the PunkGateway contract is added to the\n   * LendPoolAddressesProvider of the market.\n   **/\n  function initialize(\n    address addressProvider,\n    address wethGateway,\n    address _punks,\n    address _wrappedPunks\n  ) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n    _wethGateway = IWETHGateway(wethGateway);\n\n    punks = IPunks(_punks);\n    wrappedPunks = IWrappedPunks(_wrappedPunks);\n    wrappedPunks.registerProxy();\n    proxy = wrappedPunks.proxyInfo(address(this));\n\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_getLendPool()), true);\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_wethGateway), true);\n  }\n\n  /**\n   * @notice Returns the LendPool address\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice Returns the LendPoolLoan address\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @notice Approves the lendpool for given tokens\n   * @param tokens the array of tokens\n   **/\n  function authorizeLendPoolERC20(address[] calldata tokens) external nonReentrant onlyOwner {\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ) {\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), 0);\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), type(uint256).max);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Authorizes/unauthorizes an array of callers to the whitelist\n   * @param callers the array of callers\n   * @param callers the authorization status\n   **/\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callersLength = callers.length;\n    for (uint256 i = 0; i < callersLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if caller is whitelisted\n   * @param caller caller address\n   **/\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @notice Checks the onBehalfOf address is valid for a given callet\n   * @param onBehalfOf the allowed address\n   **/\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @notice Deposits a punk given its index\n   * - E.g. User deposit NFT Punk and receives the wrapped asset\n   * @param punkIndex The index of the CryptoPunk to deposit\n   **/\n  function _depositPunk(uint256 punkIndex) internal {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    if (loanId != 0) {\n      return;\n    }\n\n    address owner = punks.punkIndexToAddress(punkIndex);\n\n    require(owner == _msgSender(), \"PunkGateway: not owner of punkIndex\");\n\n    punks.buyPunk(punkIndex);\n\n    punks.transferPunk(proxy, punkIndex);\n\n    wrappedPunks.mint(punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrow(\n    address reserveAsset,\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    _depositPunk(punkIndex);\n\n    cachedPool.borrow(reserveAsset, amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n\n    IERC20Upgradeable(reserveAsset).transfer(onBehalfOf, amount);\n  }\n\n  function _withdrawPunk(uint256 punkIndex, address onBehalfOf) internal {\n    address owner = wrappedPunks.ownerOf(punkIndex);\n    require(owner == _msgSender(), \"PunkGateway: caller is not owner\");\n    require(owner == onBehalfOf, \"PunkGateway: onBehalfOf is not owner\");\n\n    wrappedPunks.safeTransferFrom(onBehalfOf, address(this), punkIndex);\n    wrappedPunks.burn(punkIndex);\n    punks.transferPunk(onBehalfOf, punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repay(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256, bool) {\n    return _repay(punkIndex, amount);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk used as collateral\n   * @param amount The amount to repay\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repay(uint256 punkIndex, uint256 amount) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n    (, uint256 debt) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n\n    if (amount > debt) {\n      amount = debt;\n    }\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), amount);\n\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(address(wrappedPunks), punkIndex, amount);\n\n    if (burn) {\n      require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auction(uint256 punkIndex, uint256 bidPrice, address onBehalfOf) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), bidPrice);\n\n    cachedPool.auction(address(wrappedPunks), punkIndex, bidPrice, onBehalfOf);\n  }\n\n  function redeem(uint256 punkIndex, uint256 amount, uint256 bidFine) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), (amount + bidFine));\n\n    uint256 paybackAmount = cachedPool.redeem(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    if ((amount + bidFine) > paybackAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, ((amount + bidFine) - paybackAmount));\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidate(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    if (amount > 0) {\n      IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), amount);\n    }\n\n    uint256 extraRetAmount = cachedPool.liquidate(address(wrappedPunks), punkIndex, amount);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    if (amount > extraRetAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, (amount - extraRetAmount));\n    }\n\n    return (extraRetAmount);\n  }\n\n  /**\n   * @notice Liquidate punk in NFTX\n   * @param punkIndex The index of the CryptoPunk to liquidate\n   **/\n  function liquidateNFTX(uint256 punkIndex, uint256 amountOutMin) external override nonReentrant returns (uint256) {\n    require(_addressProvider.getLendPoolLiquidator() == _msgSender(), Errors.CALLER_NOT_POOL_LIQUIDATOR);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    uint256 remainAmount = cachedPool.liquidateNFTX(address(wrappedPunks), punkIndex, amountOutMin);\n\n    return (remainAmount);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _depositPunk(punkIndex);\n    _wethGateway.borrowETH(amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repayETH(uint256 punkIndex, uint256 amount) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 paybackAmount, bool burn) = _repayETH(punkIndex, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk with native ETH\n   * - E.g. User repays 100 ETH, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk to repay\n   * @param amount The amount to repay\n   * @param accAmount The accumulated amount\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repayETH(uint256 punkIndex, uint256 amount, uint256 accAmount) internal returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n    require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    (uint256 paybackAmount, bool burn) = _wethGateway.repayETH{value: repayDebtAmount}(\n      address(wrappedPunks),\n      punkIndex,\n      amount\n    );\n\n    if (burn) {\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(uint256 punkIndex, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _wethGateway.auctionETH{value: msg.value}(address(wrappedPunks), punkIndex, onBehalfOf);\n  }\n\n  function redeemETH(\n    uint256 punkIndex,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    //DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    uint256 paybackAmount = _wethGateway.redeemETH{value: msg.value}(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(uint256 punkIndex) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    uint256 extraAmount = _wethGateway.liquidateETH{value: msg.value}(address(wrappedPunks), punkIndex);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    // refund remaining dust eth\n    if (msg.value > extraAmount) {\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return extraAmount;\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":335,"range":[11934,12024]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrowETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n  \n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    (address reserveAsset, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    require(reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(address nftAsset, uint256 nftTokenId, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(address nftAsset, uint256 nftTokenId) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":183,"range":[6059,6147]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrow","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":244,"range":[10121,10480]},"functionType":1},{"type":0,"sourceReference":{"function":"executeBorrow","contract":"BorrowLogic","sourceName":"contracts/libraries/logic/BorrowLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Unlockd\n * @notice Implements the logic to borrow feature\n */\nlibrary BorrowLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on borrow() when loan needs to be opened\n   * @param user The address of the user initiating the borrow(), receiving the funds\n   * @param reserve The address of the underlying asset being borrowed\n   * @param amount The amount borrowed out\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the loan\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address indexed onBehalfOf,\n    uint256 borrowRate,\n    uint256 loanId,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param user The address of the user initiating the repay(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param amount The amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Repay(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct ExecuteBorrowLocalVars {\n    address initiator;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 loanId;\n    address reserveOracle;\n    address nftOracle;\n    address loanAddress;\n    uint256 totalSupply;\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) external {\n    _borrow(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `_borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function _borrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) internal {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    ExecuteBorrowLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n    // Convert asset amount to ETH\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    vars.totalSupply = IERC721EnumerableUpgradeable(params.nftAsset).totalSupply();\n    require(vars.totalSupply <= nftData.maxSupply, Errors.LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT);\n    require(params.nftTokenId <= nftData.maxTokenId, Errors.LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT);\n    ValidationLogic.validateBorrow(\n      params,\n      reserveData,\n      nftData,\n      nftConfig,\n      vars.loanAddress,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    require(IUToken(uToken).getAvailableLiquidity() >= params.amount, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n\n    if (vars.loanId == 0) {\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\n\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\n        vars.initiator,\n        params.onBehalfOf,\n        params.nftAsset,\n        params.nftTokenId,\n        nftData.uNftAddress,\n        params.asset,\n        params.amount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.loanAddress).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        params.amount,\n        0,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.initiator,\n      params.onBehalfOf,\n      params.amount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(params.asset, uToken, 0, params.amount);\n\n    // Withdraw amount from external lending protocol\n    uint256 value = IUToken(uToken).withdrawReserves(params.amount);\n\n    // Transfer underlying to user\n    IUToken(uToken).transferUnderlyingTo(vars.initiator, value);\n\n    emit Borrow(\n      vars.initiator,\n      params.asset,\n      value,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      reserveData.currentVariableBorrowRate,\n      vars.loanId,\n      params.referralCode\n    );\n  }\n\n  struct RepayLocalVars {\n    address initiator;\n    address poolLoan;\n    address onBehalfOf;\n    uint256 loanId;\n    bool isUpdate;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function executeRepay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256, bool) {\n    return _repay(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function _repay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) internal returns (uint256, bool) {\n    RepayLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\n\n    ValidationLogic.validateRepay(reserveData, nftData, nftConfig, loanData, params.amount, vars.borrowAmount);\n\n    vars.repayAmount = vars.borrowAmount;\n    vars.isUpdate = false;\n    if (params.amount < vars.repayAmount) {\n      vars.isUpdate = true;\n      vars.repayAmount = params.amount;\n    }\n\n    if (vars.isUpdate) {\n      ILendPoolLoan(vars.poolLoan).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        0,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.poolLoan).repayLoan(\n        vars.initiator,\n        vars.loanId,\n        nftData.uNftAddress,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount repaid to external lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    // transfer erc721 to borrower\n    if (!vars.isUpdate) {\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\n    }\n\n    emit Repay(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount, !vars.isUpdate);\n  }\n}\n","line":108,"range":[4269,4339]},"functionType":1},{"type":4,"sourceReference":{"function":"_repay","contract":"BorrowLogic","sourceName":"contracts/libraries/logic/BorrowLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Unlockd\n * @notice Implements the logic to borrow feature\n */\nlibrary BorrowLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on borrow() when loan needs to be opened\n   * @param user The address of the user initiating the borrow(), receiving the funds\n   * @param reserve The address of the underlying asset being borrowed\n   * @param amount The amount borrowed out\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the loan\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address indexed onBehalfOf,\n    uint256 borrowRate,\n    uint256 loanId,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param user The address of the user initiating the repay(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param amount The amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Repay(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct ExecuteBorrowLocalVars {\n    address initiator;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 loanId;\n    address reserveOracle;\n    address nftOracle;\n    address loanAddress;\n    uint256 totalSupply;\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) external {\n    _borrow(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `_borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function _borrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) internal {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    ExecuteBorrowLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n    // Convert asset amount to ETH\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    vars.totalSupply = IERC721EnumerableUpgradeable(params.nftAsset).totalSupply();\n    require(vars.totalSupply <= nftData.maxSupply, Errors.LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT);\n    require(params.nftTokenId <= nftData.maxTokenId, Errors.LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT);\n    ValidationLogic.validateBorrow(\n      params,\n      reserveData,\n      nftData,\n      nftConfig,\n      vars.loanAddress,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    require(IUToken(uToken).getAvailableLiquidity() >= params.amount, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n\n    if (vars.loanId == 0) {\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\n\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\n        vars.initiator,\n        params.onBehalfOf,\n        params.nftAsset,\n        params.nftTokenId,\n        nftData.uNftAddress,\n        params.asset,\n        params.amount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.loanAddress).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        params.amount,\n        0,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.initiator,\n      params.onBehalfOf,\n      params.amount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(params.asset, uToken, 0, params.amount);\n\n    // Withdraw amount from external lending protocol\n    uint256 value = IUToken(uToken).withdrawReserves(params.amount);\n\n    // Transfer underlying to user\n    IUToken(uToken).transferUnderlyingTo(vars.initiator, value);\n\n    emit Borrow(\n      vars.initiator,\n      params.asset,\n      value,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      reserveData.currentVariableBorrowRate,\n      vars.loanId,\n      params.referralCode\n    );\n  }\n\n  struct RepayLocalVars {\n    address initiator;\n    address poolLoan;\n    address onBehalfOf;\n    uint256 loanId;\n    bool isUpdate;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function executeRepay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256, bool) {\n    return _repay(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function _repay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) internal returns (uint256, bool) {\n    RepayLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\n\n    ValidationLogic.validateRepay(reserveData, nftData, nftConfig, loanData, params.amount, vars.borrowAmount);\n\n    vars.repayAmount = vars.borrowAmount;\n    vars.isUpdate = false;\n    if (params.amount < vars.repayAmount) {\n      vars.isUpdate = true;\n      vars.repayAmount = params.amount;\n    }\n\n    if (vars.isUpdate) {\n      ILendPoolLoan(vars.poolLoan).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        0,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.poolLoan).repayLoan(\n        vars.initiator,\n        vars.loanId,\n        nftData.uNftAddress,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount repaid to external lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    // transfer erc721 to borrower\n    if (!vars.isUpdate) {\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\n    }\n\n    emit Repay(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount, !vars.isUpdate);\n  }\n}\n","line":260,"range":[9927,9993]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,52,50,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033432340000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  2) PunkGateway
       Borrow all ETH and repay it:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string '301'", method="estimateGas", transaction={"from":"0x653f5769e08FB9cd6c4faC48Bad8a1B64B7Cf85d","to":"0x2540b104310EFa795DE0a9247Ba3942b71385251","data":"0xd0554fc600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000069000000000000000000000000653f5769e08fb9cd6c4fac48bad8a1b64b7cf85d0000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrowETH","contract":"PunkGateway","sourceName":"contracts/protocol/PunkGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IPunks} from \"../interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../interfaces/IWrappedPunks.sol\";\nimport {IPunkGateway} from \"../interfaces/IPunkGateway.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract PunkGateway is IPunkGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  ILendPoolAddressesProvider internal _addressProvider;\n  IWETHGateway internal _wethGateway;\n\n  IPunks public punks;\n  IWrappedPunks public wrappedPunks;\n  address public proxy;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the PunkGateway contract is added to the\n   * LendPoolAddressesProvider of the market.\n   **/\n  function initialize(\n    address addressProvider,\n    address wethGateway,\n    address _punks,\n    address _wrappedPunks\n  ) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n    _wethGateway = IWETHGateway(wethGateway);\n\n    punks = IPunks(_punks);\n    wrappedPunks = IWrappedPunks(_wrappedPunks);\n    wrappedPunks.registerProxy();\n    proxy = wrappedPunks.proxyInfo(address(this));\n\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_getLendPool()), true);\n    IERC721Upgradeable(address(wrappedPunks)).setApprovalForAll(address(_wethGateway), true);\n  }\n\n  /**\n   * @notice Returns the LendPool address\n   **/\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice Returns the LendPoolLoan address\n   **/\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @notice Approves the lendpool for given tokens\n   * @param tokens the array of tokens\n   **/\n  function authorizeLendPoolERC20(address[] calldata tokens) external nonReentrant onlyOwner {\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ) {\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), 0);\n      IERC20Upgradeable(tokens[i]).approve(address(_getLendPool()), type(uint256).max);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Authorizes/unauthorizes an array of callers to the whitelist\n   * @param callers the array of callers\n   * @param callers the authorization status\n   **/\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callersLength = callers.length;\n    for (uint256 i = 0; i < callersLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if caller is whitelisted\n   * @param caller caller address\n   **/\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @notice Checks the onBehalfOf address is valid for a given callet\n   * @param onBehalfOf the allowed address\n   **/\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @notice Deposits a punk given its index\n   * - E.g. User deposit NFT Punk and receives the wrapped asset\n   * @param punkIndex The index of the CryptoPunk to deposit\n   **/\n  function _depositPunk(uint256 punkIndex) internal {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    if (loanId != 0) {\n      return;\n    }\n\n    address owner = punks.punkIndexToAddress(punkIndex);\n\n    require(owner == _msgSender(), \"PunkGateway: not owner of punkIndex\");\n\n    punks.buyPunk(punkIndex);\n\n    punks.transferPunk(proxy, punkIndex);\n\n    wrappedPunks.mint(punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrow(\n    address reserveAsset,\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    _depositPunk(punkIndex);\n\n    cachedPool.borrow(reserveAsset, amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n\n    IERC20Upgradeable(reserveAsset).transfer(onBehalfOf, amount);\n  }\n\n  function _withdrawPunk(uint256 punkIndex, address onBehalfOf) internal {\n    address owner = wrappedPunks.ownerOf(punkIndex);\n    require(owner == _msgSender(), \"PunkGateway: caller is not owner\");\n    require(owner == onBehalfOf, \"PunkGateway: onBehalfOf is not owner\");\n\n    wrappedPunks.safeTransferFrom(onBehalfOf, address(this), punkIndex);\n    wrappedPunks.burn(punkIndex);\n    punks.transferPunk(onBehalfOf, punkIndex);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repay(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256, bool) {\n    return _repay(punkIndex, amount);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk used as collateral\n   * @param amount The amount to repay\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repay(uint256 punkIndex, uint256 amount) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n    (, uint256 debt) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n\n    if (amount > debt) {\n      amount = debt;\n    }\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), amount);\n\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(address(wrappedPunks), punkIndex, amount);\n\n    if (burn) {\n      require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auction(uint256 punkIndex, uint256 bidPrice, address onBehalfOf) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    (, , address reserve, ) = cachedPoolLoan.getLoanCollateralAndReserve(loanId);\n\n    IERC20Upgradeable(reserve).transferFrom(msg.sender, address(this), bidPrice);\n\n    cachedPool.auction(address(wrappedPunks), punkIndex, bidPrice, onBehalfOf);\n  }\n\n  function redeem(uint256 punkIndex, uint256 amount, uint256 bidFine) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), (amount + bidFine));\n\n    uint256 paybackAmount = cachedPool.redeem(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    if ((amount + bidFine) > paybackAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, ((amount + bidFine) - paybackAmount));\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidate(uint256 punkIndex, uint256 amount) external override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    if (amount > 0) {\n      IERC20Upgradeable(loan.reserveAsset).transferFrom(msg.sender, address(this), amount);\n    }\n\n    uint256 extraRetAmount = cachedPool.liquidate(address(wrappedPunks), punkIndex, amount);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    if (amount > extraRetAmount) {\n      IERC20Upgradeable(loan.reserveAsset).safeTransfer(msg.sender, (amount - extraRetAmount));\n    }\n\n    return (extraRetAmount);\n  }\n\n  /**\n   * @notice Liquidate punk in NFTX\n   * @param punkIndex The index of the CryptoPunk to liquidate\n   **/\n  function liquidateNFTX(uint256 punkIndex, uint256 amountOutMin) external override nonReentrant returns (uint256) {\n    require(_addressProvider.getLendPoolLiquidator() == _msgSender(), Errors.CALLER_NOT_POOL_LIQUIDATOR);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    uint256 remainAmount = cachedPool.liquidateNFTX(address(wrappedPunks), punkIndex, amountOutMin);\n\n    return (remainAmount);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    uint256 punkIndex,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _depositPunk(punkIndex);\n    _wethGateway.borrowETH(amount, address(wrappedPunks), punkIndex, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IPunkGateway\n   */\n  function repayETH(uint256 punkIndex, uint256 amount) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 paybackAmount, bool burn) = _repayETH(punkIndex, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific punk with native ETH\n   * - E.g. User repays 100 ETH, burning loan and receives collateral asset\n   * @param punkIndex The index of the CryptoPunk to repay\n   * @param amount The amount to repay\n   * @param accAmount The accumulated amount\n   * @return The final amount repaid, loan is burned or not\n   **/\n  function _repayETH(uint256 punkIndex, uint256 amount, uint256 accAmount) internal returns (uint256, bool) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    address borrower = cachedPoolLoan.borrowerOf(loanId);\n    require(borrower == _msgSender(), \"PunkGateway: caller is not borrower\");\n\n    (, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    (uint256 paybackAmount, bool burn) = _wethGateway.repayETH{value: repayDebtAmount}(\n      address(wrappedPunks),\n      punkIndex,\n      amount\n    );\n\n    if (burn) {\n      _withdrawPunk(punkIndex, borrower);\n    }\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(uint256 punkIndex, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    _wethGateway.auctionETH{value: msg.value}(address(wrappedPunks), punkIndex, onBehalfOf);\n  }\n\n  function redeemETH(\n    uint256 punkIndex,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    //DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n\n    uint256 paybackAmount = _wethGateway.redeemETH{value: msg.value}(address(wrappedPunks), punkIndex, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(uint256 punkIndex) external payable override nonReentrant returns (uint256) {\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(address(wrappedPunks), punkIndex);\n    require(loanId != 0, \"PunkGateway: no loan with such punkIndex\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.bidderAddress == _msgSender(), \"PunkGateway: caller is not bidder\");\n\n    uint256 extraAmount = _wethGateway.liquidateETH{value: msg.value}(address(wrappedPunks), punkIndex);\n\n    _withdrawPunk(punkIndex, loan.bidderAddress);\n\n    // refund remaining dust eth\n    if (msg.value > extraAmount) {\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return extraAmount;\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":335,"range":[11934,12024]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrowETH","contract":"WETHGateway","sourceName":"contracts/protocol/WETHGateway.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\nimport {EmergencyTokenRecoveryUpgradeable} from \"./EmergencyTokenRecoveryUpgradeable.sol\";\n\ncontract WETHGateway is IWETHGateway, ERC721HolderUpgradeable, EmergencyTokenRecoveryUpgradeable {\n  ILendPoolAddressesProvider internal _addressProvider;\n\n  IWETH internal WETH;\n\n  mapping(address => bool) internal _callerWhitelists;\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n  uint256 private _status;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Sets the WETH address and the LendPoolAddressesProvider address. Infinite approves lend pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  function initialize(address addressProvider, address weth) public initializer {\n    __ERC721Holder_init();\n    __EmergencyTokenRecovery_init();\n\n    _addressProvider = ILendPoolAddressesProvider(addressProvider);\n\n    WETH = IWETH(weth);\n\n    WETH.approve(address(_getLendPool()), type(uint256).max);\n  }\n\n  /**\n   * @notice returns the LendPool address\n   */\n  function _getLendPool() internal view returns (ILendPool) {\n    return ILendPool(_addressProvider.getLendPool());\n  }\n\n  /**\n   * @notice returns the LendPoolLoan address\n   */\n  function _getLendPoolLoan() internal view returns (ILendPoolLoan) {\n    return ILendPoolLoan(_addressProvider.getLendPoolLoan());\n  }\n\n  /**\n   * @dev approves the lendpool for the given NFT assets\n   * @param nftAssets the array of nft assets\n   */\n  function authorizeLendPoolNFT(address[] calldata nftAssets) external nonReentrant onlyOwner {\n    uint256 nftAssetsLength = nftAssets.length;\n    for (uint256 i = 0; i < nftAssetsLength; ) {\n      IERC721Upgradeable(nftAssets[i]).setApprovalForAll(address(_getLendPool()), true);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev authorizes/unauthorizes a list of callers for the whitelist\n   * @param callers the array of callers to be authorized\n   * @param flag the flag to authorize/unauthorize\n   */\n  function authorizeCallerWhitelist(address[] calldata callers, bool flag) external nonReentrant onlyOwner {\n    uint256 callerLength = callers.length;\n    for (uint256 i = 0; i < callerLength; ) {\n      _callerWhitelists[callers[i]] = flag;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev checks if caller is whitelisted\n   * @param caller the caller to check\n   */\n  function isCallerInWhitelist(address caller) external view returns (bool) {\n    return _callerWhitelists[caller];\n  }\n\n  /**\n   * @dev checks if caller's approved address is valid\n   * @param onBehalfOf the address to check approval of the caller\n   */\n  function _checkValidCallerAndOnBehalfOf(address onBehalfOf) internal view {\n    require(\n      (onBehalfOf == _msgSender()) || (_callerWhitelists[_msgSender()] == true),\n      Errors.CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST\n    );\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function depositETH(address onBehalfOf, uint16 referralCode) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function withdrawETH(uint256 amount, address to) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(to);\n\n    ILendPool cachedPool = _getLendPool();\n    IUToken uWETH = IUToken(cachedPool.getReserveData(address(WETH)).uTokenAddress);\n\n    uint256 userBalance = uWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    uWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    cachedPool.withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function borrowETH(\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      IERC721Upgradeable(nftAsset).safeTransferFrom(msg.sender, address(this), nftTokenId);\n    }\n    cachedPool.borrow(address(WETH), amount, nftAsset, nftTokenId, onBehalfOf, referralCode);\n    WETH.withdraw(amount);\n    _safeTransferETH(onBehalfOf, amount);\n  }\n\n  /**\n   * @inheritdoc IWETHGateway\n   */\n  function repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external payable override nonReentrant returns (uint256, bool) {\n    (uint256 repayAmount, bool repayAll) = _repayETH(nftAsset, nftTokenId, amount, 0);\n\n    // refund remaining dust eth\n    if (msg.value > repayAmount) {\n      _safeTransferETH(msg.sender, msg.value - repayAmount);\n    }\n\n    return (repayAmount, repayAll);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param accAmount the accumulated amount\n  \n   */\n  function _repayETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 accAmount\n  ) internal returns (uint256, bool) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    (address reserveAsset, uint256 repayDebtAmount) = cachedPoolLoan.getLoanReserveBorrowAmount(loanId);\n    require(reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (amount < repayDebtAmount) {\n      repayDebtAmount = amount;\n    }\n\n    require(msg.value >= (accAmount + repayDebtAmount), \"msg.value is less than repay amount\");\n\n    WETH.deposit{value: repayDebtAmount}();\n    (uint256 paybackAmount, bool burn) = cachedPool.repay(nftAsset, nftTokenId, amount);\n\n    return (paybackAmount, burn);\n  }\n\n  function auctionETH(address nftAsset, uint256 nftTokenId, address onBehalfOf) external payable override nonReentrant {\n    _checkValidCallerAndOnBehalfOf(onBehalfOf);\n\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    WETH.deposit{value: msg.value}();\n    cachedPool.auction(nftAsset, nftTokenId, msg.value, onBehalfOf);\n  }\n\n  function redeemETH(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    require(msg.value >= (amount + bidFine), \"msg.value is less than redeem amount\");\n\n    WETH.deposit{value: msg.value}();\n\n    uint256 paybackAmount = cachedPool.redeem(nftAsset, nftTokenId, amount, bidFine);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) {\n      WETH.withdraw(msg.value - paybackAmount);\n      _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    return paybackAmount;\n  }\n\n  function liquidateETH(address nftAsset, uint256 nftTokenId) external payable override nonReentrant returns (uint256) {\n    ILendPool cachedPool = _getLendPool();\n    ILendPoolLoan cachedPoolLoan = _getLendPoolLoan();\n\n    uint256 loanId = cachedPoolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    require(loanId > 0, \"collateral loan id not exist\");\n\n    DataTypes.LoanData memory loan = cachedPoolLoan.getLoan(loanId);\n    require(loan.reserveAsset == address(WETH), \"loan reserve not WETH\");\n\n    if (msg.value > 0) {\n      WETH.deposit{value: msg.value}();\n    }\n\n    uint256 extraAmount = cachedPool.liquidate(nftAsset, nftTokenId, msg.value);\n\n    if (msg.value > extraAmount) {\n      WETH.withdraw(msg.value - extraAmount);\n      _safeTransferETH(msg.sender, msg.value - extraAmount);\n    }\n\n    return (extraAmount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), \"Receive not allowed\");\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert(\"Fallback not allowed\");\n  }\n}\n","line":183,"range":[6059,6147]},"functionType":1},{"type":0,"sourceReference":{"function":"_upgradeToAndCall","contract":"UnlockdUpgradeableProxy","sourceName":"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol","sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","line":70,"range":[2303,2314]},"functionType":1},{"type":0,"sourceReference":{"function":"borrow","contract":"LendPool","sourceName":"contracts/protocol/LendPool.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ILendPoolLoan} from \"../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../interfaces/ILendPool.sol\";\nimport {ILendPoolAddressesProvider} from \"../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {ICryptoPunksMarket} from \"../interfaces/ICryptoPunksMarket.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {NftLogic} from \"../libraries/logic/NftLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidateLogic} from \"../libraries/logic/LiquidateLogic.sol\";\nimport {LiquidateMarketsLogic} from \"../libraries/logic/LiquidateMarketsLogic.sol\";\n\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../libraries/configuration/NftConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendPoolStorage} from \"./LendPoolStorage.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @title LendPool contract\n * @dev Main point of interaction with an Unlockd protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Auction\n *   # Liquidate\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\n *   LendPoolAddressesProvider\n * @author Unlockd\n **/\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\ncontract LendPool is Initializable, ILendPool, ContextUpgradeable, IERC721ReceiverUpgradeable, LendPoolStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using NftLogic for DataTypes.NftData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  bytes32 public constant ADDRESS_ID_WETH_GATEWAY = keccak256(\"WETH_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNK_GATEWAY = keccak256(\"PUNK_GATEWAY\");\n  bytes32 public constant ADDRESS_ID_PUNKS = keccak256(\"PUNKS\");\n  bytes32 public constant ADDRESS_ID_WPUNKS = keccak256(\"WPUNKS\");\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendPoolConfigurator() {\n    _onlyLendPoolConfigurator();\n    _;\n  }\n\n  modifier onlyLendPoolLiquidatorOrGateway() {\n    _onlyLendPoolLiquidatorOrGateway();\n    _;\n  }\n\n  modifier onlyPoolAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @notice Revert if called by any account other than the rescuer.\n   */\n  modifier onlyRescuer() {\n    require(_msgSender() == _rescuer, \"Rescuable: caller is not the rescuer\");\n    _;\n  }\n\n  modifier onlyHolder(address nftAsset, uint256 nftTokenId) {\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      require(\n        _msgSender() == ICryptoPunksMarket(nftAsset).punkIndexToAddress(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    } else {\n      require(\n        _msgSender() == IERC721Upgradeable(nftAsset).ownerOf(nftTokenId) ||\n          _msgSender() == IERC721Upgradeable(_nfts[nftAsset].uNftAddress).ownerOf(nftTokenId),\n        Errors.LP_CALLER_NOT_NFT_HOLDER\n      );\n    }\n    _;\n  }\n\n  modifier onlyCollection(address nftAsset) {\n    DataTypes.NftData memory data = _nfts[nftAsset];\n    if (nftAsset == _addressesProvider.getAddress(ADDRESS_ID_PUNKS)) {\n      data = _nfts[_addressesProvider.getAddress(ADDRESS_ID_WPUNKS)];\n    }\n    require(data.uNftAddress != address(0), Errors.LP_COLLECTION_NOT_SUPPORTED);\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendPoolConfigurator() internal view {\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\n  }\n\n  function _onlyLendPoolLiquidatorOrGateway() internal view {\n    require(\n      _addressesProvider.getLendPoolLiquidator() == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_WETH_GATEWAY) == _msgSender() ||\n        _addressesProvider.getAddress(ADDRESS_ID_PUNK_GATEWAY) == _msgSender(),\n      Errors.LP_CALLER_NOT_LEND_POOL_LIQUIDATOR_NOR_GATEWAY\n    );\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\n   * LendPoolAddressesProvider of the market.\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendPoolAddressesProvider\n   **/\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\n    require(address(provider) != address(0), Errors.INVALID_ZERO_ADDRESS);\n\n    _maxNumberOfReserves = 32;\n    _maxNumberOfNfts = 255;\n    _liquidateFeePercentage = 250;\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying uTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 uusdc\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the uTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of uTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    SupplyLogic.executeDeposit(\n      _reserves,\n      DataTypes.ExecuteDepositParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent uTokens owned\n   * E.g. User has 100 uusdc, calls withdraw() and receives 100 USDC, burning the 100 uusdc\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole uToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to})\n      );\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\n   *   and lock collateral asset in contract\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param nftAsset The address of the underlying nft used as collateral\n   * @param nftTokenId The token ID of the underlying nft used as collateral\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   * 0 if the action is executed directly by the user, without any middle-man\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override nonReentrant whenNotPaused {\n    BorrowLogic.executeBorrow(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      DataTypes.ExecuteBorrowParams({\n        initiator: _msgSender(),\n        asset: asset,\n        amount: amount,\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay\n   **/\n  function repay(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\n    return\n      BorrowLogic.executeRepay(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteRepayParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to auction a non-healthy position collateral-wise\n   * - The bidder want to buy collateral asset of the user getting liquidated\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\n   *   is a different wallet\n   **/\n  function auction(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 bidPrice,\n    address onBehalfOf\n  ) external override nonReentrant whenNotPaused {\n    LiquidateLogic.executeAuction(\n      _addressesProvider,\n      _reserves,\n      _nfts,\n      _nftConfig,\n      _isMarketSupported,\n      _sudoswapPairs,\n      _buildLendPoolVars(),\n      DataTypes.ExecuteAuctionParams({\n        initiator: _msgSender(),\n        nftAsset: nftAsset,\n        nftTokenId: nftTokenId,\n        bidPrice: bidPrice,\n        onBehalfOf: onBehalfOf,\n        auctionDurationConfigFee: _auctionDurationConfigFee\n      })\n    );\n  }\n\n  /**\n   * @notice Redeem a NFT loan which state is in Auction\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   * @param amount The amount to repay the debt\n   * @param bidFine The amount of bid fine\n   **/\n  function redeem(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount,\n    uint256 bidFine\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeRedeem(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteRedeemParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount,\n          bidFine: bidFine,\n          safeHealthFactor: _safeHealthFactor\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\n   *   the collateral asset\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidate(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return\n      LiquidateLogic.executeLiquidate(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        _buildLendPoolVars(),\n        DataTypes.ExecuteLiquidateParams({\n          initiator: _msgSender(),\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          amount: amount\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on NFTX\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateNFTX(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateNFTX(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        })\n      );\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise\n   * - The collateral asset is sold on SudoSwap\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\n   **/\n  function liquidateSudoSwap(\n    address nftAsset,\n    uint256 nftTokenId,\n    uint256 amountOutMin,\n    address LSSVMPair,\n    uint256 amountOutMinSudoswap\n  ) external override nonReentrant onlyLendPoolLiquidatorOrGateway whenNotPaused returns (uint256) {\n    return\n      LiquidateMarketsLogic.executeLiquidateSudoSwap(\n        _addressesProvider,\n        _reserves,\n        _nfts,\n        _nftConfig,\n        DataTypes.ExecuteLiquidateMarketsParams({\n          nftAsset: nftAsset,\n          nftTokenId: nftTokenId,\n          liquidateFeePercentage: _liquidateFeePercentage,\n          amountOutMin: amountOutMin\n        }),\n        DataTypes.SudoSwapParams({LSSVMPair: LSSVMPair, amountOutMinSudoswap: amountOutMinSudoswap})\n      );\n  }\n\n  function approveValuation(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external payable override onlyHolder(nftAsset, nftTokenId) onlyCollection(nftAsset) whenNotPaused {\n    require(_configFee == msg.value, Errors.LP_MSG_VALUE_DIFFERENT_FROM_CONFIG_FEE);\n\n    emit ValuationApproved(_msgSender(), nftAsset, nftTokenId);\n  }\n\n  function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getReserveConfiguration(\n    address asset\n  ) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the NFT\n   * @param asset The address of the asset of the NFT\n   * @return The configuration of the NFT\n   **/\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nfts[asset].configuration;\n  }\n\n  function getNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][nftTokenId];\n  }\n\n  /**\n   * @dev Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param asset The address of the underlying asset of the nft\n   * @return The state of the nft\n   **/\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\n    return _nfts[asset];\n  }\n\n  /**\n   * @dev Returns the configuration of the nft asset\n   * @param asset The address of the underlying asset of the nft\n   * @param tokenId NFT asset ID\n   * @return The configuration of the nft asset\n   **/\n  function getNftAssetConfig(\n    address asset,\n    uint256 tokenId\n  ) external view override returns (DataTypes.NftConfigurationMap memory) {\n    return _nftConfig[asset][tokenId];\n  }\n\n  /**\n   * @dev Returns the loan data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param reserveAsset The address of the Reserve\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\n   * @return ltv the loan to value of the user\n   * @return liquidationThreshold the liquidation threshold of the NFT\n   * @return liquidationBonus the liquidation bonus of the NFT\n   **/\n  function getNftCollateralData(\n    address nftAsset,\n    uint256 nftTokenId,\n    address reserveAsset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralInETH,\n      uint256 totalCollateralInReserve,\n      uint256 availableBorrowsInETH,\n      uint256 availableBorrowsInReserve,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (ltv, liquidationThreshold, liquidationBonus) = nftConfig.getCollateralParams();\n\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\n  }\n\n  /**\n   * @dev Returns the debt data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return reserveAsset the address of the Reserve\n   * @return totalCollateral the total power of the NFT\n   * @return totalDebt the total debt of the NFT\n   * @return availableBorrows the borrowing power left of the NFT\n   * @return healthFactor the current health factor of the NFT\n   **/\n  function getNftDebtData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (\n      uint256 loanId,\n      address reserveAsset,\n      uint256 totalCollateral,\n      uint256 totalDebt,\n      uint256 availableBorrows,\n      uint256 healthFactor\n    )\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId == 0) {\n      return (0, address(0), 0, 0, 0, 0);\n    }\n\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n\n    reserveAsset = loan.reserveAsset;\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\n\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\n      reserveAsset,\n      reserveData,\n      nftAsset,\n      nftTokenId,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\n      reserveAsset,\n      reserveData,\n      _addressesProvider.getLendPoolLoan(),\n      loanId,\n      _addressesProvider.getReserveOracle()\n    );\n\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\n\n    if (loan.state == DataTypes.LoanState.Active) {\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\n    }\n  }\n\n  /**\n   * @dev Returns the auction data of the NFT\n   * @param nftAsset The address of the NFT\n   * @param nftTokenId The token id of the NFT\n   * @return loanId the loan id of the NFT\n   * @return bidderAddress the highest bidder address of the loan\n   * @return bidPrice the highest bid price in Reserve of the loan\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\n   * @return bidFine the penalty fine of the loan\n   **/\n  function getNftAuctionData(\n    address nftAsset,\n    uint256 nftTokenId\n  )\n    external\n    view\n    override\n    returns (uint256 loanId, address bidderAddress, uint256 bidPrice, uint256 bidBorrowAmount, uint256 bidFine)\n  {\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\n\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\n    if (loanId != 0) {\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\n\n      bidderAddress = loan.bidderAddress;\n      bidPrice = loan.bidPrice;\n      bidBorrowAmount = loan.bidBorrowAmount;\n\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\n        loan.reserveAsset,\n        reserveData,\n        nftAsset,\n        nftConfig,\n        loan,\n        address(poolLoan),\n        _addressesProvider.getReserveOracle()\n      );\n    }\n  }\n\n  struct GetLiquidationPriceLocalVars {\n    address poolLoan;\n    uint256 loanId;\n    uint256 thresholdPrice;\n    uint256 liquidatePrice;\n    uint256 paybackAmount;\n    uint256 remainAmount;\n  }\n\n  /**\n   * @dev Returns the state and configuration of the nft\n   * @param nftAsset The address of the underlying asset of the nft\n   * @param nftTokenId The token ID of the asset\n   **/\n  function getNftLiquidatePrice(\n    address nftAsset,\n    uint256 nftTokenId\n  ) external view override returns (uint256 liquidatePrice, uint256 paybackAmount) {\n    GetLiquidationPriceLocalVars memory vars;\n\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\n    if (vars.loanId == 0) {\n      return (0, 0);\n    }\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = _nftConfig[nftAsset][nftTokenId];\n\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\n      vars.loanId,\n      loanData.reserveAsset,\n      reserveData,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      nftConfig,\n      vars.poolLoan,\n      _addressesProvider.getReserveOracle(),\n      _addressesProvider.getNFTOracle()\n    );\n\n    if (vars.liquidatePrice < vars.paybackAmount) {\n      vars.liquidatePrice = vars.paybackAmount;\n    }\n\n    return (vars.liquidatePrice, vars.paybackAmount);\n  }\n\n  /**\n   * @dev Validates and finalizes an uToken transfer\n   * - Only callable by the overlying uToken of the `asset`\n   * @param asset The address of the underlying asset of the uToken\n   * @param from The user from which the uToken are transferred\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address,\n    uint256,\n    uint256,\n    uint256\n  ) external view override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n    require(_msgSender() == reserve.uTokenAddress, Errors.LP_CALLER_MUST_BE_AN_UTOKEN);\n\n    ValidationLogic.validateTransfer(from, reserve);\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i != _reservesCount; ) {\n      _activeReserves[i] = _reservesList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the list of the initialized nfts\n   **/\n  function getNftsList() external view override returns (address[] memory) {\n    address[] memory _activeNfts = new address[](_nftsCount);\n    for (uint256 i = 0; i != _nftsCount; ) {\n      _activeNfts[i] = _nftsList[i];\n      unchecked {\n        ++i;\n      }\n    }\n    return _activeNfts;\n  }\n\n  /**\n   * @dev Set the _pause state of the pool\n   * - Only callable by the LendPoolConfigurator contract\n   * @param val `true` to pause the pool, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendPoolConfigurator {\n    if (_paused != val) {\n      _paused = val;\n      if (_paused) {\n        _pauseStartTime = block.timestamp;\n        emit Paused();\n      } else {\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\n        emit Unpaused();\n      }\n    }\n  }\n\n  /**\n   * @dev Returns if the LendPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\n    _pauseStartTime = startTime;\n    _pauseDurationTime = durationTime;\n    emit PausedTimeUpdated(startTime, durationTime);\n  }\n\n  function getPausedTime() external view override returns (uint256, uint256) {\n    return (_pauseStartTime, _pauseDurationTime);\n  }\n\n  /**\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Sets the max number of reserves in the protocol\n   * @param val the value to set the max number of reserves\n   **/\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addReserveToList`\n    _maxNumberOfReserves = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\n   */\n  function getMaxNumberOfReserves() external view override returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Sets the max number of NFTs in the protocol\n   * @param val the value to set the max number of NFTs\n   **/\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\n    require(val <= 255, Errors.LP_INVALID_OVERFLOW_VALUE); //Sanity check to avoid overflows in `_addNftToList`\n    _maxNumberOfNfts = val;\n  }\n\n  /**\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\n   */\n  function getMaxNumberOfNfts() external view override returns (uint256) {\n    return _maxNumberOfNfts;\n  }\n\n  function setLiquidateFeePercentage(uint256 percentage) external override onlyLendPoolConfigurator {\n    _liquidateFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns the liquidate fee percentage\n   */\n  function getLiquidateFeePercentage() external view override returns (uint256) {\n    return _liquidateFeePercentage;\n  }\n\n  /**\n   * @dev Sets the max timeframe between NFT config triggers and borrows\n   * @param timeframe the number of seconds for the timeframe\n   **/\n  function setTimeframe(uint256 timeframe) external override onlyLendPoolConfigurator {\n    _timeframe = timeframe;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getTimeframe() external view override returns (uint256) {\n    return _timeframe;\n  }\n\n  /**\n   * @dev Allows and address to be sold on NFTX\n   * @param nftAsset the address of the NFT\n   **/\n  function setIsMarketSupported(address nftAsset, uint8 market, bool val) external override onlyLendPoolConfigurator {\n    require(nftAsset != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _isMarketSupported[nftAsset][market] = val;\n  }\n\n  /**\n   * @dev Returns the max timeframe between NFT config triggers and borrows\n   **/\n  function getIsMarketSupported(address nftAsset, uint8 market) external view override returns (bool) {\n    return _isMarketSupported[nftAsset][market];\n  }\n\n  /**\n   * @dev Sets configFee amount to be charged for ConfigureNFTAsColleteral\n   * @param configFee the number of seconds for the timeframe\n   **/\n  function setConfigFee(uint256 configFee) external override onlyLendPoolConfigurator {\n    _configFee = configFee;\n  }\n\n  /**\n   * @dev Returns the configFee amount\n   **/\n  function getConfigFee() external view override returns (uint256) {\n    return _configFee;\n  }\n\n  /**\n   * @dev sets the fee to be charged on first bid on nft\n   * @param auctionDurationConfigFee the amount to charge to the user\n   **/\n  function setAuctionDurationConfigFee(uint256 auctionDurationConfigFee) external override onlyLendPoolConfigurator {\n    _auctionDurationConfigFee = auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Returns the auctionDurationConfigFee amount\n   **/\n  function getAuctionDurationConfigFee() public view override returns (uint256) {\n    return _auctionDurationConfigFee;\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an uToken and nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param uTokenAddress The address of the uToken that will be assigned to the reserve\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\n   * @param interestRateAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address uTokenAddress,\n    address debtTokenAddress,\n    address interestRateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(\n      uTokenAddress != address(0) && debtTokenAddress != address(0) && interestRateAddress != address(0),\n      Errors.INVALID_ZERO_ADDRESS\n    );\n    _reserves[asset].init(uTokenAddress, debtTokenAddress, interestRateAddress);\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Initializes a nft, activating it, assigning nft loan and an\n   * interest rate strategy\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the nft\n   * @param uNftAddress the address of the UNFT regarding the chosen asset\n   **/\n  function initNft(address asset, address uNftAddress) external override onlyLendPoolConfigurator {\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\n    require(uNftAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _nfts[asset].init(uNftAddress);\n    _addNftToList(asset);\n\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\n\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, uNftAddress);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateAddress(\n    address asset,\n    address rateAddress\n  ) external override onlyLendPoolConfigurator {\n    require(asset != address(0) && rateAddress != address(0), Errors.INVALID_ZERO_ADDRESS);\n    _reserves[asset].interestRateAddress = rateAddress;\n    emit ReserveInterestRateAddressChanged(asset, rateAddress);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _reserves[asset].configuration.data = configuration;\n    emit ReserveConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\n    _nfts[asset].configuration.data = configuration;\n    emit NftConfigurationChanged(asset, configuration);\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the NFT as a whole\n   * - Only callable by the LendPoolConfigurator contract\n   * @param asset The address of the asset of the NFT\n   * @param nftTokenId the tokenId of the asset\n   * @param configuration The new configuration bitmap\n   **/\n  function setNftConfigByTokenId(\n    address asset,\n    uint256 nftTokenId,\n    uint256 configuration\n  ) external override onlyLendPoolConfigurator {\n    _nftConfig[asset][nftTokenId].data = configuration;\n    emit NftConfigurationByIdChanged(asset, nftTokenId, configuration);\n  }\n\n  /**\n   * @dev Sets the max supply and token ID for a given asset\n   * @param asset The address to set the data\n   * @param maxSupply The max supply value\n   * @param maxTokenId The max token ID value\n   **/\n  function setNftMaxSupplyAndTokenId(\n    address asset,\n    uint256 maxSupply,\n    uint256 maxTokenId\n  ) external override onlyLendPoolConfigurator {\n    _nfts[asset].maxSupply = maxSupply;\n    _nfts[asset].maxTokenId = maxTokenId;\n  }\n\n  /**\n   * @notice Rescue tokens and ETH locked up in this contract.\n   * @param tokenContract ERC20 token contract address\n   * @param to        Recipient address\n   * @param amount    Amount to withdraw\n   */\n  function rescue(\n    IERC20 tokenContract,\n    address to,\n    uint256 amount,\n    bool rescueETH\n  ) external override nonReentrant onlyRescuer {\n    if (rescueETH) {\n      (bool sent, ) = to.call{value: amount}(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      tokenContract.safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @notice Rescue NFTs locked up in this contract.\n   * @param nftAsset ERC721 asset contract address\n   * @param tokenId ERC721 token id\n   * @param to Recipient address\n   */\n  function rescueNFT(\n    IERC721Upgradeable nftAsset,\n    uint256 tokenId,\n    address to\n  ) external override nonReentrant onlyRescuer {\n    nftAsset.safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @notice Assign the rescuer role to a given address.\n   * @param newRescuer New rescuer's address\n   */\n  function updateRescuer(address newRescuer) external override onlyLendPoolConfigurator {\n    require(newRescuer != address(0), \"Rescuable: new rescuer is the zero address\");\n    _rescuer = newRescuer;\n    emit RescuerChanged(newRescuer);\n  }\n\n  /**\n   * @notice Returns current rescuer\n   * @return Rescuer's address\n   */\n  function rescuer() external view override returns (address) {\n    return _rescuer;\n  }\n\n  /**\n   * @notice Update the safe health factor value for redeems\n   * @param newSafeHealthFactor New safe health factor value\n   */\n  function updateSafeHealthFactor(uint256 newSafeHealthFactor) external override onlyPoolAdmin {\n    require(newSafeHealthFactor != 0, Errors.LP_INVALID_SAFE_HEALTH_FACTOR);\n    _safeHealthFactor = newSafeHealthFactor;\n    emit SafeHealthFactorUpdated(newSafeHealthFactor);\n  }\n\n  /**\n   * @notice Returns current safe health factor\n   * @return The safe health factor value\n   */\n  function getSafeHealthFactor() external view override returns (uint256) {\n    return _safeHealthFactor;\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function _addNftToList(address asset) internal {\n    uint256 nftsCount = _nftsCount;\n\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\n\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\n\n    if (!nftAlreadyAdded) {\n      _nfts[asset].id = uint8(nftsCount);\n      _nftsList[nftsCount] = asset;\n\n      _nftsCount = nftsCount + 1;\n    }\n  }\n\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\n  }\n\n  receive() external payable {}\n}\n","line":244,"range":[10121,10480]},"functionType":1},{"type":0,"sourceReference":{"function":"executeBorrow","contract":"BorrowLogic","sourceName":"contracts/libraries/logic/BorrowLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Unlockd\n * @notice Implements the logic to borrow feature\n */\nlibrary BorrowLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on borrow() when loan needs to be opened\n   * @param user The address of the user initiating the borrow(), receiving the funds\n   * @param reserve The address of the underlying asset being borrowed\n   * @param amount The amount borrowed out\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the loan\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address indexed onBehalfOf,\n    uint256 borrowRate,\n    uint256 loanId,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param user The address of the user initiating the repay(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param amount The amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Repay(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct ExecuteBorrowLocalVars {\n    address initiator;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 loanId;\n    address reserveOracle;\n    address nftOracle;\n    address loanAddress;\n    uint256 totalSupply;\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) external {\n    _borrow(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `_borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function _borrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) internal {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    ExecuteBorrowLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n    // Convert asset amount to ETH\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    vars.totalSupply = IERC721EnumerableUpgradeable(params.nftAsset).totalSupply();\n    require(vars.totalSupply <= nftData.maxSupply, Errors.LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT);\n    require(params.nftTokenId <= nftData.maxTokenId, Errors.LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT);\n    ValidationLogic.validateBorrow(\n      params,\n      reserveData,\n      nftData,\n      nftConfig,\n      vars.loanAddress,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    require(IUToken(uToken).getAvailableLiquidity() >= params.amount, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n\n    if (vars.loanId == 0) {\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\n\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\n        vars.initiator,\n        params.onBehalfOf,\n        params.nftAsset,\n        params.nftTokenId,\n        nftData.uNftAddress,\n        params.asset,\n        params.amount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.loanAddress).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        params.amount,\n        0,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.initiator,\n      params.onBehalfOf,\n      params.amount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(params.asset, uToken, 0, params.amount);\n\n    // Withdraw amount from external lending protocol\n    uint256 value = IUToken(uToken).withdrawReserves(params.amount);\n\n    // Transfer underlying to user\n    IUToken(uToken).transferUnderlyingTo(vars.initiator, value);\n\n    emit Borrow(\n      vars.initiator,\n      params.asset,\n      value,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      reserveData.currentVariableBorrowRate,\n      vars.loanId,\n      params.referralCode\n    );\n  }\n\n  struct RepayLocalVars {\n    address initiator;\n    address poolLoan;\n    address onBehalfOf;\n    uint256 loanId;\n    bool isUpdate;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function executeRepay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256, bool) {\n    return _repay(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function _repay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) internal returns (uint256, bool) {\n    RepayLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\n\n    ValidationLogic.validateRepay(reserveData, nftData, nftConfig, loanData, params.amount, vars.borrowAmount);\n\n    vars.repayAmount = vars.borrowAmount;\n    vars.isUpdate = false;\n    if (params.amount < vars.repayAmount) {\n      vars.isUpdate = true;\n      vars.repayAmount = params.amount;\n    }\n\n    if (vars.isUpdate) {\n      ILendPoolLoan(vars.poolLoan).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        0,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.poolLoan).repayLoan(\n        vars.initiator,\n        vars.loanId,\n        nftData.uNftAddress,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount repaid to external lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    // transfer erc721 to borrower\n    if (!vars.isUpdate) {\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\n    }\n\n    emit Repay(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount, !vars.isUpdate);\n  }\n}\n","line":108,"range":[4269,4339]},"functionType":1},{"type":0,"sourceReference":{"function":"_borrow","contract":"BorrowLogic","sourceName":"contracts/libraries/logic/BorrowLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\nimport {IDebtToken} from \"../../interfaces/IDebtToken.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolAddressesProvider} from \"../../interfaces/ILendPoolAddressesProvider.sol\";\nimport {IReserveOracleGetter} from \"../../interfaces/IReserveOracleGetter.sol\";\nimport {INFTOracleGetter} from \"../../interfaces/INFTOracleGetter.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\n\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Unlockd\n * @notice Implements the logic to borrow feature\n */\nlibrary BorrowLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @dev Emitted on borrow() when loan needs to be opened\n   * @param user The address of the user initiating the borrow(), receiving the funds\n   * @param reserve The address of the underlying asset being borrowed\n   * @param amount The amount borrowed out\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param onBehalfOf The address that will be getting the loan\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address nftAsset,\n    uint256 nftTokenId,\n    address indexed onBehalfOf,\n    uint256 borrowRate,\n    uint256 loanId,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param user The address of the user initiating the repay(), providing the funds\n   * @param reserve The address of the underlying asset of the reserve\n   * @param amount The amount repaid\n   * @param nftAsset The address of the underlying NFT used as collateral\n   * @param nftTokenId The token id of the underlying NFT used as collateral\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\n   * @param loanId The loan ID of the NFT loans\n   **/\n  event Repay(\n    address user,\n    address indexed reserve,\n    uint256 amount,\n    address indexed nftAsset,\n    uint256 nftTokenId,\n    address indexed borrower,\n    uint256 loanId\n  );\n\n  struct ExecuteBorrowLocalVars {\n    address initiator;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 loanId;\n    address reserveOracle;\n    address nftOracle;\n    address loanAddress;\n    uint256 totalSupply;\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) external {\n    _borrow(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the borrow feature. Through `_borrow()`, users borrow assets from the protocol.\n   * @dev Emits the `Borrow()` event.\n   * @param addressesProvider The addresses provider\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function _borrow(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) internal {\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\n\n    ExecuteBorrowLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n    // Convert asset amount to ETH\n    vars.reserveOracle = addressesProvider.getReserveOracle();\n    vars.nftOracle = addressesProvider.getNFTOracle();\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    vars.totalSupply = IERC721EnumerableUpgradeable(params.nftAsset).totalSupply();\n    require(vars.totalSupply <= nftData.maxSupply, Errors.LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT);\n    require(params.nftTokenId <= nftData.maxTokenId, Errors.LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT);\n    ValidationLogic.validateBorrow(\n      params,\n      reserveData,\n      nftData,\n      nftConfig,\n      vars.loanAddress,\n      vars.loanId,\n      vars.reserveOracle,\n      vars.nftOracle\n    );\n\n    address uToken = reserveData.uTokenAddress;\n\n    require(IUToken(uToken).getAvailableLiquidity() >= params.amount, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n\n    if (vars.loanId == 0) {\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\n\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\n        vars.initiator,\n        params.onBehalfOf,\n        params.nftAsset,\n        params.nftTokenId,\n        nftData.uNftAddress,\n        params.asset,\n        params.amount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.loanAddress).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        params.amount,\n        0,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).mint(\n      vars.initiator,\n      params.onBehalfOf,\n      params.amount,\n      reserveData.variableBorrowIndex\n    );\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(params.asset, uToken, 0, params.amount);\n\n    // Withdraw amount from external lending protocol\n    uint256 value = IUToken(uToken).withdrawReserves(params.amount);\n\n    // Transfer underlying to user\n    IUToken(uToken).transferUnderlyingTo(vars.initiator, value);\n\n    emit Borrow(\n      vars.initiator,\n      params.asset,\n      value,\n      params.nftAsset,\n      params.nftTokenId,\n      params.onBehalfOf,\n      reserveData.currentVariableBorrowRate,\n      vars.loanId,\n      params.referralCode\n    );\n  }\n\n  struct RepayLocalVars {\n    address initiator;\n    address poolLoan;\n    address onBehalfOf;\n    uint256 loanId;\n    bool isUpdate;\n    uint256 borrowAmount;\n    uint256 repayAmount;\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function executeRepay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256, bool) {\n    return _repay(addressesProvider, reservesData, nftsData, nftsConfig, params);\n  }\n\n  /**\n   * @notice Implements the repay feature. Through `repay()`, users repay assets to the protocol.\n   * @dev Emits the `Repay()` event.\n   * @param reservesData The state of all the reserves\n   * @param nftsData The state of all the nfts\n   * @param params The additional parameters needed to execute the repay function\n   */\n  function _repay(\n    ILendPoolAddressesProvider addressesProvider,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(address => DataTypes.NftData) storage nftsData,\n    mapping(address => mapping(uint256 => DataTypes.NftConfigurationMap)) storage nftsConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) internal returns (uint256, bool) {\n    RepayLocalVars memory vars;\n    vars.initiator = params.initiator;\n\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\n\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\n\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\n\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\n    DataTypes.NftConfigurationMap storage nftConfig = nftsConfig[params.nftAsset][params.nftTokenId];\n\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\n    reserveData.updateState();\n\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\n\n    ValidationLogic.validateRepay(reserveData, nftData, nftConfig, loanData, params.amount, vars.borrowAmount);\n\n    vars.repayAmount = vars.borrowAmount;\n    vars.isUpdate = false;\n    if (params.amount < vars.repayAmount) {\n      vars.isUpdate = true;\n      vars.repayAmount = params.amount;\n    }\n\n    if (vars.isUpdate) {\n      ILendPoolLoan(vars.poolLoan).updateLoan(\n        vars.initiator,\n        vars.loanId,\n        0,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    } else {\n      ILendPoolLoan(vars.poolLoan).repayLoan(\n        vars.initiator,\n        vars.loanId,\n        nftData.uNftAddress,\n        vars.repayAmount,\n        reserveData.variableBorrowIndex\n      );\n    }\n\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\n\n    address uToken = reserveData.uTokenAddress;\n\n    // update interest rate according latest borrow amount (utilizaton)\n    reserveData.updateInterestRates(loanData.reserveAsset, uToken, vars.repayAmount, 0);\n\n    // transfer repay amount to uToken\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, uToken, vars.repayAmount);\n\n    // Deposit amount repaid to external lending protocol\n    IUToken(uToken).depositReserves(vars.repayAmount);\n\n    // transfer erc721 to borrower\n    if (!vars.isUpdate) {\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\n    }\n\n    emit Repay(\n      vars.initiator,\n      loanData.reserveAsset,\n      vars.repayAmount,\n      loanData.nftAsset,\n      loanData.nftTokenId,\n      loanData.borrower,\n      vars.loanId\n    );\n\n    return (vars.repayAmount, !vars.isUpdate);\n  }\n}\n","line":146,"range":[6223,6415]},"functionType":1},{"type":0,"sourceReference":{"function":"validateBorrow","contract":"ValidationLogic","sourceName":"contracts/libraries/logic/ValidationLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ValidationLogic library\n * @author Unlockd\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveData The reserve state\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveData storage reserveData,\n    uint256 amount,\n    uint256 userBalance,\n    address uToken\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    // Case where there is not enough liquidity to cover user's withdrawal\n    uint256 availableLiquidity = IUToken(uToken).getAvailableLiquidity();\n    require(amount <= availableLiquidity, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeeded;\n    uint256 userCollateralBalance;\n    uint256 userBorrowBalance;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool nftIsActive;\n    bool nftIsFrozen;\n    address loanReserveAsset;\n    address loanBorrower;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param reserveData The reserve state from which the user is borrowing\n   * @param nftData The state of the user for the specific nft\n   */\n  function validateBorrow(\n    DataTypes.ExecuteBorrowParams memory params,\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(params.amount > 0, Errors.VL_INVALID_AMOUNT);\n\n    if (loanId != 0) {\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\n\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n      require(params.asset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\n      require(params.onBehalfOf == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\n    }\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\n      .configuration\n      .getFlags();\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    (vars.nftIsActive, vars.nftIsFrozen) = nftConfig.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    require(\n      (nftConfig.getConfigTimestamp() + ILendPool(address(this)).getTimeframe()) >= block.timestamp,\n      Errors.VL_TIMEFRAME_EXCEEDED\n    );\n\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\n      params.asset,\n      reserveData,\n      params.nftAsset,\n      params.nftTokenId,\n      nftConfig,\n      loanAddress,\n      loanId,\n      reserveOracle,\n      nftOracle\n    );\n\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    //LTV is calculated in percentage\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + params.amount).percentDiv(vars.currentLtv);\n\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserveData The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param borrowAmount The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amountSent,\n    uint256 borrowAmount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\n\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the auction action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The nft data of the underlying nft\n   * @param bidPrice Total variable debt balance of the user\n   **/\n  function validateAuction(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 bidPrice\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates a redeem action\n   * @param reserveData The reserve state\n   * @param nftData The nft state\n   */\n  function validateRedeem(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidate(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the liquidation NFTX action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidateMarkets(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev Loan requires to be in `Active` state. The Markets liquidate process is triggered if there has not been any auction\n     * and the auction time has passed. In that case, loan is not in `Auction` nor `Defaulted`,  and needs to be liquidated in a third-party market.\n     */\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates an uToken transfer\n   * @param from The user from which the uTokens are being transferred\n   * @param reserveData The state of the reserve\n   */\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\n    from;\n    reserveData;\n  }\n}\n","line":92,"range":[3448,6380]},"functionType":1},{"type":4,"sourceReference":{"function":"validateDeposit","contract":"ValidationLogic","sourceName":"contracts/libraries/logic/ValidationLogic.sol","sourceContent":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {NftConfiguration} from \"../configuration/NftConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ILendPoolLoan} from \"../../interfaces/ILendPoolLoan.sol\";\nimport {ILendPool} from \"../../interfaces/ILendPool.sol\";\nimport {IUToken} from \"../../interfaces/IUToken.sol\";\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/**\n * @title ValidationLogic library\n * @author Unlockd\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using NftConfiguration for DataTypes.NftConfigurationMap;\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveData The reserve state\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveData storage reserveData,\n    uint256 amount,\n    uint256 userBalance,\n    address uToken\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    // Case where there is not enough liquidity to cover user's withdrawal\n    uint256 availableLiquidity = IUToken(uToken).getAvailableLiquidity();\n    require(amount <= availableLiquidity, Errors.LP_RESERVES_WITHOUT_ENOUGH_LIQUIDITY);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeeded;\n    uint256 userCollateralBalance;\n    uint256 userBorrowBalance;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool nftIsActive;\n    bool nftIsFrozen;\n    address loanReserveAsset;\n    address loanBorrower;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param reserveData The reserve state from which the user is borrowing\n   * @param nftData The state of the user for the specific nft\n   */\n  function validateBorrow(\n    DataTypes.ExecuteBorrowParams memory params,\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    address loanAddress,\n    uint256 loanId,\n    address reserveOracle,\n    address nftOracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(params.amount > 0, Errors.VL_INVALID_AMOUNT);\n\n    if (loanId != 0) {\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\n\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n      require(params.asset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\n      require(params.onBehalfOf == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\n    }\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\n      .configuration\n      .getFlags();\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    (vars.nftIsActive, vars.nftIsFrozen) = nftConfig.getFlags();\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\n\n    require(\n      (nftConfig.getConfigTimestamp() + ILendPool(address(this)).getTimeframe()) >= block.timestamp,\n      Errors.VL_TIMEFRAME_EXCEEDED\n    );\n\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftConfig.getCollateralParams();\n\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\n      params.asset,\n      reserveData,\n      params.nftAsset,\n      params.nftTokenId,\n      nftConfig,\n      loanAddress,\n      loanId,\n      reserveOracle,\n      nftOracle\n    );\n\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    //LTV is calculated in percentage\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + params.amount).percentDiv(vars.currentLtv);\n\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserveData The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param borrowAmount The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amountSent,\n    uint256 borrowAmount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\n\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the auction action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The nft data of the underlying nft\n   * @param bidPrice Total variable debt balance of the user\n   **/\n  function validateAuction(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 bidPrice\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\n      Errors.LPL_INVALID_LOAN_STATE\n    );\n\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates a redeem action\n   * @param reserveData The reserve state\n   * @param nftData The nft state\n   */\n  function validateRedeem(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData,\n    uint256 amount\n  ) external view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidate(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates the liquidation NFTX action\n   * @param reserveData The reserve data of the principal\n   * @param nftData The data of the underlying NFT\n   * @param loanData The loan data of the underlying NFT\n   **/\n  function validateLiquidateMarkets(\n    DataTypes.ReserveData storage reserveData,\n    DataTypes.NftData storage nftData,\n    DataTypes.NftConfigurationMap storage nftConfig,\n    DataTypes.LoanData memory loanData\n  ) internal view {\n    require(nftData.uNftAddress != address(0), Errors.LPC_INVALID_UNFT_ADDRESS);\n    require(reserveData.uTokenAddress != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\n\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev additional check for individual asset\n     */\n    require(nftConfig.getActive(), Errors.VL_NO_ACTIVE_NFT);\n\n    /**\n     * @dev Loan requires to be in `Active` state. The Markets liquidate process is triggered if there has not been any auction\n     * and the auction time has passed. In that case, loan is not in `Auction` nor `Defaulted`,  and needs to be liquidated in a third-party market.\n     */\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\n  }\n\n  /**\n   * @dev Validates an uToken transfer\n   * @param from The user from which the uTokens are being transferred\n   * @param reserveData The state of the reserve\n   */\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\n    from;\n    reserveData;\n  }\n}\n","line":41,"range":[1795,1841]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,51,48,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033330310000000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)



